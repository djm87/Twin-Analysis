
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <title> Function Reference (MTEX Toolbox)
         
      </title>
      <!-- DOCNAME: MTEX Toolbox -->
      <meta name="chunktype" content="refpage">
      <!-- CHUNKNAME:  -->
      <!-- HEADSTUFF:  -->
      <!-- HEADSTUFF -->
      <meta name="refentity" content="method:">
      <meta http-equiv="Content-Script-Type" content="text/javascript">
      <meta name="toctype" content="fcn">
      <link rel="stylesheet" href="style.css"><script language="JavaScript" src="docscripts.js"></script></head>
   <body><a name="top_of_page"></a><div>
         <table class="nav" summary="Navigation aid" border="0" width="100%" cellpadding="0" cellspacing="0">
            <tr>
               <td valign="baseline"><b>MTEX</b> - A MATLAB Toolbox for Quantitative Texture Analysis</td>
            </tr>
         </table>
         <p style="font-size:1px;"></p>
      </div>
      <div class="content">
         <h1 class="refname"> Function Reference</h1>
         <div class="subheading">
            <div class="funcrefpage"><a href="funcref_alph.html">&gt;&gt; Alphabetical List</a></div>
            <table class="ref" width="90%">
               <tr>
                  <td valign="top" width="250px"><a href="#1"> Classes representing Geometry 
                        <td valign="top" width="75%"></td></a></td>
               </tr>
               <tr>
                  <td valign="top" width="250px"><a href="#14"> Classes for Quantitative Texture Analysis
                        <td valign="top" width="75%"></td></a></td>
               </tr>
               <tr>
                  <td valign="top" width="250px"><a href="#21"> Auxiliary Functions
                        <td valign="top" width="75%">Helper functions making life easier
                           
                            Below you can find a series of powerful all purpose tools provided by 
                            the MTEX toolbox.
                        </td></a></td>
               </tr>
            </table>
         </div>
         <h2> Classes representing Geometry <a name="1"> </a></h2>
         <table class="ref" width="90%">
            <tr>
               <td valign="top" width="250px"><a href="#2"> Specimen Directions (The Class @vector3d)
                     <td valign="top" width="75%">This section describes the class *vector3d* and gives an overview how to
                         deal with specimen directions in MTEX.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#3"> Crystal Directions (The Class @Miller)
                     <td valign="top" width="75%">This section describes the class *Miller* and gives an overview how to
                         deal with crystal directions in MTEX.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#4"> Crystal Shapes (The Class @crystalShape)
                     <td valign="top" width="75%">How to draw threedimensional representations of crystals.</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#5"> Rotations (The Class @rotation)
                     <td valign="top" width="75%">This section describes the class  &lt;rotation.rotation.html *rotation*&gt; and
                         gives an overview on how to work with rotations in MTEX.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#6"> Crystal and Specimen Symmetries (The Class @symmetry)
                     <td valign="top" width="75%">This section describes the class *symmetry* and gives an overview how to
                         deal with crystal symmetries in MTEX.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#7"> Crystal Orientations (The Class @orientation)
                     <td valign="top" width="75%">This sections describes the class *orientation* and gives an overview how
                         to work with crystal orientation in MTEX.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#8"> Fibres
                     <td valign="top" width="75%">This sections describes the class &lt;fibre_index.html fibre&gt; and gives an
                         overview how to work with fibres in MTEX.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#9"> Slip Systems (The Class @slipSystem)
                     <td valign="top" width="75%">This section describes the class *slipSystem*.</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#10"> Quaternions (The Class @quaternion)
                     <td valign="top" width="75%">class representing orientations</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#11"> Discretisation of 1-Sphere (The Class @S1Grid)
                     <td valign="top" width="75%">S1Grid is a class of purely internal use</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#12"> Discretisation of 2 - Sphere (The Class @S2Grid)
                     <td valign="top" width="75%">represents a grid of nodes on the sphere</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#13"> Discretisation of Orientation Space (The Class SO3Grid)
                     <td valign="top" width="75%">represents a set of orientations</td></a></td>
            </tr>
         </table>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="fundamentalRegion.html"><tt>fundamentalRegion</tt></a></td>
            <td>get the fundamental zone in orientation space for a symmetry</td>
            <tr></tr>
            <td width="250px"><a href="plotAngleDistribution.html"><tt>plotAngleDistribution</tt></a></td>
            <td>plot axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="plotAxisDistribution.html"><tt>plotAxisDistribution</tt></a></td>
            <td>plot axis distribution</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2> Specimen Directions (The Class @vector3d)<a name="2"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="vector3d.abs.html"><tt>abs</tt></a></td>
            <td>length of vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.accumarray.html"><tt>accumarray</tt></a></td>
            <td>accumarray for vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.angle.html"><tt>angle</tt></a></td>
            <td>angle between two vectors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.angle_outer.html"><tt>angle_outer</tt></a></td>
            <td>angle between two vectors Input v1, v2 - @vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.arrow3d.html"><tt>arrow3d</tt></a></td>
            <td>plot three dimensional arrows</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcDelaunay.html"><tt>calcDelaunay</tt></a></td>
            <td>compute the Delaynay triangulation for a spherical grid</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcDensity.html"><tt>calcDensity</tt></a></td>
            <td>calculate a density function out of (weighted) unit vectors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcQuadratureWeights.html"><tt>calcQuadratureWeights</tt></a></td>
            <td>compute the area of the Voronoi decomposition</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcVoronoi.html"><tt>calcVoronoi</tt></a></td>
            <td>compute the area of the Voronoi decomposition</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcVoronoiArea.html"><tt>calcVoronoiArea</tt></a></td>
            <td>compute the spherical area of the Voronoi decomposition</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cat.html"><tt>cat</tt></a></td>
            <td>implement cat for vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.centroid.html"><tt>centroid</tt></a></td>
            <td>compute the centroid of a 2d polygon in 3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.char.html"><tt>char</tt></a></td>
            <td>convert to char</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.circle.html"><tt>circle</tt></a></td>
            <td>annotated a circle</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.contour.html"><tt>contour</tt></a></td>
            <td>spherical contour plot</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.contourf.html"><tt>contourf</tt></a></td>
            <td>spherical filled contour plot</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cross.html"><tt>cross</tt></a></td>
            <td>pointwise cross product of two vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cross_outer.html"><tt>cross_outer</tt></a></td>
            <td>pointwise cross product of two vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.ctranspose.html"><tt>ctranspose</tt></a></td>
            <td>transpose vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.det.html"><tt>det</tt></a></td>
            <td>pointwise determinant or triple product of three vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.dot.html"><tt>dot</tt></a></td>
            <td>pointwise inner product</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.dot_outer.html"><tt>dot_outer</tt></a></td>
            <td>outer dot product</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.double.html"><tt>double</tt></a></td>
            <td>converts vector3d to double Input v - @vector3d Output x, y, z - double</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.dyad.html"><tt>dyad</tt></a></td>
            <td>dyadic tensor product</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.end.html"><tt>end</tt></a></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.eq.html"><tt>eq</tt></a></td>
            <td>? v1 == v2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.exp.html"><tt>exp</tt></a></td>
            <td>rotation vector to rotation</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.export.html"><tt>export</tt></a></td>
            <td>export quaternions to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.find.html"><tt>find</tt></a></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.horzcat.html"><tt>horzcat</tt></a></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.interp.html"><tt>interp</tt></a></td>
            <td>spherical interpolation - including some smoothing</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.isPerp.html"><tt>isPerp</tt></a></td>
            <td>check whether v1 and v2 are orthogonal</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.isempty.html"><tt>isempty</tt></a></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.length.html"><tt>length</tt></a></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.line.html"><tt>line</tt></a></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.mean.html"><tt>mean</tt></a></td>
            <td>computes the mean vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.minus.html"><tt>minus</tt></a></td>
            <td>overload minus</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.mpower.html"><tt>mpower</tt></a></td>
            <td>n-th dyadic product</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.mtimes.html"><tt>mtimes</tt></a></td>
            <td>scalar multiplication</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.ne.html"><tt>ne</tt></a></td>
            <td>? v1 == v2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.norm.html"><tt>norm</tt></a></td>
            <td>vector norm</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.normalize.html"><tt>normalize</tt></a></td>
            <td>normalize a vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.orth.html"><tt>orth</tt></a></td>
            <td>an arbitrary orthogonal vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.orthProj.html"><tt>orthProj</tt></a></td>
            <td>vector3d/orthProj is a function. v = orthProj(v, N)</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.pcolor.html"><tt>pcolor</tt></a></td>
            <td>spherical contour plot</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.perp.html"><tt>perp</tt></a></td>
            <td>conmpute an vector best orthogonal to a list of directions</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.planeIntersect.html"><tt>planeIntersect</tt></a></td>
            <td>pointwise determinant or triple product of three vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plot.html"><tt>plot</tt></a></td>
            <td>plot vectors as two dimensional projections on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plot3d.html"><tt>plot3d</tt></a></td>
            <td>plot spherical data</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plotCustom.html"><tt>plotCustom</tt></a></td>
            <td>Syntax plotcustom(v,@(x,y) drawCommand(x,y))  %</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plus.html"><tt>plus</tt></a></td>
            <td>poitwise addition</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.polar.html"><tt>polar</tt></a></td>
            <td>cartesian to spherical coordinates Input v - @vector3d Output theta  - polar angle rho    - azimuthal angle  r      - radius</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.polyArea.html"><tt>polyArea</tt></a></td>
            <td>area of a flat polygon given by vertices v1, v2, ..., v_n</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a></td>
            <td>projects vectors to the fundamental sector of the inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.quiver.html"><tt>quiver</tt></a></td>
            <td>Syntax quiver(v,d)</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.quiver3.html"><tt>quiver3</tt></a></td>
            <td>Syntax quiver(v,d)</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rank.html"><tt>rank</tt></a></td>
            <td>rank = 1</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rdivide.html"><tt>rdivide</tt></a></td>
            <td>scalar division v ./ s</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.refine.html"><tt>refine</tt></a></td>
            <td>refine vectors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.region.html"><tt>region</tt></a></td>
            <td>vector3d/region is a function. sR = region(v, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.repmat.html"><tt>repmat</tt></a></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.reshape.html"><tt>reshape</tt></a></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rotate.html"><tt>rotate</tt></a></td>
            <td>rotate vector3d by rotation or orientation</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rotate_outer.html"><tt>rotate_outer</tt></a></td>
            <td>rotate vector3d by quaternion</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.scatter.html"><tt>scatter</tt></a></td>
            <td>Syntax scatter(v)              % plot the directions v scatter(v,data)         % colorize directions according to data scatter(v,'label',text)
               % plot text below markers scatter(v,'label',text,'textaboveMarker') % plot text above markers
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.scatter3d.html"><tt>scatter3d</tt></a></td>
            <td>plot spherical data</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.setdiff.html"><tt>setdiff</tt></a></td>
            <td>remove vectors v2 from a set of vectors v1</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.size.html"><tt>size</tt></a></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.smooth.html"><tt>smooth</tt></a></td>
            <td>low level function for plotting functions on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.sparse.html"><tt>sparse</tt></a></td>
            <td>SPARSE Create sparse matrix. S = SPARSE(X) converts a sparse or full matrix to sparse form by squeezing out any zero elements.</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subSet.html"><tt>subSet</tt></a></td>
            <td>subindex vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.sum.html"><tt>sum</tt></a></td>
            <td>sum of vectors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.surf.html"><tt>surf</tt></a></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.symmetrise.html"><tt>symmetrise</tt></a></td>
            <td>symmetrcially equivalent directions and its multiple</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.text.html"><tt>text</tt></a></td>
            <td>display a text in a spherical plot</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.text3.html"><tt>text3</tt></a></td>
            <td>plot three dimensional arrows</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.times.html"><tt>times</tt></a></td>
            <td>.* - componenwtise multiplication</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.transpose.html"><tt>transpose</tt></a></td>
            <td>transpose vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.uminus.html"><tt>uminus</tt></a></td>
            <td>overloads unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.unique.html"><tt>unique</tt></a></td>
            <td>disjoint list of vectors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.vector3d.html"><tt>vector3d</tt></a></td>
            <td>Constructor</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.vertcat.html"><tt>vertcat</tt></a></td>
            <td>overloads [v1,v2,v3..]</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Crystal Directions (The Class @Miller)<a name="3"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="Miller.Miller.html"><tt>Miller</tt></a></td>
            <td>define a crystal direction by Miller indice</td>
            <tr></tr>
            <td width="250px"><a href="Miller.calcDensity.html"><tt>calcDensity</tt></a></td>
            <td>calculate a density function out of (weighted) crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="Miller.cat.html"><tt>cat</tt></a></td>
            <td>concatenate lists of Miller indices to one list</td>
            <tr></tr>
            <td width="250px"><a href="Miller.char.html"><tt>char</tt></a></td>
            <td>Miller indece to string</td>
            <tr></tr>
            <td width="250px"><a href="Miller.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="Miller.dot.html"><tt>dot</tt></a></td>
            <td>inner product between two Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="Miller.dot_outer.html"><tt>dot_outer</tt></a></td>
            <td>inner product between two Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="Miller.dspacing.html"><tt>dspacing</tt></a></td>
            <td>space between crystal planes</td>
            <tr></tr>
            <td width="250px"><a href="Miller.exp.html"><tt>exp</tt></a></td>
            <td>misorientation vector to misorientation</td>
            <tr></tr>
            <td width="250px"><a href="Miller.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a></td>
            <td>projects vectors to the fundamental sector of the inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="Miller.region.html"><tt>region</tt></a></td>
            <td>return spherical region associated to a set of crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="Miller.rotate.html"><tt>rotate</tt></a></td>
            <td>rotate crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="Miller.rotate_outer.html"><tt>rotate_outer</tt></a></td>
            <td>rotate crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="Miller.round.html"><tt>round</tt></a></td>
            <td>tries to round miller indizes to greatest common divisor</td>
            <tr></tr>
            <td width="250px"><a href="Miller.scatter.html"><tt>scatter</tt></a></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="Miller.smooth.html"><tt>smooth</tt></a></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="Miller.surf.html"><tt>surf</tt></a></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="Miller.symmetrise.html"><tt>symmetrise</tt></a></td>
            <td>directions symmetrically equivalent to m</td>
            <tr></tr>
            <td width="250px"><a href="Miller.text.html"><tt>text</tt></a></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="Miller.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a></td>
            <td>change reference frame while keeping hkl or uvw</td>
            <tr></tr>
            <td width="250px"><a href="Miller.unique.html"><tt>unique</tt></a></td>
            <td>disjoint list of Miller indices</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Crystal Shapes (The Class @crystalShape)<a name="4"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="crystalShape.crystalShape.html"><tt>crystalShape</tt></a></td>
            <td>a class representing crystal shapes.</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.fitArea.html"><tt>fitArea</tt></a></td>
            <td>change habitus of crystal shape to fit given faceAreas</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.length.html"><tt>length</tt></a></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.mtimes.html"><tt>mtimes</tt></a></td>
            <td>*   Matrix multiply. X*Y is the matrix product of X and Y.  Any scalar (a 1-by-1 matrix) may multiply anything.  Otherwise,
               the number of columns of X must equal the number of rows of Y.
            </td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.plot.html"><tt>plot</tt></a></td>
            <td>colorize grains</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.plus.html"><tt>plus</tt></a></td>
            <td>crystal shape should be first argument</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.repmat.html"><tt>repmat</tt></a></td>
            <td>implements repmat for crystalShape</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.reshape.html"><tt>reshape</tt></a></td>
            <td>RESHAPE Reshape array. RESHAPE(X,M,N) or RESHAPE(X,[M,N]) returns the M-by-N matrix  whose elements are taken columnwise from
               X. An error results  if X does not have M*N elements.
            </td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.rotate.html"><tt>rotate</tt></a></td>
            <td>rotate a crystal shape by an rotation or orientation</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.rotate_outer.html"><tt>rotate_outer</tt></a></td>
            <td>rotate a crystal shape by an rotation or orientation</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.size.html"><tt>size</tt></a></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.subSet.html"><tt>subSet</tt></a></td>
            <td>crystalShape/subSet is a function. cS = subSet(cS, NSelect)</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.times.html"><tt>times</tt></a></td>
            <td>.*  Array multiply. X.*Y denotes element-by-element multiplication. X and Y must have compatible sizes. In the simplest cases,
               they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension
               sizes of the inputs are either the same or one of them is 1.
            </td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Rotations (The Class @rotation)<a name="5"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="rotation.byAxisAngle.html"><tt>byAxisAngle</tt></a></td>
            <td>define rotations by rotational axis and rotational angle</td>
            <tr></tr>
            <td width="250px"><a href="rotation.byEuler.html"><tt>byEuler</tt></a></td>
            <td>define rotentations by Euler angles</td>
            <tr></tr>
            <td width="250px"><a href="rotation.byMatrix.html"><tt>byMatrix</tt></a></td>
            <td>define rotations by matrices</td>
            <tr></tr>
            <td width="250px"><a href="rotation.cat.html"><tt>cat</tt></a></td>
            <td>implement cat for rotation</td>
            <tr></tr>
            <td width="250px"><a href="rotation.char.html"><tt>char</tt></a></td>
            <td>quaternion to char</td>
            <tr></tr>
            <td width="250px"><a href="rotation.display.html"><tt>display</tt></a></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="rotation.dot.html"><tt>dot</tt></a></td>
            <td>compute rot1 . rot2</td>
            <tr></tr>
            <td width="250px"><a href="rotation.dot_outer.html"><tt>dot_outer</tt></a></td>
            <td>dot_outer</td>
            <tr></tr>
            <td width="250px"><a href="rotation.getMinAxes.html"><tt>getMinAxes</tt></a></td>
            <td>rotation/getMinAxes is a function. [axes, angle] = getMinAxes(rot)</td>
            <tr></tr>
            <td width="250px"><a href="rotation.isImproper.html"><tt>isImproper</tt></a></td>
            <td>rotation/isImproper is a function. out = isImproper(r)</td>
            <tr></tr>
            <td width="250px"><a href="rotation.line.html"><tt>line</tt></a></td>
            <td>draw rotations connected by lines</td>
            <tr></tr>
            <td width="250px"><a href="rotation.map.html"><tt>map</tt></a></td>
            <td>define rotations by pairs of vectors</td>
            <tr></tr>
            <td width="250px"><a href="rotation.matrix.html"><tt>matrix</tt></a></td>
            <td>quaternion to direction cosine matrix conversion converts direction cosine matrix to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="rotation.mldivide.html"><tt>mldivide</tt></a></td>
            <td>o \ v</td>
            <tr></tr>
            <td width="250px"><a href="rotation.mtimes.html"><tt>mtimes</tt></a></td>
            <td>r = a * b</td>
            <tr></tr>
            <td width="250px"><a href="rotation.permute.html"><tt>permute</tt></a></td>
            <td>overloads permute</td>
            <tr></tr>
            <td width="250px"><a href="rotation.power.html"><tt>power</tt></a></td>
            <td>r.^n</td>
            <tr></tr>
            <td width="250px"><a href="rotation.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a></td>
            <td>projects rotation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="rotation.repmat.html"><tt>repmat</tt></a></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="rotation.reshape.html"><tt>reshape</tt></a></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="rotation.rotation.html"><tt>rotation</tt></a></td>
            <td>defines an rotation</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subSet.html"><tt>subSet</tt></a></td>
            <td>indexing of rotation</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="rotation.times.html"><tt>times</tt></a></td>
            <td>r = a .* b</td>
            <tr></tr>
            <td width="250px"><a href="rotation.transpose.html"><tt>transpose</tt></a></td>
            <td>transpose array of rotations</td>
            <tr></tr>
            <td width="250px"><a href="rotation.uminus.html"><tt>uminus</tt></a></td>
            <td>implements -rotation</td>
            <tr></tr>
            <td width="250px"><a href="rotation.unique.html"><tt>unique</tt></a></td>
            <td>disjoint list of rotations</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Crystal and Specimen Symmetries (The Class @symmetry)<a name="6"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="symmetry.Laue.html"><tt>Laue</tt></a></td>
            <td>return the corresponding Laue group</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.LaueName.html"><tt>LaueName</tt></a></td>
            <td>get Laue name</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.alignment.html"><tt>alignment</tt></a></td>
            <td>return alignment of the reference frame as string, e.g. x||a, y||b*</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a></td>
            <td>compute the angle distribution of a uniform ODF for a crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a></td>
            <td>compute the axis distribution of an uniform ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.calcQuat.html"><tt>calcQuat</tt></a></td>
            <td>calculate quaternions for Laue groups</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.check.html"><tt>check</tt></a></td>
            <td>check symmetry</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.disjoint.html"><tt>disjoint</tt></a></td>
            <td>returns the disjoint of two symmetry groups</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.elements.html"><tt>elements</tt></a></td>
            <td>extract symmetry elements by multiplicity</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.ensureCS.html"><tt>ensureCS</tt></a></td>
            <td>ensures that an obj has the right crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.eq.html"><tt>eq</tt></a></td>
            <td>check S1 == S2</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.factor.html"><tt>factor</tt></a></td>
            <td>factorizes s1 and s2 into l, d, r such that s1 = l * d and s2 = d * r</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.fundamentalRegion.html"><tt>fundamentalRegion</tt></a></td>
            <td>fundamental region in orientation space for a (pair) of symmetries</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.fundamentalRegionEuler.html"><tt>fundamentalRegionEuler</tt></a></td>
            <td>get the fundamental region in Euler angles</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.fundamentalSector.html"><tt>fundamentalSector</tt></a></td>
            <td>get the fundamental sector for a symmetry in the inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.length.html"><tt>length</tt></a></td>
            <td>number of symmetry elements</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.maxAngle.html"><tt>maxAngle</tt></a></td>
            <td>get the maximum angle of the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.multiplicityPerpZ.html"><tt>multiplicityPerpZ</tt></a></td>
            <td>maximum angle rho</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.multiplicityZ.html"><tt>multiplicityZ</tt></a></td>
            <td>maximum angle rho</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.nfold.html"><tt>nfold</tt></a></td>
            <td>maximal n-fold of symmetry axes</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.plot.html"><tt>plot</tt></a></td>
            <td>visualize symmetry elements according to international table</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.properGroup.html"><tt>properGroup</tt></a></td>
            <td>return the corresponding Laue group</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.properSubGroup.html"><tt>properSubGroup</tt></a></td>
            <td>return the corresponding Laue group</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.rotation_special.html"><tt>rotation_special</tt></a></td>
            <td>returns symmetry elements different from rotation about c-axis</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.symmetry.html"><tt>symmetry</tt></a></td>
            <td>Supported Symmetries</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.union.html"><tt>union</tt></a></td>
            <td>returns the union of two symmetry groups</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Crystal Orientations (The Class @orientation)<a name="7"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="orientation.BCV.html"><tt>BCV</tt></a></td>
            <td>biased cross validation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.KLCV.html"><tt>KLCV</tt></a></td>
            <td>Kullback Leibler cross validation for optimal kernel estimation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.LSCV.html"><tt>LSCV</tt></a></td>
            <td>least squares cross valiadation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.angle.html"><tt>angle</tt></a></td>
            <td>calculates rotational angle between orientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.axis.html"><tt>axis</tt></a></td>
            <td>rotational axis of an misorientation or two orientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.bingham_test.html"><tt>bingham_test</tt></a></td>
            <td>bingham test for spherical/prolat/oblat case</td>
            <tr></tr>
            <td width="250px"><a href="orientation.byAxisAngle.html"><tt>byAxisAngle</tt></a></td>
            <td>define orientations by rotational axis and rotational angle</td>
            <tr></tr>
            <td width="250px"><a href="orientation.byEuler.html"><tt>byEuler</tt></a></td>
            <td>define orientations by Euler angles</td>
            <tr></tr>
            <td width="250px"><a href="orientation.byMatrix.html"><tt>byMatrix</tt></a></td>
            <td>define orientations by a matrix</td>
            <tr></tr>
            <td width="250px"><a href="orientation.byMiller.html"><tt>byMiller</tt></a></td>
            <td>define orientations by Miller Bravais indeces</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a></td>
            <td>calculate angle distribution</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcBinghamODF.html"><tt>calcBinghamODF</tt></a></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcCluster.html"><tt>calcCluster</tt></a></td>
            <td>sort orientations into clusters</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcFourierODF.html"><tt>calcFourierODF</tt></a></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcInvTaylor.html"><tt>calcInvTaylor</tt></a></td>
            <td>Taylor factor from orientation gradient</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcKernel.html"><tt>calcKernel</tt></a></td>
            <td>compute an optimal kernel function for ODF estimation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcKernelODF.html"><tt>calcKernelODF</tt></a></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcMDF.html"><tt>calcMDF</tt></a></td>
            <td>computes an MDF from individuel orientations or misorientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcMIndex.html"><tt>calcMIndex</tt></a></td>
            <td>TODO!!!</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcODF.html"><tt>calcODF</tt></a></td>
            <td>computes an ODF from individuel orientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcTensor.html"><tt>calcTensor</tt></a></td>
            <td>compute the average tensor for a vector of orientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.crossCorrelation.html"><tt>crossCorrelation</tt></a></td>
            <td>computes the cross correlation for the kernel density estimator</td>
            <tr></tr>
            <td width="250px"><a href="orientation.ctranspose.html"><tt>ctranspose</tt></a></td>
            <td>inverse orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.display.html"><tt>display</tt></a></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="orientation.doHClustering.html"><tt>doHClustering</tt></a></td>
            <td>sort orientations into clusters</td>
            <tr></tr>
            <td width="250px"><a href="orientation.dot.html"><tt>dot</tt></a></td>
            <td>compute minimum dot(o1,o2) modulo symmetry</td>
            <tr></tr>
            <td width="250px"><a href="orientation.dot_outer.html"><tt>dot_outer</tt></a></td>
            <td>dot_outer</td>
            <tr></tr>
            <td width="250px"><a href="orientation.exp.html"><tt>exp</tt></a></td>
            <td>exponential function</td>
            <tr></tr>
            <td width="250px"><a href="orientation.export_VPSC.html"><tt>export_VPSC</tt></a></td>
            <td>export individual orientations to the VPSC format</td>
            <tr></tr>
            <td width="250px"><a href="orientation.fibreVolume.html"><tt>fibreVolume</tt></a></td>
            <td>ratio of orientations close to a certain fibre</td>
            <tr></tr>
            <td width="250px"><a href="orientation.getFundamentalRegion.html"><tt>getFundamentalRegion</tt></a></td>
            <td>projects orientations to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="orientation.isMisorientation.html"><tt>isMisorientation</tt></a></td>
            <td>check whether o is a misorientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.ldivide.html"><tt>ldivide</tt></a></td>
            <td>o .\ v</td>
            <tr></tr>
            <td width="250px"><a href="orientation.log.html"><tt>log</tt></a></td>
            <td>the misorientation vector between two orientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.logm.html"><tt>logm</tt></a></td>
            <td>the logarithmic map that translates a rotation into a spin tensor</td>
            <tr></tr>
            <td width="250px"><a href="orientation.map.html"><tt>map</tt></a></td>
            <td>define orientations by pairs of vectors</td>
            <tr></tr>
            <td width="250px"><a href="orientation.mean.html"><tt>mean</tt></a></td>
            <td>mean of a list of orientations, principle axes and moments of inertia</td>
            <tr></tr>
            <td width="250px"><a href="orientation.mldivide.html"><tt>mldivide</tt></a></td>
            <td>o \ v</td>
            <tr></tr>
            <td width="250px"><a href="orientation.mtimes.html"><tt>mtimes</tt></a></td>
            <td>orientation times Miller and orientation times orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.niceEuler.html"><tt>niceEuler</tt></a></td>
            <td>orientation to euler angle</td>
            <tr></tr>
            <td width="250px"><a href="orientation.orientation.html"><tt>orientation</tt></a></td>
            <td>orientation - class representing orientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.parents.html"><tt>parents</tt></a></td>
            <td>variants of an orientation relationship</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plot.html"><tt>plot</tt></a></td>
            <td>annotate a orientation to an existing plot</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotIPDF.html"><tt>plotIPDF</tt></a></td>
            <td>plot orientations into inverse pole figures</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotPDF.html"><tt>plotPDF</tt></a></td>
            <td>plot orientations into pole figures</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotSection.html"><tt>plotSection</tt></a></td>
            <td>plot orientations to ODF sections</td>
            <tr></tr>
            <td width="250px"><a href="orientation.power.html"><tt>power</tt></a></td>
            <td>ori.^n</td>
            <tr></tr>
            <td width="250px"><a href="orientation.project2EulerFR.html"><tt>project2EulerFR</tt></a></td>
            <td>projects orientation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="orientation.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a></td>
            <td>projects orientation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="orientation.qqplot.html"><tt>qqplot</tt></a></td>
            <td>quantile-quantile of misorientation angle against random angular misorientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.round2Miller.html"><tt>round2Miller</tt></a></td>
            <td>find lattice alignements for arbitrary orientations and misorientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.scatter.html"><tt>scatter</tt></a></td>
            <td>plots orientations in 3d</td>
            <tr></tr>
            <td width="250px"><a href="orientation.sphereVolume.html"><tt>sphereVolume</tt></a></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.symmetrise.html"><tt>symmetrise</tt></a></td>
            <td>all crystallographically equivalent orientations</td>
            <tr></tr>
            <td width="250px"><a href="orientation.times.html"><tt>times</tt></a></td>
            <td>vec = ori .* Miller</td>
            <tr></tr>
            <td width="250px"><a href="orientation.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a></td>
            <td>change reference frame of an orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.unique.html"><tt>unique</tt></a></td>
            <td>disjoint list of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="orientation.variants.html"><tt>variants</tt></a></td>
            <td>variants of an orientation relationship</td>
            <tr></tr>
            <td width="250px"><a href="orientation.volume.html"><tt>volume</tt></a></td>
            <td>ratio of orientations with a certain orientation</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Fibres<a name="8"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="fibre.angle.html"><tt>angle</tt></a></td>
            <td>angle fibre to orientation or fibre to fibre</td>
            <tr></tr>
            <td width="250px"><a href="fibre.cat.html"><tt>cat</tt></a></td>
            <td>implement cat for fibre</td>
            <tr></tr>
            <td width="250px"><a href="fibre.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="fibre.end.html"><tt>end</tt></a></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="fibre.eq.html"><tt>eq</tt></a></td>
            <td>? sS1 == sS2</td>
            <tr></tr>
            <td width="250px"><a href="fibre.fibre.html"><tt>fibre</tt></a></td>
            <td>fibre is a class representing a fibre in orientation space. Examples are alpha, beta or gamma fibres. In general a fibre is
               defined by a crystal direction h of type &lt;Miller_index.html Miller&gt; and a specimen direction of type &lt;vector3d_index.html
               vector3d&gt;.
            </td>
            <tr></tr>
            <td width="250px"><a href="fibre.horzcat.html"><tt>horzcat</tt></a></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="fibre.isempty.html"><tt>isempty</tt></a></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="fibre.length.html"><tt>length</tt></a></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="fibre.ne.html"><tt>ne</tt></a></td>
            <td>? sS1 ~= sS2</td>
            <tr></tr>
            <td width="250px"><a href="fibre.orientation.html"><tt>orientation</tt></a></td>
            <td>generate a list of orientation out of a fibre</td>
            <tr></tr>
            <td width="250px"><a href="fibre.plot.html"><tt>plot</tt></a></td>
            <td>plot a fibre</td>
            <tr></tr>
            <td width="250px"><a href="fibre.plotIPDF.html"><tt>plotIPDF</tt></a></td>
            <td>plot orientations into inverse pole figures</td>
            <tr></tr>
            <td width="250px"><a href="fibre.plotPDF.html"><tt>plotPDF</tt></a></td>
            <td>plot a fibre into pole figures</td>
            <tr></tr>
            <td width="250px"><a href="fibre.rotation.html"><tt>rotation</tt></a></td>
            <td>generate a list of orientation out of a fibre</td>
            <tr></tr>
            <td width="250px"><a href="fibre.size.html"><tt>size</tt></a></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="fibre.subSet.html"><tt>subSet</tt></a></td>
            <td>subindex vector3d</td>
            <tr></tr>
            <td width="250px"><a href="fibre.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="fibre.symmetrise.html"><tt>symmetrise</tt></a></td>
            <td>all crystallographically equivalent fibres</td>
            <tr></tr>
            <td width="250px"><a href="fibre.transpose.html"><tt>transpose</tt></a></td>
            <td>transpose list of slipSystem</td>
            <tr></tr>
            <td width="250px"><a href="fibre.vertcat.html"><tt>vertcat</tt></a></td>
            <td>overloads [v1,v2,v3..]</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Slip Systems (The Class @slipSystem)<a name="9"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="slipSystem.SchmidFactor.html"><tt>SchmidFactor</tt></a></td>
            <td>compute the Schmid factor</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.cat.html"><tt>cat</tt></a></td>
            <td>implement cat for slipSystem</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.deformationTensor.html"><tt>deformationTensor</tt></a></td>
            <td>deformation tensor</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.end.html"><tt>end</tt></a></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.eq.html"><tt>eq</tt></a></td>
            <td>? sS1 == sS2</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.horzcat.html"><tt>horzcat</tt></a></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.isempty.html"><tt>isempty</tt></a></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.length.html"><tt>length</tt></a></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.mPrime.html"><tt>mPrime</tt></a></td>
            <td>m' parameter from Luster and Morris in 1995</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.ne.html"><tt>ne</tt></a></td>
            <td>? sS1 ~= sS2</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.residualBurgersVector.html"><tt>residualBurgersVector</tt></a></td>
            <td>compute the Schmid factor</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.rotate.html"><tt>rotate</tt></a></td>
            <td>rotate slip system</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.rotate_outer.html"><tt>rotate_outer</tt></a></td>
            <td>rotate slip system</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.size.html"><tt>size</tt></a></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.slipSystem.html"><tt>slipSystem</tt></a></td>
            <td>class representing slip systems</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.subSet.html"><tt>subSet</tt></a></td>
            <td>subindex vector3d</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.symmetrise.html"><tt>symmetrise</tt></a></td>
            <td>find all symmetrically equivalent slips systems</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.trace.html"><tt>trace</tt></a></td>
            <td>trace of the slip plane in the surface normal to n</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.transpose.html"><tt>transpose</tt></a></td>
            <td>transpose list of slipSystem</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.uminus.html"><tt>uminus</tt></a></td>
            <td>overloads unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.vertcat.html"><tt>vertcat</tt></a></td>
            <td>overloads [v1,v2,v3..]</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Quaternions (The Class @quaternion)<a name="10"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="quaternion.EinsteinSum.html"><tt>EinsteinSum</tt></a></td>
            <td>tensor multiplication according to Einstein summation</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.Euler.html"><tt>Euler</tt></a></td>
            <td>quaternion to euler angle</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.Rodrigues.html"><tt>Rodrigues</tt></a></td>
            <td>quaternion to rodrigues representation</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.angle.html"><tt>angle</tt></a></td>
            <td>calcualtes the rotational angle between rotations q1 and q2</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.angle_outer.html"><tt>angle_outer</tt></a></td>
            <td>calcualtes the rotational angle between all rotations q1 and q2</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.axis.html"><tt>axis</tt></a></td>
            <td>rotational axis of the quaternion</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.calcVoronoi.html"><tt>calcVoronoi</tt></a></td>
            <td>compute the the Voronoi decomposition for unit quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.cat.html"><tt>cat</tt></a></td>
            <td>implement cat for quaternion</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.char.html"><tt>char</tt></a></td>
            <td>quaternion to char</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.cross.html"><tt>cross</tt></a></td>
            <td>pointwise cross product of three quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ctranspose.html"><tt>ctranspose</tt></a></td>
            <td>transpose quaternion</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.display.html"><tt>display</tt></a></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot.html"><tt>dot</tt></a></td>
            <td>inner product of quaternions g1 and g2</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot_angle.html"><tt>dot_angle</tt></a></td>
            <td>compute minimum q1 . q2 modulo rotation about zaxis and angle omega</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot_outer.html"><tt>dot_outer</tt></a></td>
            <td>outer inner product between two quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.double.html"><tt>double</tt></a></td>
            <td>quaternion to double</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.end.html"><tt>end</tt></a></td>
            <td>overloads end function</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.eq.html"><tt>eq</tt></a></td>
            <td>? q1 == q2</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.export.html"><tt>export</tt></a></td>
            <td>export quaternions to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.find.html"><tt>find</tt></a></td>
            <td>return indece and distance of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.geodesic.html"><tt>geodesic</tt></a></td>
            <td>Calculats the rotation, which is described by the geodesic  gamma(t)_{rot1,rot2} from rot1 to rot2 at the location t, for
               vectors of n rotations.
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.horzcat.html"><tt>horzcat</tt></a></td>
            <td>implements [q1,q2,q3..]</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.inv.html"><tt>inv</tt></a></td>
            <td>quaternion of the inverse roation</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.isempty.html"><tt>isempty</tt></a></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.isnan.html"><tt>isnan</tt></a></td>
            <td>check for nan values</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.length.html"><tt>length</tt></a></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.log.html"><tt>log</tt></a></td>
            <td>the logarithmic map that translates a rotation into a rotation vector</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.logm.html"><tt>logm</tt></a></td>
            <td>the logarithmic map that translates a rotation into a spin tensor</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.matrix.html"><tt>matrix</tt></a></td>
            <td>quaternion to direction cosine matrix conversion converts direction cosine matrix to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mean.html"><tt>mean</tt></a></td>
            <td>mean of a list of quaternions, principle axes and moments of inertia</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mean_CS.html"><tt>mean_CS</tt></a></td>
            <td>fast mean of</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.minus.html"><tt>minus</tt></a></td>
            <td>overloads minus</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mldivide.html"><tt>mldivide</tt></a></td>
            <td>\   Backslash or left matrix divide. A\B is the matrix division of A into B, which is roughly the same as INV(A)*B , except
               it is computed in a different way. If A is an N-by-N matrix and B is a column vector with N components, or a matrix with several
               such columns, then X = A\B is the solution to the equation A*X = B. A warning  message is printed if A is badly scaled or
               nearly singular. A\EYE(SIZE(A)) produces the inverse of A.
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mpower.html"><tt>mpower</tt></a></td>
            <td>q^n</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mrdivide.html"><tt>mrdivide</tt></a></td>
            <td>scalar division</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mtimes.html"><tt>mtimes</tt></a></td>
            <td>quaternionen multiplication q1 * q2</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ndims.html"><tt>ndims</tt></a></td>
            <td>overloads ndims</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ne.html"><tt>ne</tt></a></td>
            <td>q1 ~= q2 ?</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.norm.html"><tt>norm</tt></a></td>
            <td>quaternion norm sqrt(a^2+b^2+c^2+c^2)</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.normalize.html"><tt>normalize</tt></a></td>
            <td>normalize quaternion</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.permute.html"><tt>permute</tt></a></td>
            <td>overloads permute</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.perturbe.html"><tt>perturbe</tt></a></td>
            <td>pertube data randomly by epsilon</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.plot.html"><tt>plot</tt></a></td>
            <td>PLOT   Linear plot.  PLOT(X,Y) plots vector Y versus vector X. If X or Y is a matrix, then the vector is plotted versus the
               rows or columns of the matrix, whichever line up.  If X is a scalar and Y is a vector, disconnected line objects are created
               and plotted as discrete points vertically at X.
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.plus.html"><tt>plus</tt></a></td>
            <td>pointwise addition</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.power.html"><tt>power</tt></a></td>
            <td>q.^n</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.prod.html"><tt>prod</tt></a></td>
            <td>overloads q1 * q2 * q3</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.project2EulerFR.html"><tt>project2EulerFR</tt></a></td>
            <td>projects quaternions to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a></td>
            <td>projects quaternions to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.qmatrix.html"><tt>qmatrix</tt></a></td>
            <td>returns the quaternion multiplication matrix</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.qq.html"><tt>qq</tt></a></td>
            <td>returns w * q' * q</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.quaternion.html"><tt>quaternion</tt></a></td>
            <td>quaternion is a class. q = quaternion(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.rdivide.html"><tt>rdivide</tt></a></td>
            <td>scalar division</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.real.html"><tt>real</tt></a></td>
            <td>real-part of of quaternion</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.repmat.html"><tt>repmat</tt></a></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.reshape.html"><tt>reshape</tt></a></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.scatter.html"><tt>scatter</tt></a></td>
            <td>plot function</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.setSubSet.html"><tt>setSubSet</tt></a></td>
            <td>indexing of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.size.html"><tt>size</tt></a></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subSet.html"><tt>subSet</tt></a></td>
            <td>indexing of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.sum.html"><tt>sum</tt></a></td>
            <td>overloads sum</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.symmetrise.html"><tt>symmetrise</tt></a></td>
            <td>symmetrcially equivalent orientations</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.times.html"><tt>times</tt></a></td>
            <td>quaternion .* quaternion and quaternion .* vector3d</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.transpose.html"><tt>transpose</tt></a></td>
            <td>transpose array of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.uminus.html"><tt>uminus</tt></a></td>
            <td>overload unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.unique.html"><tt>unique</tt></a></td>
            <td>disjoint list of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.vertcat.html"><tt>vertcat</tt></a></td>
            <td>implements [q1;q2;q3..]</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Discretisation of 1-Sphere (The Class @S1Grid)<a name="11"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="S1Grid.GridLength.html"><tt>GridLength</tt></a></td>
            <td>return number of points</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.S1Grid.html"><tt>S1Grid</tt></a></td>
            <td>Constructor</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.coarser.html"><tt>coarser</tt></a></td>
            <td>makes S1Grid more coarse</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.delete.html"><tt>delete</tt></a></td>
            <td>delte points from S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.display.html"><tt>display</tt></a></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.dist.html"><tt>dist</tt></a></td>
            <td>distance to all points of S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.dist_outer.html"><tt>dist_outer</tt></a></td>
            <td>distance to all points of S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.double.html"><tt>double</tt></a></td>
            <td>convert to double</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.eq.html"><tt>eq</tt></a></td>
            <td>implements G1 == G2</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.find.html"><tt>find</tt></a></td>
            <td>find close points</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.max.html"><tt>max</tt></a></td>
            <td>return maximum value</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.min.html"><tt>min</tt></a></td>
            <td>return maximum value</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.minus.html"><tt>minus</tt></a></td>
            <td>-   Minus.  X - Y subtracts matrix Y from X. X and Y must have compatible sizes. In the simplest cases, they can be the same
               size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension sizes of the inputs are
               either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.plot.html"><tt>plot</tt></a></td>
            <td>plot grid</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.plus.html"><tt>plus</tt></a></td>
            <td>+   Plus. X + Y adds matrices X and Y. X and Y must have compatible sizes. In the simplest cases, they can be the same size
               or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension sizes of the inputs are either
               the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.refine.html"><tt>refine</tt></a></td>
            <td>refine S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.shift.html"><tt>shift</tt></a></td>
            <td>shifts S1Grid by delta</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.subGrid.html"><tt>subGrid</tt></a></td>
            <td>epsilon - neighborhood of a point in the grid</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Discretisation of 2 - Sphere (The Class @S2Grid)<a name="12"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="S2Grid.S2Grid.html"><tt>S2Grid</tt></a></td>
            <td>Syntax S2Grid(theta,rho)      % fills a Sphere with N--nodes regularS2Grid('resolution',5*degree)     % construct regular
               polar and azimuthal spacing equispacedS2Grid('resolution',5*degree)  % construct equispaced nodes
            </td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.cat.html"><tt>cat</tt></a></td>
            <td>implements cat for S2Grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.copy.html"><tt>copy</tt></a></td>
            <td>copy certain condition from grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.delete.html"><tt>delete</tt></a></td>
            <td>elilinates points from grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.find.html"><tt>find</tt></a></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.getdata.html"><tt>getdata</tt></a></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.polar.html"><tt>polar</tt></a></td>
            <td>polar coordinates of S2Grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.refine.html"><tt>refine</tt></a></td>
            <td>refine S2Grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subGrid.html"><tt>subGrid</tt></a></td>
            <td>subgrid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Discretisation of Orientation Space (The Class SO3Grid)<a name="13"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="SO3Grid.SO3Grid.html"><tt>SO3Grid</tt></a></td>
            <td>represent orientations in a gridded structure to allow quick access</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.char.html"><tt>char</tt></a></td>
            <td>convert to char</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.copy.html"><tt>copy</tt></a></td>
            <td>copy nodes by indece</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.delete.html"><tt>delete</tt></a></td>
            <td>clear nodes by indece Input SOG    - @SO3Grid indece - int32</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.dot_outer.html"><tt>dot_outer</tt></a></td>
            <td>return outer inner product of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.find.html"><tt>find</tt></a></td>
            <td>return indece and distance of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.mtimes.html"><tt>mtimes</tt></a></td>
            <td>outer quaternion multiplication</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.spy.html"><tt>spy</tt></a></td>
            <td>spy distance matrix</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subGrid.html"><tt>subGrid</tt></a></td>
            <td>sub-SO3Grid as epsilon neigborhood of a node</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("1");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#1">Back to Top of Section</a></p>
         <h2> Classes for Quantitative Texture Analysis<a name="14"> </a></h2>
         <table class="ref" width="90%">
            <tr>
               <td valign="top" width="250px"><a href="#15"> Orientation Density Functions (The Class @ODF)
                     <td valign="top" width="75%">This sections describes the class *ODF* and gives an overview how to work
                         with orientation density functions in MTEX.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#16"> Standard ODFs
                     <td valign="top" width="75%">predefined ODFs</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#17"> ODF Shapes (The class @kernel) 
                     <td valign="top" width="75%">standard distributions on SO(3)</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#18"> Pole Figure Data (The Class @PoleFigure)
                     <td valign="top" width="75%">This section describes the class *PoleFigure* and gives an overview of
                         the functionality MTEX offers to analyze pole figure data.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#19"> Electron Backscatter Diffraction Data (The Class @EBSD)
                     <td valign="top" width="75%">This section describes the class *EBSD* and gives an overview over the
                         functionality that MTEX offers to analyze EBSD data.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#20"> tensors (The Class @tensor)
                     <td valign="top" width="75%"></td></a></td>
            </tr>
         </table>
         <table width="95%"></table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2> Orientation Density Functions (The Class @ODF)<a name="15"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="ODF.FourierODF.html"><tt>FourierODF</tt></a></td>
            <td>compute FourierODF from another ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.ODF.html"><tt>ODF</tt></a></td>
            <td>ODF is a class. odf = ODF(components, weights)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.bandwidth.html"><tt>bandwidth</tt></a></td>
            <td>bandwidth of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a></td>
            <td>compute the angle distribution of an ODF or an MDF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a></td>
            <td>compute the axis distribution of an ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAxisVolume.html"><tt>calcAxisVolume</tt></a></td>
            <td>amount of orientations with a specific misorientation axis</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcComponents.html"><tt>calcComponents</tt></a></td>
            <td>heuristic to find modal orientations</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcError.html"><tt>calcError</tt></a></td>
            <td>calculate approximation error between two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcFourier.html"><tt>calcFourier</tt></a></td>
            <td>compute Fourier coefficients of odf</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcMDF.html"><tt>calcMDF</tt></a></td>
            <td>calculate the uncorrelated misorientation distribution function (MDF) from one or two ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcMIndex.html"><tt>calcMIndex</tt></a></td>
            <td>M-index of Skemer et al.(2005) based on the difference between uncorrelated and uniform misorientation angle distributions</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcModes.html"><tt>calcModes</tt></a></td>
            <td>heuristic to find modal orientations</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcOrientations.html"><tt>calcOrientations</tt></a></td>
            <td>draw random orientations from ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcPDF.html"><tt>calcPDF</tt></a></td>
            <td>calcPDF computed the PDF corresponding to an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcPoleFigure.html"><tt>calcPoleFigure</tt></a></td>
            <td>simulate pole figures from an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcTensor.html"><tt>calcTensor</tt></a></td>
            <td>compute the average tensor for an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcpdf_special3.html"><tt>calcpdf_special3</tt></a></td>
            <td>compute the pdf for h = (theta,rhoh), r = (theta,rhor)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.centerSpecimen.html"><tt>centerSpecimen</tt></a></td>
            <td>rotatates an odf with specimen symmetry into its symmetry axes</td>
            <tr></tr>
            <td width="250px"><a href="ODF.char.html"><tt>char</tt></a></td>
            <td>odf -&gt; char</td>
            <tr></tr>
            <td width="250px"><a href="ODF.concentration.html"><tt>concentration</tt></a></td>
            <td>not yet implemeted</td>
            <tr></tr>
            <td width="250px"><a href="ODF.conv.html"><tt>conv</tt></a></td>
            <td>convolute ODF with kernel psi</td>
            <tr></tr>
            <td width="250px"><a href="ODF.discreteSample.html"><tt>discreteSample</tt></a></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="ODF.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="ODF.entropy.html"><tt>entropy</tt></a></td>
            <td>caclulate entropy of ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.eval.html"><tt>eval</tt></a></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export.html"><tt>export</tt></a></td>
            <td>export an ODF to an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_VPSC.html"><tt>export_VPSC</tt></a></td>
            <td>export an ODF to the VPSC format</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_generic.html"><tt>export_generic</tt></a></td>
            <td>export an ODF to an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_mtex.html"><tt>export_mtex</tt></a></td>
            <td>export an ODF into the MTEX format</td>
            <tr></tr>
            <td width="250px"><a href="ODF.fibreVolume.html"><tt>fibreVolume</tt></a></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="ODF.grad.html"><tt>grad</tt></a></td>
            <td>gradient of odf at orientation ori</td>
            <tr></tr>
            <td width="250px"><a href="ODF.hist.html"><tt>hist</tt></a></td>
            <td>calcualtes a histogram of ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.isFourier.html"><tt>isFourier</tt></a></td>
            <td>check whether odf is given by Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="ODF.max.html"><tt>max</tt></a></td>
            <td>heuristic to find local modal orientations</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mean.html"><tt>mean</tt></a></td>
            <td>expected value of an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.minus.html"><tt>minus</tt></a></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mrdivide.html"><tt>mrdivide</tt></a></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mtimes.html"><tt>mtimes</tt></a></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.neuralgas.html"><tt>neuralgas</tt></a></td>
            <td>attempt to distribute measure-sites equally according to invers polefigure density (experimental)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.norm.html"><tt>norm</tt></a></td>
            <td>caclulate texture index of ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plot.html"><tt>plot</tt></a></td>
            <td>plots odf or append to a previous plot using 'add2all'</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plot3d.html"><tt>plot3d</tt></a></td>
            <td>plots odf</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotDiff.html"><tt>plotDiff</tt></a></td>
            <td>difference plot between two odfs or an odf and a pole figure</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotFibre.html"><tt>plotFibre</tt></a></td>
            <td>plot odf along a fibre</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotFourier.html"><tt>plotFourier</tt></a></td>
            <td>plots Fourier coefficients of the odf</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotIPDF.html"><tt>plotIPDF</tt></a></td>
            <td>plot inverse pole figures</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotPDF.html"><tt>plotPDF</tt></a></td>
            <td>plot pole figures</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotSection.html"><tt>plotSection</tt></a></td>
            <td>plot ODF sections</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plus.html"><tt>plus</tt></a></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="ODF.quantile.html"><tt>quantile</tt></a></td>
            <td>quantile orientations of an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.rdivide.html"><tt>rdivide</tt></a></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.rotate.html"><tt>rotate</tt></a></td>
            <td>rotate ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.rotate_outer.html"><tt>rotate_outer</tt></a></td>
            <td>rotate ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.slope.html"><tt>slope</tt></a></td>
            <td>| grad(r) |</td>
            <tr></tr>
            <td width="250px"><a href="ODF.smooth.html"><tt>smooth</tt></a></td>
            <td>smooth ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.steepestDescent.html"><tt>steepestDescent</tt></a></td>
            <td>find maximum with steepest descent</td>
            <tr></tr>
            <td width="250px"><a href="ODF.steepestDescentX.html"><tt>steepestDescentX</tt></a></td>
            <td>find maximum with steepest descent</td>
            <tr></tr>
            <td width="250px"><a href="ODF.textureindex.html"><tt>textureindex</tt></a></td>
            <td>caclulate texture index of ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.times.html"><tt>times</tt></a></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.uminus.html"><tt>uminus</tt></a></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="ODF.volume.html"><tt>volume</tt></a></td>
            <td>ratio of orientations with a certain orientation</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("14");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#14">Back to Top of Section</a></p>
         <h2> Standard ODFs<a name="16"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="BinghamODF.html"><tt>BinghamODF</tt></a></td>
            <td>defines a Bingham distributed ODF</td>
            <tr></tr>
            <td width="250px"><a href="FourierODF.html"><tt>FourierODF</tt></a></td>
            <td>defines an ODF by its Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="SantaFe.html"><tt>SantaFe</tt></a></td>
            <td>the SantaFe-sample ODF</td>
            <tr></tr>
            <td width="250px"><a href="femODF.html"><tt>femODF</tt></a></td>
            <td>defines an ODF by finite elements</td>
            <tr></tr>
            <td width="250px"><a href="fibreODF.html"><tt>fibreODF</tt></a></td>
            <td>defines an fibre symmetric ODF</td>
            <tr></tr>
            <td width="250px"><a href="mix2.html"><tt>mix2</tt></a></td>
            <td>mix2 sample ODF</td>
            <tr></tr>
            <td width="250px"><a href="uniformODF.html"><tt>uniformODF</tt></a></td>
            <td>get crystal and specimen symmetry</td>
            <tr></tr>
            <td width="250px"><a href="unimodalODF.html"><tt>unimodalODF</tt></a></td>
            <td>define a unimodal ODF</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("14");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#14">Back to Top of Section</a></p>
         <h2> ODF Shapes (The class @kernel) <a name="17"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="kernel.K_symmetrised.html"><tt>K_symmetrised</tt></a></td>
            <td>evaluate kernel modulo symmetries</td>
            <tr></tr>
            <td width="250px"><a href="kernel.RK_symmetrised.html"><tt>RK_symmetrised</tt></a></td>
            <td>sum Radon trasformed kernel</td>
            <tr></tr>
            <td width="250px"><a href="kernel.kernel.html"><tt>kernel</tt></a></td>
            <td>kernel is a class. psi = kernel(A)</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plot.html"><tt>plot</tt></a></td>
            <td>plot the kernel function</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plotFourier.html"><tt>plotFourier</tt></a></td>
            <td>plot the Chybeyshev coefficients of the kernel function</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plotPDF.html"><tt>plotPDF</tt></a></td>
            <td>plot Radon transformed kernel</td>
            <tr></tr>
            <td width="250px"><a href="kernel.volume.html"><tt>volume</tt></a></td>
            <td>kernel/volume is a function. [vol, dist] = volume(psi, radius, dist)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("14");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#14">Back to Top of Section</a></p>
         <h2> Pole Figure Data (The Class @PoleFigure)<a name="18"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="PoleFigure.PoleFigure.html"><tt>PoleFigure</tt></a></td>
            <td>constructor</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcError.html"><tt>calcError</tt></a></td>
            <td>RP and mean square error</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcErrorPF.html"><tt>calcErrorPF</tt></a></td>
            <td>error polefigure between meassured and recalculated pole figures</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcFEMODF.html"><tt>calcFEMODF</tt></a></td>
            <td>PDF to ODF inversion</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcNormalization.html"><tt>calcNormalization</tt></a></td>
            <td>normalization of a meassured pole figure with respect to a second pole figure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcODF.html"><tt>calcODF</tt></a></td>
            <td>PDF to ODF inversion</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcPoleFigure.html"><tt>calcPoleFigure</tt></a></td>
            <td>simulate pole figure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.cat.html"><tt>cat</tt></a></td>
            <td>implement cat for PoleFigure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.char.html"><tt>char</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.correct.html"><tt>correct</tt></a></td>
            <td>corrects polfigures for background and defocussing</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.export.html"><tt>export</tt></a></td>
            <td>export pole figure in an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.findOutlier.html"><tt>findOutlier</tt></a></td>
            <td>find outliers in pole figures</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.isOutlier.html"><tt>isOutlier</tt></a></td>
            <td>find outliers in pole figures</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.isempty.html"><tt>isempty</tt></a></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.max.html"><tt>max</tt></a></td>
            <td>maximum of two pole figures or the maximum of a single polefigure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mean.html"><tt>mean</tt></a></td>
            <td>mean of pole figure intensities</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.min.html"><tt>min</tt></a></td>
            <td>minimum of two pole figures or the minimum of a single polefigure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.minus.html"><tt>minus</tt></a></td>
            <td>implements pf1 - pf2</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mrdivide.html"><tt>mrdivide</tt></a></td>
            <td>implements pf1 ./ b and a ./ pf2</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mtimes.html"><tt>mtimes</tt></a></td>
            <td>scaling of PoleFigures, implements pf1 * b and a * pf2</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.noisepf.html"><tt>noisepf</tt></a></td>
            <td>simulate diffraction counts</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.normalize.html"><tt>normalize</tt></a></td>
            <td>normalization of a meassured pole figure with respect to an ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plot.html"><tt>plot</tt></a></td>
            <td>plot pole figure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plotDiff.html"><tt>plotDiff</tt></a></td>
            <td>difference plot between two pole figures or an odf and a pole figure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plus.html"><tt>plus</tt></a></td>
            <td>implements pf1 + pf2</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.rdivide.html"><tt>rdivide</tt></a></td>
            <td>implements pf1 ./ b and a ./ pf2</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.rotate.html"><tt>rotate</tt></a></td>
            <td>rotates pole figures by a certain rotation</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.rotate_outer.html"><tt>rotate_outer</tt></a></td>
            <td>is called by rot * pf</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.scale.html"><tt>scale</tt></a></td>
            <td>scale polefigure by a factor</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.select.html"><tt>select</tt></a></td>
            <td>select PoleFigures</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.subsref.html"><tt>subsref</tt></a></td>
            <td>overide polefigure() and polefigure{}</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.times.html"><tt>times</tt></a></td>
            <td>implements pf1 .* b and a .* pf2</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.uminus.html"><tt>uminus</tt></a></td>
            <td>implements -pf</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.union.html"><tt>union</tt></a></td>
            <td>crytsallographic direction to one</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.unique.html"><tt>unique</tt></a></td>
            <td>remove dublicated points in a polefigure</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("14");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#14">Back to Top of Section</a></p>
         <h2> Electron Backscatter Diffraction Data (The Class @EBSD)<a name="19"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="EBSD.EBSD.html"><tt>EBSD</tt></a></td>
            <td>constructor</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.KAM.html"><tt>KAM</tt></a></td>
            <td>intragranular average misorientation angle per orientation</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.affinetrans.html"><tt>affinetrans</tt></a></td>
            <td>perform an affine transformation on spatial ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcGrains.html"><tt>calcGrains</tt></a></td>
            <td>grains reconstruction from 2d EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcMisorientation.html"><tt>calcMisorientation</tt></a></td>
            <td>calculate uncorrelated misorientations between two ebsd phases</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcTensor.html"><tt>calcTensor</tt></a></td>
            <td>compute the average tensor for an EBSD data set</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.cat.html"><tt>cat</tt></a></td>
            <td>overloads [ebsd1,ebsd2,ebsd3..]</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.char.html"><tt>char</tt></a></td>
            <td>ebsd -&gt; char</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.export.html"><tt>export</tt></a></td>
            <td>export EBSD data to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.export_h5.html"><tt>export_h5</tt></a></td>
            <td>export EBSD data to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.extend.html"><tt>extend</tt></a></td>
            <td>returns the boundings of spatial EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.fill.html"><tt>fill</tt></a></td>
            <td>extrapolate spatial EBSD data by nearest neighbour for tetragonal lattice</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.fillByGrainId.html"><tt>fillByGrainId</tt></a></td>
            <td>extrapolate spatial EBSD data by nearest neighbour for tetragonal lattice</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.findByLocation.html"><tt>findByLocation</tt></a></td>
            <td>select EBSD data by spatial coordinates</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.findByOrientation.html"><tt>findByOrientation</tt></a></td>
            <td>select ebsd data by orientation</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.fliplr.html"><tt>fliplr</tt></a></td>
            <td>flip spatial ebsd-data from left to right</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.flipud.html"><tt>flipud</tt></a></td>
            <td>flip spatial ebsd-data from upside down</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.gridify.html"><tt>gridify</tt></a></td>
            <td>extend EBSD data to an grid</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.id2ind.html"><tt>id2ind</tt></a></td>
            <td>find ind such that ebsd.id(ind) == id</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.inpolygon.html"><tt>inpolygon</tt></a></td>
            <td>checks which ebsd data are within given polygon</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.mtimes.html"><tt>mtimes</tt></a></td>
            <td>rotating the ebsd data by a certain rotation</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.plot.html"><tt>plot</tt></a></td>
            <td>spatial EBSD plot</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.plotUnitCells.html"><tt>plotUnitCells</tt></a></td>
            <td>low level plotting routine for EBSD maps</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.quiver.html"><tt>quiver</tt></a></td>
            <td>plot directions at ebsd centers</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.reduce.html"><tt>reduce</tt></a></td>
            <td>reduce ebsd data by a factor</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.rotate.html"><tt>rotate</tt></a></td>
            <td>rotate EBSD orientations or spatial data around point of origin</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.selectInteractive.html"><tt>selectInteractive</tt></a></td>
            <td>select interactively a rectangular region of an EBSD data set</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.shift.html"><tt>shift</tt></a></td>
            <td>shift spatial ebsd-data about (x,y)</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.smooth.html"><tt>smooth</tt></a></td>
            <td>smooth spatial EBSD</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.spatialProfile.html"><tt>spatialProfile</tt></a></td>
            <td>select EBSD data along line segments</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subSet.html"><tt>subSet</tt></a></td>
            <td>indexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subsind.html"><tt>subsind</tt></a></td>
            <td>subindexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subsref.html"><tt>subsref</tt></a></td>
            <td>indexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.updateUnitCell.html"><tt>updateUnitCell</tt></a></td>
            <td>this function should be called after the spatial coordinates of an EBSD data set have been modified</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("14");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#14">Back to Top of Section</a></p>
         <h2> tensors (The Class @tensor)<a name="20"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="tensor.Fourier.html"><tt>Fourier</tt></a></td>
            <td>compute the Fourier coefficients of the tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.Voigt.html"><tt>Voigt</tt></a></td>
            <td>tensor/Voigt is a function. V = Voigt(T)</td>
            <tr></tr>
            <td width="250px"><a href="tensor.antiSym.html"><tt>antiSym</tt></a></td>
            <td>the antisymmetric part A = 0.5(T - T.') of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.char.html"><tt>char</tt></a></td>
            <td>tensor to char</td>
            <tr></tr>
            <td width="250px"><a href="tensor.checkSymmetry.html"><tt>checkSymmetry</tt></a></td>
            <td>tensor/checkSymmetry is a function. out = checkSymmetry(T)</td>
            <tr></tr>
            <td width="250px"><a href="tensor.colon.html"><tt>colon</tt></a></td>
            <td>double dot A:B between two tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.conj.html"><tt>conj</tt></a></td>
            <td>conjugate of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.ctranspose.html"><tt>ctranspose</tt></a></td>
            <td>conjugate of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.det.html"><tt>det</tt></a></td>
            <td>compute the determinants of rank 2 tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.diag.html"><tt>diag</tt></a></td>
            <td>convert rank 1 or rank 0 tensor into diagonal rank 2 tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.directionalMagnitude.html"><tt>directionalMagnitude</tt></a></td>
            <td>magnitude of a tensor in direction v</td>
            <tr></tr>
            <td width="250px"><a href="tensor.display.html"><tt>display</tt></a></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="tensor.double.html"><tt>double</tt></a></td>
            <td>convert tensor values to matrix</td>
            <tr></tr>
            <td width="250px"><a href="tensor.eig.html"><tt>eig</tt></a></td>
            <td>compute the eigenvalues and eigenvectors of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.end.html"><tt>end</tt></a></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="tensor.eq.html"><tt>eq</tt></a></td>
            <td>checks whether two tensors are equal</td>
            <tr></tr>
            <td width="250px"><a href="tensor.expm.html"><tt>expm</tt></a></td>
            <td>matrix exponential of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.horzcat.html"><tt>horzcat</tt></a></td>
            <td>overloads [T1,T2,T3..]</td>
            <tr></tr>
            <td width="250px"><a href="tensor.inv.html"><tt>inv</tt></a></td>
            <td>inverse of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.length.html"><tt>length</tt></a></td>
            <td>returns the number of tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.logm.html"><tt>logm</tt></a></td>
            <td>matrix logarithm of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.matrix.html"><tt>matrix</tt></a></td>
            <td>return tensor as a matrix</td>
            <tr></tr>
            <td width="250px"><a href="tensor.max.html"><tt>max</tt></a></td>
            <td>MAX    Maximum elements of an array. M = MAX(X) is the largest element in the vector X. If X is a matrix, M  is a row vector
               containing the maximum element from each column. For  N-D arrays, MAX(X) operates along the first non-singleton dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.mean.html"><tt>mean</tt></a></td>
            <td>mean of a list of tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.min.html"><tt>min</tt></a></td>
            <td>MIN    Minimum elements of an array. M = MIN(X) is the smallest element in the vector X. If X is a matrix, M is a row vector
               containing the minimum element from each column. For  N-D arrays, MIN(X) operates along the first non-singleton dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.minus.html"><tt>minus</tt></a></td>
            <td>T1 - T2;</td>
            <tr></tr>
            <td width="250px"><a href="tensor.mrdivide.html"><tt>mrdivide</tt></a></td>
            <td>implements T / S</td>
            <tr></tr>
            <td width="250px"><a href="tensor.mtimes.html"><tt>mtimes</tt></a></td>
            <td>implements T1 * T2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.ndims.html"><tt>ndims</tt></a></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="tensor.ne.html"><tt>ne</tt></a></td>
            <td>checks whether two tensors are not equal</td>
            <tr></tr>
            <td width="250px"><a href="tensor.norm.html"><tt>norm</tt></a></td>
            <td>tensor frobenius norm</td>
            <tr></tr>
            <td width="250px"><a href="tensor.numel.html"><tt>numel</tt></a></td>
            <td>returns the number of tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.plot.html"><tt>plot</tt></a></td>
            <td>plot a tensor T</td>
            <tr></tr>
            <td width="250px"><a href="tensor.plus.html"><tt>plus</tt></a></td>
            <td>add two tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.polar.html"><tt>polar</tt></a></td>
            <td>compute the polar decomposition of rank 2 tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.quadric.html"><tt>quadric</tt></a></td>
            <td>quadric</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rdivide.html"><tt>rdivide</tt></a></td>
            <td>./  Right array divide. A./B denotes element-by-element division. X and Y must have compatible sizes. In the simplest cases,
               they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension
               sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.real.html"><tt>real</tt></a></td>
            <td>REAL   Complex real part. REAL(X) is the real part of X. See I or J to enter complex numbers.</td>
            <tr></tr>
            <td width="250px"><a href="tensor.reshape.html"><tt>reshape</tt></a></td>
            <td>reshape for tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rotate.html"><tt>rotate</tt></a></td>
            <td>rotate a tensor by a list of rotations</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rotate_outer.html"><tt>rotate_outer</tt></a></td>
            <td>rotate a tensor by a list of rotations</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rotation.html"><tt>rotation</tt></a></td>
            <td>convertes orthogonal rank 2 tensors into rotations</td>
            <tr></tr>
            <td width="250px"><a href="tensor.size.html"><tt>size</tt></a></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="tensor.sqrtm.html"><tt>sqrtm</tt></a></td>
            <td>matrix exponential of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.subsasgn.html"><tt>subsasgn</tt></a></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="tensor.subsref.html"><tt>subsref</tt></a></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="tensor.sum.html"><tt>sum</tt></a></td>
            <td>sum of a list of tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.sym.html"><tt>sym</tt></a></td>
            <td>the symmetric part S = 0.5(T + T.') of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.symmetrise.html"><tt>symmetrise</tt></a></td>
            <td>symmetrise a tensor according to its crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="tensor.tensor.html"><tt>tensor</tt></a></td>
            <td>constructor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.tensorSize.html"><tt>tensorSize</tt></a></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="tensor.times.html"><tt>times</tt></a></td>
            <td>multiply a tensor by a scalar</td>
            <tr></tr>
            <td width="250px"><a href="tensor.trace.html"><tt>trace</tt></a></td>
            <td>compute the traces of a rank 2 tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a></td>
            <td>set properties of a tensor variable</td>
            <tr></tr>
            <td width="250px"><a href="tensor.transpose.html"><tt>transpose</tt></a></td>
            <td>transpose a list of a tensors</td>
            <tr></tr>
            <td width="250px"><a href="tensor.uminus.html"><tt>uminus</tt></a></td>
            <td>unary minus</td>
            <tr></tr>
            <td width="250px"><a href="tensor.vector3d.html"><tt>vector3d</tt></a></td>
            <td>convert rank one tensors to vector3d</td>
            <tr></tr>
            <td width="250px"><a href="tensor.vertcat.html"><tt>vertcat</tt></a></td>
            <td>overloads [T1,T2,T3..]</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("14");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#14">Back to Top of Section</a></p>
         <h2> Auxiliary Functions<a name="21"> </a></h2>
         <table class="ref" width="90%">
            <tr>
               <td valign="top" width="250px"><a href="#22"> Plotting Tools 
                     <td valign="top" width="75%">Below you find a list of tools to work with data given in the Dubna format</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#23"> Geometry Tools
                     <td valign="top" width="75%">This section of geometry tools especially contains methods to convert
                         directions and rotations from one parametrization into another.
                         Additionally, some basic geometrical objects are predefined.
                     </td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#24"> Statistics
                     <td valign="top" width="75%">Below you find a list of statistical tools included in the MTEX toolbox.</td></a></td>
            </tr>
            <tr>
               <td valign="top" width="250px"><a href="#25"> Plotting
                     <td valign="top" width="75%">Below you find a list of plotting tools included in the MTEX toolbox. Of
                         special importance is the command [[savefigure.html,savefigure]] which
                         allows saving plots in any kinds of image files.
                     </td></a></td>
            </tr>
         </table>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="annotate.html"><tt>annotate</tt></a></td>
            <td>annotate to a existing figure</td>
            <tr></tr>
            <td width="250px"><a href="ar2rgb.html"><tt>ar2rgb</tt></a></td>
            <td>compute rgb values from angle and radius</td>
            <tr></tr>
            <td width="250px"><a href="contour3s.html"><tt>contour3s</tt></a></td>
            <td>contour-slices</td>
            <tr></tr>
            <td width="250px"><a href="convertFigureRGB2ind.html"><tt>convertFigureRGB2ind</tt></a></td>
            <td>default resolution</td>
            <tr></tr>
            <td width="250px"><a href="ellipse.html"><tt>ellipse</tt></a></td>
            <td>annotate an ellipse in a spherical plot</td>
            <tr></tr>
            <td width="250px"><a href="gcm.html"><tt>gcm</tt></a></td>
            <td>gcm is a function. mfig = mtexFig</td>
            <tr></tr>
            <td width="250px"><a href="getCamera.html"><tt>getCamera</tt></a></td>
            <td>get xAxis and zAxis position from axis</td>
            <tr></tr>
            <td width="250px"><a href="getColormaps.html"><tt>getColormaps</tt></a></td>
            <td>getColormaps is a function. [cm, cmd] = getColormaps</td>
            <tr></tr>
            <td width="250px"><a href="getHoldState.html"><tt>getHoldState</tt></a></td>
            <td>getHoldState is a function. ishold = getHoldState(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="getUnitScale.html"><tt>getUnitScale</tt></a></td>
            <td>Syntax factor = getUnitScale(unit)</td>
            <tr></tr>
            <td width="250px"><a href="hsl2hsv.html"><tt>hsl2hsv</tt></a></td>
            <td>hsl2hsv is a function. [h, s, v] = hsl2hsv(hh, ss, ll)</td>
            <tr></tr>
            <td width="250px"><a href="isRGB.html"><tt>isRGB</tt></a></td>
            <td>isRGB is a function. out = isRGB(fig)</td>
            <tr></tr>
            <td width="250px"><a href="mtexColorMap.html"><tt>mtexColorMap</tt></a></td>
            <td>define an MTEX colormap</td>
            <tr></tr>
            <td width="250px"><a href="mtexColorbar.html"><tt>mtexColorbar</tt></a></td>
            <td>overide buildin Matlab colorbar function</td>
            <tr></tr>
            <td width="250px"><a href="newMapPlot.html"><tt>newMapPlot</tt></a></td>
            <td>newMapPlot is a function. [mP, isNew] = newMapPlot(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="newMtexFigure.html"><tt>newMtexFigure</tt></a></td>
            <td>set uo a new plotting figure</td>
            <tr></tr>
            <td width="250px"><a href="newODFSectionPlot.html"><tt>newODFSectionPlot</tt></a></td>
            <td>generate a new ODF section plot</td>
            <tr></tr>
            <td width="250px"><a href="newSphericalPlot.html"><tt>newSphericalPlot</tt></a></td>
            <td>split plot in upper and lower hemisphere</td>
            <tr></tr>
            <td width="250px"><a href="nextAxis.html"><tt>nextAxis</tt></a></td>
            <td>nextAxis is a function. ax = nextAxis(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="nextstyle.html"><tt>nextstyle</tt></a></td>
            <td>NEXTSTYLE Get next plot linespec [L,C,M] = NEXTSTYLE(AX) gets the next line style, color and marker for plotting from the
               ColorOrder and LineStyleOrder of axes AX.
            </td>
            <tr></tr>
            <td width="250px"><a href="optiondraw.html"><tt>optiondraw</tt></a></td>
            <td>apply options to handle</td>
            <tr></tr>
            <td width="250px"><a href="optionplot.html"><tt>optionplot</tt></a></td>
            <td>plot y against x using the options in varargin</td>
            <tr></tr>
            <td width="250px"><a href="plotEllipse.html"><tt>plotEllipse</tt></a></td>
            <td>plot multiple ellipses</td>
            <tr></tr>
            <td width="250px"><a href="plotEmptySphere.html"><tt>plotEmptySphere</tt></a></td>
            <td>plots white sphere</td>
            <tr></tr>
            <td width="250px"><a href="plota2east.html"><tt>plota2east</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plota2north.html"><tt>plota2north</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plota2south.html"><tt>plota2south</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plota2west.html"><tt>plota2west</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotb2east.html"><tt>plotb2east</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotb2north.html"><tt>plotb2north</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotb2south.html"><tt>plotb2south</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotb2west.html"><tt>plotb2west</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2east.html"><tt>plotx2east</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2north.html"><tt>plotx2north</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2south.html"><tt>plotx2south</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2west.html"><tt>plotx2west</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotzIntoPlane.html"><tt>plotzIntoPlane</tt></a></td>
            <td>set the default plot direction of the z-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotzOutOfPlane.html"><tt>plotzOutOfPlane</tt></a></td>
            <td>set the default plot direction of the z-axis</td>
            <tr></tr>
            <td width="250px"><a href="saveFigure.html"><tt>saveFigure</tt></a></td>
            <td>save figure as graphics file</td>
            <tr></tr>
            <td width="250px"><a href="sectionLabels.html"><tt>sectionLabels</tt></a></td>
            <td>sectionLabels is a function. [symbol, labelx, labely] = sectionLabels(type)</td>
            <tr></tr>
            <td width="250px"><a href="selectPolygon.html"><tt>selectPolygon</tt></a></td>
            <td>select a polygon by mouse</td>
            <tr></tr>
            <td width="250px"><a href="setCamera.html"><tt>setCamera</tt></a></td>
            <td>set Camera according to xAxis and zAxis position</td>
            <tr></tr>
            <td width="250px"><a href="setColorRange.html"><tt>setColorRange</tt></a></td>
            <td>set color range for figures</td>
            <tr></tr>
            <td width="250px"><a href="switchUnit.html"><tt>switchUnit</tt></a></td>
            <td>returns the closest length to a known unit. For example, 10e3m will give 10km.</td>
            <tr></tr>
            <td width="250px"><a href="zUpDown.html"><tt>zUpDown</tt></a></td>
            <td>zUpDown is a function. v = zUpDown</td>
            <tr></tr>
            <td width="250px"><a href="assert_grid.html"><tt>assert_grid</tt></a></td>
            <td>check for valid grid parameters</td>
            <tr></tr>
            <td width="250px"><a href="calcUnitCell.html"><tt>calcUnitCell</tt></a></td>
            <td>compute the unit cell for an EBSD data set</td>
            <tr></tr>
            <td width="250px"><a href="check_interfaces.html"><tt>check_interfaces</tt></a></td>
            <td>determine interface from file</td>
            <tr></tr>
            <td width="250px"><a href="loadHelper.html"><tt>loadHelper</tt></a></td>
            <td>helps to load data-matrix with ColumnNames restricts also data according to conventions (e.g. &gt;4pi)</td>
            <tr></tr>
            <td width="250px"><a href="string2Miller.html"><tt>string2Miller</tt></a></td>
            <td>converts string to Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="docopt.html"><tt>docopt</tt></a></td>
            <td>DOCOPT Web browser for UNIX platforms. DOCOPT is an M-file that you or your system manager can edit to specify the Web browser
               to use with MATLAB. It is used for the WEB function with the -BROWSER option. It is also used for links to external Web sites
               from the the Help browser and from Web menu items. DOCOPT applies only to non-Macintosh UNIX platforms.
            </td>
            <tr></tr>
            <td width="250px"><a href="dynOption.html"><tt>dynOption</tt></a></td>
            <td>class to add dynamic options to a static class Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="dynProp.html"><tt>dynProp</tt></a></td>
            <td>class to add dynamic properties to a static class Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="mtexdata.html"><tt>mtexdata</tt></a></td>
            <td>load of data provided with mtex and often used in documentation</td>
            <tr></tr>
            <td width="250px"><a href="mtexdegchar.html"><tt>mtexdegchar</tt></a></td>
            <td>returns the degree character</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2> Plotting Tools <a name="22"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="DubnaGrid.html"><tt>DubnaGrid</tt></a></td>
            <td>construct specimen grid of the Dubna goniometer</td>
            <tr></tr>
            <td width="250px"><a href="DubnaPoleFigure.html"><tt>DubnaPoleFigure</tt></a></td>
            <td>construct pole figure using Dubna struct file</td>
            <tr></tr>
            <td width="250px"><a href="calc_background.html"><tt>calc_background</tt></a></td>
            <td>background of spectra</td>
            <tr></tr>
            <td width="250px"><a href="loadallspectra.html"><tt>loadallspectra</tt></a></td>
            <td>load all spectra files of a Dubna meassurement cycle</td>
            <tr></tr>
            <td width="250px"><a href="loadspectra.html"><tt>loadspectra</tt></a></td>
            <td>load a single spectrum o a Dubna meassurement</td>
            <tr></tr>
            <td width="250px"><a href="plot_spectra.html"><tt>plot_spectra</tt></a></td>
            <td>plot spectra of the Dubna goniometer</td>
            <tr></tr>
            <td width="250px"><a href="proceed_spectra.html"><tt>proceed_spectra</tt></a></td>
            <td>procede Dubna spectra</td>
            <tr></tr>
            <td width="250px"><a href="work.html"><tt>work</tt></a></td>
            <td>import spectra</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("21");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#21">Back to Top of Section</a></p>
         <h2> Geometry Tools<a name="23"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="CSL.html"><tt>CSL</tt></a></td>
            <td>coincidence site lattice misorientations for cubic symmetry</td>
            <tr></tr>
            <td width="250px"><a href="EulerAngleConvention.html"><tt>EulerAngleConvention</tt></a></td>
            <td>EulerAngleConvention is a function. [convention, labels] = EulerAngleConvention(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="axis2quat.html"><tt>axis2quat</tt></a></td>
            <td>rotational axis, roational angle to Quaternion</td>
            <tr></tr>
            <td width="250px"><a href="axis2quat_outer.html"><tt>axis2quat_outer</tt></a></td>
            <td>rotational axis, roational angle to Quaternion</td>
            <tr></tr>
            <td width="250px"><a href="checkEulerAngleConvention.html"><tt>checkEulerAngleConvention</tt></a></td>
            <td>checkEulerAngleConvention is a function. r = checkEulerAngleConvention(conv1, conv2)</td>
            <tr></tr>
            <td width="250px"><a href="equispacedS2Grid.html"><tt>equispacedS2Grid</tt></a></td>
            <td>defines an equispaced spherical grid</td>
            <tr></tr>
            <td width="250px"><a href="equispacedSO3Grid.html"><tt>equispacedSO3Grid</tt></a></td>
            <td>defines a equispaced grid in the orientation space</td>
            <tr></tr>
            <td width="250px"><a href="euler2quat.html"><tt>euler2quat</tt></a></td>
            <td>converts euler angle to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="expquat.html"><tt>expquat</tt></a></td>
            <td>matrix exponential to convert skew symmetric matrices into quaternions</td>
            <tr></tr>
            <td width="250px"><a href="extractSphericalRegion.html"><tt>extractSphericalRegion</tt></a></td>
            <td>TODO: maybe consider option 'antipodal'</td>
            <tr></tr>
            <td width="250px"><a href="fibre2quat.html"><tt>fibre2quat</tt></a></td>
            <td>arbitrary quaternion q with q * h = r</td>
            <tr></tr>
            <td width="250px"><a href="hr2quat.html"><tt>hr2quat</tt></a></td>
            <td>arbitrary quaternion q with q * h = r</td>
            <tr></tr>
            <td width="250px"><a href="loadCIF.html"><tt>loadCIF</tt></a></td>
            <td>import crystal symmetry from cif file</td>
            <tr></tr>
            <td width="250px"><a href="loadPHL.html"><tt>loadPHL</tt></a></td>
            <td>loadPHL is a function. cs = loadPHL(fname)</td>
            <tr></tr>
            <td width="250px"><a href="localOrientationGrid.html"><tt>localOrientationGrid</tt></a></td>
            <td>define a equispaced grid localized to a center orientation</td>
            <tr></tr>
            <td width="250px"><a href="mat2quat.html"><tt>mat2quat</tt></a></td>
            <td>converts direction cosine matrix to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="plotS2Grid.html"><tt>plotS2Grid</tt></a></td>
            <td>create a regular S2Grid for plotting</td>
            <tr></tr>
            <td width="250px"><a href="plotSO3Grid.html"><tt>plotSO3Grid</tt></a></td>
            <td>give a regular grid in orientation space</td>
            <tr></tr>
            <td width="250px"><a href="quadratureS2Grid.html"><tt>quadratureS2Grid</tt></a></td>
            <td>Syntax [S2G, W, M2] = quadratureS2Grid(M) quadrature grid of type chebyshev [S2G, W, M2] = quadratureS2Grid(M, 'gauss') quadrature
               grid of type gauss
            </td>
            <tr></tr>
            <td width="250px"><a href="reflection.html"><tt>reflection</tt></a></td>
            <td>defines a reflection at plane with normal n</td>
            <tr></tr>
            <td width="250px"><a href="regularS2Grid.html"><tt>regularS2Grid</tt></a></td>
            <td>Syntax regularS2Grid('points',[72 19]) regularS2Grid('resolution',[5*degree 2.5*degree]) regularS2Grid('theta',theta,'rho',rho)</td>
            <tr></tr>
            <td width="250px"><a href="regularSO3Grid.html"><tt>regularSO3Grid</tt></a></td>
            <td>regular grid in Euler orientation space</td>
            <tr></tr>
            <td width="250px"><a href="rodrigues2quat.html"><tt>rodrigues2quat</tt></a></td>
            <td>rodrigues2quat is a function. q = rodrigues2quat(R, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="vec42quat.html"><tt>vec42quat</tt></a></td>
            <td>returns a quaternion q with q u_1 = v1 and q u2 = v2</td>
            <tr></tr>
            <td width="250px"><a href="xvector.html"><tt>xvector</tt></a></td>
            <td>vector (1,0,0)</td>
            <tr></tr>
            <td width="250px"><a href="yvector.html"><tt>yvector</tt></a></td>
            <td>vector (0,1,0)</td>
            <tr></tr>
            <td width="250px"><a href="zvector.html"><tt>zvector</tt></a></td>
            <td>vector (0,0,1)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("21");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#21">Back to Top of Section</a></p>
         <h2> Statistics<a name="24"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="c_hat.html"><tt>c_hat</tt></a></td>
            <td>return the second moments for bingham test</td>
            <tr></tr>
            <td width="250px"><a href="cmeans.html"><tt>cmeans</tt></a></td>
            <td>m -  fuzzifier</td>
            <tr></tr>
            <td width="250px"><a href="kmeans.html"><tt>kmeans</tt></a></td>
            <td>k-means++: The Advantages of Careful Seeding", by David Arthur and  Sergei Vassilvitskii, SODA 2007.</td>
            <tr></tr>
            <td width="250px"><a href="quantile.html"><tt>quantile</tt></a></td>
            <td>n percent quantile of x</td>
            <tr></tr>
            <td width="250px"><a href="randp.html"><tt>randp</tt></a></td>
            <td>randp(lambda) returns Poisson distributed Vector with mean lambda</td>
            <tr></tr>
            <td width="250px"><a href="range.html"><tt>range</tt></a></td>
            <td>RANGE  Sample range. Y = RANGE(X) returns the range of the values in X.  For a vector input, Y is the difference between the
               maximum and minimum values.  For a matrix input, Y is a vector containing the range for each column.  For N-D arrays, RANGE
               operates along the first non-singleton dimension.
            </td>
         </table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("21");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#21">Back to Top of Section</a></p>
         <h2> Plotting<a name="25"> </a></h2>
         <table width="95%"></table>
         <p class="pagenavlink"><script language="Javascript">updateSectionId("21");</script><script language="Javascript">addTopOfSectionButtons();</script><a href="#21">Back to Top of Section</a></p>
         <p style="font-size:1px;"></p>
         <table class="footer" border="0" width="100%" cellpadding="0" cellspacing="0">
            <tr>
               <td valign="baseline" align="right">MTEX 5.2.beta2</td>
            </tr>
         </table>
      </div>
   </body>
</html>