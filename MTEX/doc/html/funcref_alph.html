
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <title>Functions - Alphabetical List (MTEX Toolbox)
         
      </title>
      <!-- DOCNAME: MTEX Toolbox -->
      <meta name="chunktype" content="refpage">
      <!-- CHUNKNAME:  -->
      <!-- HEADSTUFF:  -->
      <!-- HEADSTUFF -->
      <meta name="refentity" content="method:">
      <meta http-equiv="Content-Script-Type" content="text/javascript">
      <meta name="toctype" content="fcn">
      <link rel="stylesheet" href="style.css"><script language="JavaScript" src="docscripts.js"></script></head>
   <body><a name="top_of_page"></a><div>
         <table class="nav" summary="Navigation aid" border="0" width="100%" cellpadding="0" cellspacing="0">
            <tr>
               <td valign="baseline"><b>MTEX</b> - A MATLAB Toolbox for Quantitative Texture Analysis</td>
            </tr>
         </table>
         <p style="font-size:1px;"></p>
      </div>
      <div class="content">
         <h1 class="refname">Functions - Alphabetical List</h1>
         <div class="subheading">
            <div class="funcrefpage"><a href="funcref_cat.html">&gt;&gt; Categorial List</a></div><span> <a href="#1">A</a></span><span> <a href="#2">B</a></span><span> <a href="#3">C</a></span><span> <a href="#4">D</a></span><span> <a href="#5">E</a></span><span> <a href="#6">F</a></span><span> <a href="#7">G</a></span><span> <a href="#8">H</a></span><span> <a href="#9">I</a></span><span> J</span><span> <a href="#10">K</a></span><span> <a href="#11">L</a></span><span> <a href="#12">M</a></span><span> <a href="#13">N</a></span><span> <a href="#14">O</a></span><span> <a href="#15">P</a></span><span> <a href="#16">Q</a></span><span> <a href="#17">R</a></span><span> <a href="#18">S</a></span><span> <a href="#19">T</a></span><span> <a href="#20">U</a></span><span> <a href="#21">V</a></span><span> <a href="#22">W</a></span><span> <a href="#23">X</a></span><span> <a href="#24">Y</a></span><span> <a href="#25">Z</a></span></div>
         <h2>A<a name="1"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="AbelPoissonKernel.html"><tt>AbelPoissonKernel</tt></a></td>
            <td>the Abel Poisson kernel</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.abs.html"><tt>abs</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>absolute value of a function Syntax sF = abs(sF) sF = abs(sF, 'bandwidth', bandwidth)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.abs.html"><tt>abs</tt></a><span>   (S2FunTri)</span></td>
            <td>ABS    Absolute value. ABS(X) is the absolute value of the elements of X. When X is complex, ABS(X) is the complex modulus
               (magnitude) of the elements of X.
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.abs.html"><tt>abs</tt></a><span>   (vector3d)</span></td>
            <td>length of vector</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.accumarray.html"><tt>accumarray</tt></a><span>   (vector3d)</span></td>
            <td>accumarray for vector3d</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.acos.html"><tt>acos</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>cost of a function Syntax sF = acos(sF) sF = acos(sF, 'bandwidth', bandwidth)</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.add.html"><tt>add</tt></a><span>   (crystalSymmetry)</span></td>
            <td>add additional symmetry operations to a crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.adjustFigurePosition.html"><tt>adjustFigurePosition</tt></a><span>   (mtexFigure)</span></td>
            <td>determine optimal size</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.affinetrans.html"><tt>affinetrans</tt></a><span>   (EBSD)</span></td>
            <td>perform an affine transformation on spatial ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.alignment.html"><tt>alignment</tt></a><span>   (symmetry)</span></td>
            <td>return alignment of the reference frame as string, e.g. x||a, y||b*</td>
            <tr></tr>
            <td width="250px"><a href="allPairs.html"><tt>allPairs</tt></a></td>
            <td>all pairs of elements of x and y modulo permutation</td>
            <tr></tr>
            <td width="250px"><a href="allTriple.html"><tt>allTriple</tt></a></td>
            <td>all triple of elements of x and y modulo permutation</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldTri.angle.html"><tt>angle</tt></a><span>   (S2AxisFieldTri)</span></td>
            <td>Syntax sVF = angle(sVF,sVF2) sVF = angle(sVF,v)</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.angle.html"><tt>angle</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>Syntax sVF = angle(sVF,sVF2) sVF = angle(sVF,v)</td>
            <tr></tr>
            <td width="250px"><a href="fibre.angle.html"><tt>angle</tt></a><span>   (fibre)</span></td>
            <td>angle fibre to orientation or fibre to fibre</td>
            <tr></tr>
            <td width="250px"><a href="orientation.angle.html"><tt>angle</tt></a><span>   (orientation)</span></td>
            <td>calculates rotational angle between orientations</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.angle.html"><tt>angle</tt></a><span>   (quaternion)</span></td>
            <td>calcualtes the rotational angle between rotations q1 and q2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.angle.html"><tt>angle</tt></a><span>   (vector3d)</span></td>
            <td>angle between two vectors</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.angle_outer.html"><tt>angle_outer</tt></a><span>   (quaternion)</span></td>
            <td>calcualtes the rotational angle between all rotations q1 and q2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.angle_outer.html"><tt>angle_outer</tt></a><span>   (vector3d)</span></td>
            <td>angle between two vectors Input v1, v2 - @vector3d</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.angularVelocityVector.html"><tt>angularVelocityVector</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>angular velocity vector omega</td>
            <tr></tr>
            <td width="250px"><a href="annotate.html"><tt>annotate</tt></a></td>
            <td>annotate to a existing figure</td>
            <tr></tr>
            <td width="250px"><a href="tensor.antiSym.html"><tt>antiSym</tt></a><span>   (tensor)</span></td>
            <td>the antisymmetric part A = 0.5(T - T.') of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="apply_recursivly.html"><tt>apply_recursivly</tt></a></td>
            <td>apply cmd recursively to all file in a directory</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldHarmonic.approximation.html"><tt>approximation</tt></a><span>   (S2AxisFieldHarmonic)</span></td>
            <td>Syntax sAF = S2AxisField.quadrature(v, value) sAF = S2AxisField.quadrature(v, value, 'bandwidth', bw)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.approximation.html"><tt>approximation</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>computes a least square problem to get an approximation Syntax sF = S2FunHarmonic.approximation(S2Grid, f) sF = S2FunHarmonic.approximation(S2Grid,
               f, 'bandwidth', bandwidth, 'tol', TOL, 'maxit', MAXIT, 'weights', W)
            </td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.approximation.html"><tt>approximation</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>Syntax sVF = S2VectorField.quadrature(v, value) sVF = S2VectorField.quadrature(v, value, 'bandwidth', bw)</td>
            <tr></tr>
            <td width="250px"><a href="ar2rgb.html"><tt>ar2rgb</tt></a></td>
            <td>compute rgb values from angle and radius</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.area.html"><tt>area</tt></a><span>   (grain2d)</span></td>
            <td>calculates the area of a list of grains</td>
            <tr></tr>
            <td width="250px"><a href="argin_check.html"><tt>argin_check</tt></a></td>
            <td>check ar to be of class classes</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.arrow3d.html"><tt>arrow3d</tt></a><span>   (vector3d)</span></td>
            <td>plot three dimensional arrows</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.aspectRatio.html"><tt>aspectRatio</tt></a><span>   (grain2d)</span></td>
            <td>aspectratio = length / width</td>
            <tr></tr>
            <td width="250px"><a href="assert_grid.html"><tt>assert_grid</tt></a></td>
            <td>check for valid grid parameters</td>
            <tr></tr>
            <td width="250px"><a href="assertExt.html"><tt>assertExt</tt></a></td>
            <td>assertExt is a function. assertExt(fname, extList)</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.axesDual.html"><tt>axesDual</tt></a><span>   (crystalSymmetry)</span></td>
            <td>return dual coordinate axes</td>
            <tr></tr>
            <td width="250px"><a href="orientation.axis.html"><tt>axis</tt></a><span>   (orientation)</span></td>
            <td>rotational axis of an misorientation or two orientations</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.axis.html"><tt>axis</tt></a><span>   (quaternion)</span></td>
            <td>rotational axis of the quaternion</td>
            <tr></tr>
            <td width="250px"><a href="axis2quat.html"><tt>axis2quat</tt></a></td>
            <td>rotational axis, roational angle to Quaternion</td>
            <tr></tr>
            <td width="250px"><a href="axis2quat_outer.html"><tt>axis2quat_outer</tt></a></td>
            <td>rotational axis, roational angle to Quaternion</td>
            <tr></tr>
            <td width="250px"><a href="axisAngleColorKey.html"><tt>axisAngleColorKey</tt></a></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="axisAnglePlot.html"><tt>axisAnglePlot</tt></a></td>
            <td>create a 3d Euler angle plot</td>
            <tr></tr>
            <td width="250px"><a href="axisAngleSections.html"><tt>axisAngleSections</tt></a></td>
            <td>defines an axis angle section</td>
            <tr></tr>
            <td width="250px"><a href="strainTensor.axisRatios.html"><tt>axisRatios</tt></a><span>   (strainTensor)</span></td>
            <td>logarithmic axis ratios of the finite strain ellipsoid</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.axisRatios.html"><tt>axisRatios</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>logarithmic axis ratios of the finite strain ellipsoid</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.axisSector.html"><tt>axisSector</tt></a><span>   (orientationRegion)</span></td>
            <td>computes the sector of rotational axes for orientations within region</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>B<a name="2"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="ODF.bandwidth.html"><tt>bandwidth</tt></a><span>   (ODF)</span></td>
            <td>bandwidth of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.basicHKL.html"><tt>basicHKL</tt></a><span>   (crystalSymmetry)</span></td>
            <td>plot symmetry</td>
            <tr></tr>
            <td width="250px"><a href="orientation.BCV.html"><tt>BCV</tt></a><span>   (orientation)</span></td>
            <td>biased cross validation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.bingham_test.html"><tt>bingham_test</tt></a><span>   (orientation)</span></td>
            <td>bingham test for spherical/prolat/oblat case</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.BinghamComponent.html"><tt>BinghamComponent</tt></a><span>   (BinghamComponent)</span></td>
            <td>BinghamComponent is a class. component = BinghamComponent(kappa, A)</td>
            <tr></tr>
            <td width="250px"><a href="BinghamODF.html"><tt>BinghamODF</tt></a></td>
            <td>defines a Bingham distributed ODF</td>
            <tr></tr>
            <td width="250px"><a href="BinghamS2.BinghamS2.html"><tt>BinghamS2</tt></a><span>   (BinghamS2)</span></td>
            <td>Input Z -  smoothing parameters; Z(1)&gt;=Z(2)&gt;=Z(3), Z(3)&lt;0 Z(1)=Z(2)  rotationally symmetric unimodal distribution Z(1)&lt;&lt;Z(2)
               partial girdle distribution
            </td>
            <tr></tr>
            <td width="250px"><a href="binghamS2_demo.html"><tt>binghamS2_demo</tt></a></td>
            <td>BinghamS2: spherical Bingham distribution function</td>
            <tr></tr>
            <td width="250px"><a href="binsearch.html"><tt>binsearch</tt></a></td>
            <td>binaer search for zero in a motonously increasing function</td>
            <tr></tr>
            <td width="250px"><a href="refractiveIndexTensor.birefringence.html"><tt>birefringence</tt></a><span>   (refractiveIndexTensor)</span></td>
            <td>birefringence from refractive index tensor</td>
            <tr></tr>
            <td width="250px"><a href="black2whiteColorMap.html"><tt>black2whiteColorMap</tt></a></td>
            <td>Linear white to black gray-scale color map</td>
            <tr></tr>
            <td width="250px"><a href="blue2redColorMap.html"><tt>blue2redColorMap</tt></a></td>
            <td>creates a colormap, ranging from dark blue via white to dark red.</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.boundary.html"><tt>boundary</tt></a><span>   (sphericalRegion)</span></td>
            <td>compute boundary points</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.boundarySize.html"><tt>boundarySize</tt></a><span>   (grain2d)</span></td>
            <td>number of boundary segment</td>
            <tr></tr>
            <td width="250px"><a href="bucketSearch.html"><tt>bucketSearch</tt></a></td>
            <td>n-d search of the closest vertex out of a set of vertices V</td>
            <tr></tr>
            <td width="250px"><a href="bumpKernel.html"><tt>bumpKernel</tt></a></td>
            <td>the bump kernel Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="BungeColorKey.html"><tt>BungeColorKey</tt></a></td>
            <td>assigns rgb values to orientations according the the Euler angles</td>
            <tr></tr>
            <td width="250px"><a href="BungePlot.html"><tt>BungePlot</tt></a></td>
            <td>create a 3d Euler angle plot</td>
            <tr></tr>
            <td width="250px"><a href="orientation.byAxisAngle.html"><tt>byAxisAngle</tt></a><span>   (orientation)</span></td>
            <td>define orientations by rotational axis and rotational angle</td>
            <tr></tr>
            <td width="250px"><a href="rotation.byAxisAngle.html"><tt>byAxisAngle</tt></a><span>   (rotation)</span></td>
            <td>define rotations by rotational axis and rotational angle</td>
            <tr></tr>
            <td width="250px"><a href="orientation.byEuler.html"><tt>byEuler</tt></a><span>   (orientation)</span></td>
            <td>define orientations by Euler angles</td>
            <tr></tr>
            <td width="250px"><a href="rotation.byEuler.html"><tt>byEuler</tt></a><span>   (rotation)</span></td>
            <td>define rotentations by Euler angles</td>
            <tr></tr>
            <td width="250px"><a href="orientation.byMatrix.html"><tt>byMatrix</tt></a><span>   (orientation)</span></td>
            <td>define orientations by a matrix</td>
            <tr></tr>
            <td width="250px"><a href="rotation.byMatrix.html"><tt>byMatrix</tt></a><span>   (rotation)</span></td>
            <td>define rotations by matrices</td>
            <tr></tr>
            <td width="250px"><a href="orientation.byMiller.html"><tt>byMiller</tt></a><span>   (orientation)</span></td>
            <td>define orientations by Miller Bravais indeces</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.byVertices.html"><tt>byVertices</tt></a><span>   (sphericalRegion)</span></td>
            <td>define a spherical region by its vertices</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>C<a name="3"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="c_hat.html"><tt>c_hat</tt></a></td>
            <td>return the second moments for bingham test</td>
            <tr></tr>
            <td width="250px"><a href="calc_background.html"><tt>calc_background</tt></a></td>
            <td>background of spectra</td>
            <tr></tr>
            <td width="250px"><a href="calc_flags.html"><tt>calc_flags</tt></a></td>
            <td>check for optional flag</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a><span>   (ODF)</span></td>
            <td>compute the angle distribution of an ODF or an MDF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a><span>   (orientation)</span></td>
            <td>calculate angle distribution</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a><span>   (orientationRegion)</span></td>
            <td>compute the angle distribution of a uniform ODF for a crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.calcAngleDistribution.html"><tt>calcAngleDistribution</tt></a><span>   (symmetry)</span></td>
            <td>compute the angle distribution of a uniform ODF for a crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a><span>   (ODF)</span></td>
            <td>compute the axis distribution of an ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a><span>   (orientationRegion)</span></td>
            <td>compute the axis distribution of an uniform ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.calcAxisDistribution.html"><tt>calcAxisDistribution</tt></a><span>   (symmetry)</span></td>
            <td>compute the axis distribution of an uniform ODF or MDF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcAxisVolume.html"><tt>calcAxisVolume</tt></a><span>   (ODF)</span></td>
            <td>amount of orientations with a specific misorientation axis</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.calcBario.html"><tt>calcBario</tt></a><span>   (DelaunaySO3)</span></td>
            <td>compute bariocentric coordinates for an orientation</td>
            <tr></tr>
            <td width="250px"><a href="S2Triangulation.calcBario.html"><tt>calcBario</tt></a><span>   (S2Triangulation)</span></td>
            <td>S2Triangulation/calcBario is a function. [bario, tId] = calcBario(sT, v, tId)</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcBinghamODF.html"><tt>calcBinghamODF</tt></a><span>   (orientation)</span></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcCluster.html"><tt>calcCluster</tt></a><span>   (orientation)</span></td>
            <td>sort orientations into clusters</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcComponents.html"><tt>calcComponents</tt></a><span>   (ODF)</span></td>
            <td>heuristic to find modal orientations</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcDelaunay.html"><tt>calcDelaunay</tt></a><span>   (vector3d)</span></td>
            <td>compute the Delaynay triangulation for a spherical grid</td>
            <tr></tr>
            <td width="250px"><a href="Miller.calcDensity.html"><tt>calcDensity</tt></a><span>   (Miller)</span></td>
            <td>calculate a density function out of (weighted) crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcDensity.html"><tt>calcDensity</tt></a><span>   (vector3d)</span></td>
            <td>calculate a density function out of (weighted) unit vectors</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcError.html"><tt>calcError</tt></a><span>   (ODF)</span></td>
            <td>calculate approximation error between two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcError.html"><tt>calcError</tt></a><span>   (PoleFigure)</span></td>
            <td>RP and mean square error</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcErrorPF.html"><tt>calcErrorPF</tt></a><span>   (PoleFigure)</span></td>
            <td>error polefigure between meassured and recalculated pole figures</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcFEMODF.html"><tt>calcFEMODF</tt></a><span>   (PoleFigure)</span></td>
            <td>PDF to ODF inversion</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (BinghamComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (FourierComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcFourier.html"><tt>calcFourier</tt></a><span>   (ODF)</span></td>
            <td>compute Fourier coefficients of odf</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (femComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (fibreComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (uniformComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.calcFourier.html"><tt>calcFourier</tt></a><span>   (unimodalComponent)</span></td>
            <td>called by ODF/calcFourier</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcFourierODF.html"><tt>calcFourierODF</tt></a><span>   (orientation)</span></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="EBSDhex.calcGND.html"><tt>calcGND</tt></a><span>   (EBSDhex)</span></td>
            <td>compute the geometrically necessary dislocation</td>
            <tr></tr>
            <td width="250px"><a href="EBSDsquare.calcGND.html"><tt>calcGND</tt></a><span>   (EBSDsquare)</span></td>
            <td>compute the geometrically necessary dislocation</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcGrains.html"><tt>calcGrains</tt></a><span>   (EBSD)</span></td>
            <td>grains reconstruction from 2d EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcInvTaylor.html"><tt>calcInvTaylor</tt></a><span>   (orientation)</span></td>
            <td>Taylor factor from orientation gradient</td>
            <tr></tr>
            <td width="250px"><a href="calcKearnsFactor.html"><tt>calcKearnsFactor</tt></a></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcKernel.html"><tt>calcKernel</tt></a><span>   (orientation)</span></td>
            <td>compute an optimal kernel function for ODF estimation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcKernelODF.html"><tt>calcKernelODF</tt></a><span>   (orientation)</span></td>
            <td>calculate ODF from individuel orientations via kernel density estimation</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcMDF.html"><tt>calcMDF</tt></a><span>   (FourierComponent)</span></td>
            <td>calculate the uncorrelated misorientation distribution function (MDF) from one or two ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcMDF.html"><tt>calcMDF</tt></a><span>   (ODF)</span></td>
            <td>calculate the uncorrelated misorientation distribution function (MDF) from one or two ODF</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.calcMDF.html"><tt>calcMDF</tt></a><span>   (unimodalComponent)</span></td>
            <td>calculate the uncorrelated misorientation distribution function (MDF) from one or two ODF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcMDF.html"><tt>calcMDF</tt></a><span>   (orientation)</span></td>
            <td>computes an MDF from individuel orientations or misorientations</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.calcMeanDirection.html"><tt>calcMeanDirection</tt></a><span>   (grainBoundary)</span></td>
            <td>compute a smoothed direction that ignores staircasing</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcMIndex.html"><tt>calcMIndex</tt></a><span>   (ODF)</span></td>
            <td>M-index of Skemer et al.(2005) based on the difference between uncorrelated and uniform misorientation angle distributions</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcMIndex.html"><tt>calcMIndex</tt></a><span>   (orientation)</span></td>
            <td>TODO!!!</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcMisorientation.html"><tt>calcMisorientation</tt></a><span>   (EBSD)</span></td>
            <td>calculate uncorrelated misorientations between two ebsd phases</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.calcModes.html"><tt>calcModes</tt></a><span>   (BinghamComponent)</span></td>
            <td>return the modes of the component</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcModes.html"><tt>calcModes</tt></a><span>   (ODF)</span></td>
            <td>heuristic to find modal orientations</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.calcModes.html"><tt>calcModes</tt></a><span>   (ODFComponent)</span></td>
            <td>return the modes of the component</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.calcModes.html"><tt>calcModes</tt></a><span>   (fibreComponent)</span></td>
            <td>return the modes of the component</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.calcModes.html"><tt>calcModes</tt></a><span>   (unimodalComponent)</span></td>
            <td>return the modes of the component</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcNormalization.html"><tt>calcNormalization</tt></a><span>   (PoleFigure)</span></td>
            <td>normalization of a meassured pole figure with respect to a second pole figure</td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.calcODF.html"><tt>calcODF</tt></a><span>   (MLSSolver)</span></td>
            <td>apply zero range method</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcODF.html"><tt>calcODF</tt></a><span>   (PoleFigure)</span></td>
            <td>PDF to ODF inversion</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcODF.html"><tt>calcODF</tt></a><span>   (orientation)</span></td>
            <td>computes an ODF from individuel orientations</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcOrientations.html"><tt>calcOrientations</tt></a><span>   (ODF)</span></td>
            <td>draw random orientations from ODF</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (BinghamComponent)</span></td>
            <td>called by pdf</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (FourierComponent)</span></td>
            <td>calculate pole figure from Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcPDF.html"><tt>calcPDF</tt></a><span>   (ODF)</span></td>
            <td>calcPDF computed the PDF corresponding to an ODF</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (femComponent)</span></td>
            <td>called by pdf</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (fibreComponent)</span></td>
            <td>calculate pdf for fibre component</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (uniformComponent)</span></td>
            <td>calculate pdf</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.calcPDF.html"><tt>calcPDF</tt></a><span>   (unimodalComponent)</span></td>
            <td>compute the pole density function for a given unimodal component</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcpdf_special3.html"><tt>calcpdf_special3</tt></a><span>   (ODF)</span></td>
            <td>compute the pdf for h = (theta,rhoh), r = (theta,rhor)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcPoleFigure.html"><tt>calcPoleFigure</tt></a><span>   (ODF)</span></td>
            <td>simulate pole figures from an ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.calcPoleFigure.html"><tt>calcPoleFigure</tt></a><span>   (PoleFigure)</span></td>
            <td>simulate pole figure</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcQuadratureWeights.html"><tt>calcQuadratureWeights</tt></a><span>   (vector3d)</span></td>
            <td>compute the area of the Voronoi decomposition</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.calcQuat.html"><tt>calcQuat</tt></a><span>   (symmetry)</span></td>
            <td>calculate quaternions for Laue groups</td>
            <tr></tr>
            <td width="250px"><a href="stressTensor.calcShearStress.html"><tt>calcShearStress</tt></a><span>   (stressTensor)</span></td>
            <td>shear stress</td>
            <tr></tr>
            <td width="250px"><a href="strainTensor.calcTaylor.html"><tt>calcTaylor</tt></a><span>   (strainTensor)</span></td>
            <td>compute Taylor factor and strain dependent orientation gradient</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.calcTaylor.html"><tt>calcTaylor</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>compute Taylor factor and strain dependent orientation gradient</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.calcTensor.html"><tt>calcTensor</tt></a><span>   (EBSD)</span></td>
            <td>compute the average tensor for an EBSD data set</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.calcTensor.html"><tt>calcTensor</tt></a><span>   (FourierComponent)</span></td>
            <td>compute the average tensor for an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.calcTensor.html"><tt>calcTensor</tt></a><span>   (ODF)</span></td>
            <td>compute the average tensor for an ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.calcTensor.html"><tt>calcTensor</tt></a><span>   (ODFComponent)</span></td>
            <td>compute the average tensor for an ODF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.calcTensor.html"><tt>calcTensor</tt></a><span>   (orientation)</span></td>
            <td>compute the average tensor for a vector of orientations</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.calcTriplePoints.html"><tt>calcTriplePoints</tt></a><span>   (grainBoundary)</span></td>
            <td>compute triple points</td>
            <tr></tr>
            <td width="250px"><a href="calcUnitCell.html"><tt>calcUnitCell</tt></a></td>
            <td>compute the unit cell for an EBSD data set</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.calcVoronoi.html"><tt>calcVoronoi</tt></a><span>   (quaternion)</span></td>
            <td>compute the the Voronoi decomposition for unit quaternions</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcVoronoi.html"><tt>calcVoronoi</tt></a><span>   (vector3d)</span></td>
            <td>compute the area of the Voronoi decomposition</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.calcVoronoiArea.html"><tt>calcVoronoiArea</tt></a><span>   (vector3d)</span></td>
            <td>compute the spherical area of the Voronoi decomposition</td>
            <tr></tr>
            <td width="250px"><a href="zeroRangeMethod.calcZeroRange.html"><tt>calcZeroRange</tt></a><span>   (zeroRangeMethod)</span></td>
            <td>calculate zero range</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.calliper.html"><tt>calliper</tt></a><span>   (grain2d)</span></td>
            <td>Calliper (Feret diameter) of a grain in measurement units, the projection length normal to it and its direction/trend.</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.cat.html"><tt>cat</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads cat</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.cat.html"><tt>cat</tt></a><span>   (EBSD)</span></td>
            <td>overloads [ebsd1,ebsd2,ebsd3..]</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.cat.html"><tt>cat</tt></a><span>   (grain2d)</span></td>
            <td>implements [grain1, grain2]</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.cat.html"><tt>cat</tt></a><span>   (PoleFigure)</span></td>
            <td>implement cat for PoleFigure</td>
            <tr></tr>
            <td width="250px"><a href="Miller.cat.html"><tt>cat</tt></a><span>   (Miller)</span></td>
            <td>concatenate lists of Miller indices to one list</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.cat.html"><tt>cat</tt></a><span>   (S2Grid)</span></td>
            <td>implements cat for S2Grid</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.cat.html"><tt>cat</tt></a><span>   (dislocationSystem)</span></td>
            <td>implement cat for dislocationSystem</td>
            <tr></tr>
            <td width="250px"><a href="fibre.cat.html"><tt>cat</tt></a><span>   (fibre)</span></td>
            <td>implement cat for fibre</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.cat.html"><tt>cat</tt></a><span>   (quaternion)</span></td>
            <td>implement cat for quaternion</td>
            <tr></tr>
            <td width="250px"><a href="rotation.cat.html"><tt>cat</tt></a><span>   (rotation)</span></td>
            <td>implement cat for rotation</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.cat.html"><tt>cat</tt></a><span>   (slipSystem)</span></td>
            <td>implement cat for slipSystem</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cat.html"><tt>cat</tt></a><span>   (vector3d)</span></td>
            <td>implement cat for vector3d</td>
            <tr></tr>
            <td width="250px"><a href="deformationGradientTensor.CauchyStrain.html"><tt>CauchyStrain</tt></a><span>   (deformationGradientTensor)</span></td>
            <td>Cauchy strain or small strain</td>
            <tr></tr>
            <td width="250px"><a href="cell2file.html"><tt>cell2file</tt></a></td>
            <td>write cellstring to file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.centerSpecimen.html"><tt>centerSpecimen</tt></a><span>   (ODF)</span></td>
            <td>rotatates an odf with specimen symmetry into its symmetry axes</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.centroid.html"><tt>centroid</tt></a><span>   (grain2d)</span></td>
            <td>calculates the barycenters of the grain boundary</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.centroid.html"><tt>centroid</tt></a><span>   (vector3d)</span></td>
            <td>compute the centroid of a 2d polygon in 3d</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.char.html"><tt>char</tt></a><span>   (EBSD)</span></td>
            <td>ebsd -&gt; char</td>
            <tr></tr>
            <td width="250px"><a href="ODF.char.html"><tt>char</tt></a><span>   (ODF)</span></td>
            <td>odf -&gt; char</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.char.html"><tt>char</tt></a><span>   (uniformComponent)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.char.html"><tt>char</tt></a><span>   (unimodalComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.char.html"><tt>char</tt></a><span>   (PoleFigure)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="tensor.char.html"><tt>char</tt></a><span>   (tensor)</span></td>
            <td>tensor to char</td>
            <tr></tr>
            <td width="250px"><a href="Miller.char.html"><tt>char</tt></a><span>   (Miller)</span></td>
            <td>Miller indece to string</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.char.html"><tt>char</tt></a><span>   (SO3Grid)</span></td>
            <td>convert to char</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.char.html"><tt>char</tt></a><span>   (crystalSymmetry)</span></td>
            <td>object -&gt; string</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.char.html"><tt>char</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to char</td>
            <tr></tr>
            <td width="250px"><a href="rotation.char.html"><tt>char</tt></a><span>   (rotation)</span></td>
            <td>quaternion to char</td>
            <tr></tr>
            <td width="250px"><a href="specimenSymmetry.char.html"><tt>char</tt></a><span>   (specimenSymmetry)</span></td>
            <td>object -&gt; string</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.char.html"><tt>char</tt></a><span>   (sphericalRegion)</span></td>
            <td>convert spherical region to char</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.char.html"><tt>char</tt></a><span>   (vector3d)</span></td>
            <td>convert to char</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.ChebCoeff.html"><tt>ChebCoeff</tt></a><span>   (FourierComponent)</span></td>
            <td>return Chebyshev coefficient of odf</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.check.html"><tt>check</tt></a><span>   (DelaunaySO3)</span></td>
            <td>ignore this</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.check.html"><tt>check</tt></a><span>   (symmetry)</span></td>
            <td>check symmetry</td>
            <tr></tr>
            <td width="250px"><a href="check_installation.html"><tt>check_installation</tt></a></td>
            <td>check whether all binaries are working properly</td>
            <tr></tr>
            <td width="250px"><a href="check_interfaces.html"><tt>check_interfaces</tt></a></td>
            <td>determine interface from file</td>
            <tr></tr>
            <td width="250px"><a href="check_option.html"><tt>check_option</tt></a></td>
            <td>check for option in option list</td>
            <tr></tr>
            <td width="250px"><a href="checkEulerAngleConvention.html"><tt>checkEulerAngleConvention</tt></a></td>
            <td>checkEulerAngleConvention is a function. r = checkEulerAngleConvention(conv1, conv2)</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.checkInside.html"><tt>checkInside</tt></a><span>   (grain2d)</span></td>
            <td>check for points or grains to be inside a big grain</td>
            <tr></tr>
            <td width="250px"><a href="S2Triangulation.checkInside.html"><tt>checkInside</tt></a><span>   (S2Triangulation)</span></td>
            <td>S2Triangulation/checkInside is a function. [isInside, tId, bario] = checkInside(sT, v, tId)</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.checkInside.html"><tt>checkInside</tt></a><span>   (orientationRegion)</span></td>
            <td>check for points to be inside the orientation region</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.checkInside.html"><tt>checkInside</tt></a><span>   (sphericalRegion)</span></td>
            <td>check for points to be inside the spherical region</td>
            <tr></tr>
            <td width="250px"><a href="checkOption.html"><tt>checkOption</tt></a></td>
            <td>check for option in option list</td>
            <tr></tr>
            <td width="250px"><a href="tensor.checkSymmetry.html"><tt>checkSymmetry</tt></a><span>   (tensor)</span></td>
            <td>tensor/checkSymmetry is a function. out = checkSymmetry(T)</td>
            <tr></tr>
            <td width="250px"><a href="zeroRangeMethod.checkZeroRange.html"><tt>checkZeroRange</tt></a><span>   (zeroRangeMethod)</span></td>
            <td>check for zero regions in experiementl pole figures</td>
            <tr></tr>
            <td width="250px"><a href="ChristoffelTensor.ChristoffelTensor.html"><tt>ChristoffelTensor</tt></a><span>   (ChristoffelTensor)</span></td>
            <td>ChristoffelTensor is a class. sT = ChristoffelTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.ChristoffelTensor.html"><tt>ChristoffelTensor</tt></a><span>   (complianceTensor)</span></td>
            <td>Christoffel tensor of an elasticity tensor for a given direction</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.ChristoffelTensor.html"><tt>ChristoffelTensor</tt></a><span>   (stiffnessTensor)</span></td>
            <td>Christoffel tensor of an elasticity tensor for a given direction</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.circle.html"><tt>circle</tt></a><span>   (vector3d)</span></td>
            <td>annotated a circle</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.cleanUp.html"><tt>cleanUp</tt></a><span>   (orientationRegion)</span></td>
            <td>testing: cs = crystalSymmetry('222'); oR = cs.fundamentalRegion;</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.cleanUp.html"><tt>cleanUp</tt></a><span>   (sphericalRegion)</span></td>
            <td>sphericalRegion/cleanUp is a function. sR = cleanUp(sR)</td>
            <tr></tr>
            <td width="250px"><a href="ClebschGordan.html"><tt>ClebschGordan</tt></a></td>
            <td>ClebschGordan.m by David Terr, Raytheon, 6-17-04 Modified on 11-9-04</td>
            <tr></tr>
            <td width="250px"><a href="ClebschGordanTensor.html"><tt>ClebschGordanTensor</tt></a></td>
            <td>A = [[1 1 -1];[1 1 1];[-1 1 1]];</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.CLim.html"><tt>CLim</tt></a><span>   (mtexFigure)</span></td>
            <td>set color range for figures</td>
            <tr></tr>
            <td width="250px"><a href="closeAllButCurrentFiles.html"><tt>closeAllButCurrentFiles</tt></a></td>
            <td>close all open files exept for the current one</td>
            <tr></tr>
            <td width="250px"><a href="clusterBreaker.html"><tt>clusterBreaker</tt></a></td>
            <td>Recursively assigns points based on neighboring assignments If flag == 0, the point is fresh,  1, the point is set &gt;1, the
               point belongs to a cluster that may have run into the recusion limit
            </td>
            <tr></tr>
            <td width="250px"><a href="cmeans.html"><tt>cmeans</tt></a></td>
            <td>m -  fuzzifier</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.coarser.html"><tt>coarser</tt></a><span>   (S1Grid)</span></td>
            <td>makes S1Grid more coarse</td>
            <tr></tr>
            <td width="250px"><a href="tensor.colon.html"><tt>colon</tt></a><span>   (tensor)</span></td>
            <td>double dot A:B between two tensors</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.colorbar.html"><tt>colorbar</tt></a><span>   (mtexFigure)</span></td>
            <td>COLORBAR Display color bar (color scale) COLORBAR appends a colorbar to the current axes in the default (right) location</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.complianceTensor.html"><tt>complianceTensor</tt></a><span>   (complianceTensor)</span></td>
            <td>complianceTensor is a class. sT = complianceTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.compressionDirection.html"><tt>compressionDirection</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>compression direction</td>
            <tr></tr>
            <td width="250px"><a href="ODF.concentration.html"><tt>concentration</tt></a><span>   (ODF)</span></td>
            <td>not yet implemeted</td>
            <tr></tr>
            <td width="250px"><a href="conformalPlot.html"><tt>conformalPlot</tt></a></td>
            <td>create a 3d Euler angle plot</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.conj.html"><tt>conj</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>conjugate S2FunHarmonic</td>
            <tr></tr>
            <td width="250px"><a href="tensor.conj.html"><tt>conj</tt></a><span>   (tensor)</span></td>
            <td>conjugate of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="connectedComponents.html"><tt>connectedComponents</tt></a></td>
            <td>label connected componentes in an graph (adjacency matrix)</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.contour.html"><tt>contour</tt></a><span>   (S2Fun)</span></td>
            <td>spherical contour plot</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.contour.html"><tt>contour</tt></a><span>   (vector3d)</span></td>
            <td>spherical contour plot</td>
            <tr></tr>
            <td width="250px"><a href="contour3s.html"><tt>contour3s</tt></a></td>
            <td>contour-slices</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.contourf.html"><tt>contourf</tt></a><span>   (S2Fun)</span></td>
            <td>spherical filled contour plot</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.contourf.html"><tt>contourf</tt></a><span>   (vector3d)</span></td>
            <td>spherical filled contour plot</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.conv.html"><tt>conv</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>spherical convolution of sF with a radial function psi</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.conv.html"><tt>conv</tt></a><span>   (FourierComponent)</span></td>
            <td>convolute ODF with kernel psi</td>
            <tr></tr>
            <td width="250px"><a href="ODF.conv.html"><tt>conv</tt></a><span>   (ODF)</span></td>
            <td>convolute ODF with kernel psi</td>
            <tr></tr>
            <td width="250px"><a href="convertFigureRGB2ind.html"><tt>convertFigureRGB2ind</tt></a></td>
            <td>default resolution</td>
            <tr></tr>
            <td width="250px"><a href="coolColorMap.html"><tt>coolColorMap</tt></a></td>
            <td>COOL   Shades of cyan and magenta color map COOL(M) returns an M-by-3 matrix containing a "cool" colormap. COOL, by itself,
               is the same length as the current figure's colormap. If no figure exists, MATLAB creates one.
            </td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.copy.html"><tt>copy</tt></a><span>   (S2Grid)</span></td>
            <td>copy certain condition from grid</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.copy.html"><tt>copy</tt></a><span>   (SO3Grid)</span></td>
            <td>copy nodes by indece</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.correct.html"><tt>correct</tt></a><span>   (PoleFigure)</span></td>
            <td>corrects polfigures for background and defocussing</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.cos.html"><tt>cos</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>cost of a function Syntax sF = cos(sF) sF = cos(sF, 'bandwidth', bandwidth)</td>
            <tr></tr>
            <td width="250px"><a href="cprintf.html"><tt>cprintf</tt></a></td>
            <td>CPRINTF	convert an array of any data type to a 2D character array</td>
            <tr></tr>
            <td width="250px"><a href="cprproject_read.html"><tt>cprproject_read</tt></a></td>
            <td>cprproject_read is a function. phases = cprproject_read(fname)</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldHarmonic.cross.html"><tt>cross</tt></a><span>   (S2AxisFieldHarmonic)</span></td>
            <td>syntax f = cross(sAF,v) f = cross(sAF1,sAF2) f = cross(sAF,sVF)</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldTri.cross.html"><tt>cross</tt></a><span>   (S2AxisFieldTri)</span></td>
            <td>Syntax sVF = cross(sVF1,sVF2) sVF = cross(sVF1,v)</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.cross.html"><tt>cross</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>pointwise cross product</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.cross.html"><tt>cross</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>Syntax sVF = cross(sVF1,sVF2) sVF = cross(sVF1,v)</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.cross.html"><tt>cross</tt></a><span>   (quaternion)</span></td>
            <td>pointwise cross product of three quaternions</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cross.html"><tt>cross</tt></a><span>   (vector3d)</span></td>
            <td>pointwise cross product of two vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.cross_outer.html"><tt>cross_outer</tt></a><span>   (vector3d)</span></td>
            <td>pointwise cross product of two vector3d</td>
            <tr></tr>
            <td width="250px"><a href="orientation.crossCorrelation.html"><tt>crossCorrelation</tt></a><span>   (orientation)</span></td>
            <td>computes the cross correlation for the kernel density estimator</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.crystalShape.html"><tt>crystalShape</tt></a><span>   (crystalShape)</span></td>
            <td>a class representing crystal shapes.</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.crystalSymmetry.html"><tt>crystalSymmetry</tt></a><span>   (crystalSymmetry)</span></td>
            <td>constructor</td>
            <tr></tr>
            <td width="250px"><a href="CSL.html"><tt>CSL</tt></a></td>
            <td>coincidence site lattice misorientations for cubic symmetry</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.ctranspose.html"><tt>ctranspose</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>ctransposes S2FunHarmonic</td>
            <tr></tr>
            <td width="250px"><a href="tensor.ctranspose.html"><tt>ctranspose</tt></a><span>   (tensor)</span></td>
            <td>conjugate of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="orientation.ctranspose.html"><tt>ctranspose</tt></a><span>   (orientation)</span></td>
            <td>inverse orientation</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ctranspose.html"><tt>ctranspose</tt></a><span>   (quaternion)</span></td>
            <td>transpose quaternion</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.ctranspose.html"><tt>ctranspose</tt></a><span>   (vector3d)</span></td>
            <td>transpose vector</td>
            <tr></tr>
            <td width="250px"><a href="cubochoricGrid.cubochoricGrid.html"><tt>cubochoricGrid</tt></a><span>   (cubochoricGrid)</span></td>
            <td>Syntax S3G = cubochoricGrid(ori,alphabeta,gamma)</td>
            <tr></tr>
            <td width="250px"><a href="cunion.html"><tt>cunion</tt></a></td>
            <td>disjoint union</td>
            <tr></tr>
            <td width="250px"><a href="EBSDhex.curvature.html"><tt>curvature</tt></a><span>   (EBSDhex)</span></td>
            <td>computes the incomplete curvature tensor</td>
            <tr></tr>
            <td width="250px"><a href="EBSDsquare.curvature.html"><tt>curvature</tt></a><span>   (EBSDsquare)</span></td>
            <td>computes the incomplete curvature tensor</td>
            <tr></tr>
            <td width="250px"><a href="dislocationDensityTensor.curvature.html"><tt>curvature</tt></a><span>   (dislocationDensityTensor)</span></td>
            <td>compute curvature tensor from a (complete) dislocation density tensor</td>
            <tr></tr>
            <td width="250px"><a href="curvatureTensor.curvatureTensor.html"><tt>curvatureTensor</tt></a><span>   (curvatureTensor)</span></td>
            <td>curvatureTensor is a class. kappa = curvatureTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="customKernel.html"><tt>customKernel</tt></a></td>
            <td>defines a kernel function as a function of the rotational angle</td>
            <tr></tr>
            <td width="250px"><a href="cut2unitI.html"><tt>cut2unitI</tt></a></td>
            <td>cut2unitI is a function. x = cut2unitI(x)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>D<a name="4"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="deformationGradientTensor.deformationGradientTensor.html"><tt>deformationGradientTensor</tt></a><span>   (deformationGradientTensor)</span></td>
            <td>deformationGradientTensor is a class. F = deformationGradientTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.deformationTensor.html"><tt>deformationTensor</tt></a><span>   (slipSystem)</span></td>
            <td>deformation tensor</td>
            <tr></tr>
            <td width="250px"><a href="deg2dim.html"><tt>deg2dim</tt></a></td>
            <td>dimension of the harmonic space up to order l</td>
            <tr></tr>
            <td width="250px"><a href="degree.html"><tt>degree</tt></a></td>
            <td>x * degree =  x in standard arc measure</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.DelaunaySO3.html"><tt>DelaunaySO3</tt></a><span>   (DelaunaySO3)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="deLaValeePoussinKernel.html"><tt>deLaValeePoussinKernel</tt></a></td>
            <td>DELAVALEEPOUSSINKERNEL Summary of this class goes here Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.delete.html"><tt>delete</tt></a><span>   (S1Grid)</span></td>
            <td>delte points from S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.delete.html"><tt>delete</tt></a><span>   (S2Grid)</span></td>
            <td>elilinates points from grid</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.delete.html"><tt>delete</tt></a><span>   (SO3Grid)</span></td>
            <td>clear nodes by indece Input SOG    - @SO3Grid indece - int32</td>
            <tr></tr>
            <td width="250px"><a href="delete_option.html"><tt>delete_option</tt></a></td>
            <td>clear options in option list</td>
            <tr></tr>
            <td width="250px"><a href="tensor.det.html"><tt>det</tt></a><span>   (tensor)</span></td>
            <td>compute the determinants of rank 2 tensors</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.det.html"><tt>det</tt></a><span>   (vector3d)</span></td>
            <td>pointwise determinant or triple product of three vector3d</td>
            <tr></tr>
            <td width="250px"><a href="det3.html"><tt>det3</tt></a></td>
            <td>determinant of a list of 3x3 matrices</td>
            <tr></tr>
            <td width="250px"><a href="strainTensor.deviatoricStrain.html"><tt>deviatoricStrain</tt></a><span>   (strainTensor)</span></td>
            <td>deviatoric strain tensor</td>
            <tr></tr>
            <td width="250px"><a href="stressTensor.deviatoricStress.html"><tt>deviatoricStress</tt></a><span>   (stressTensor)</span></td>
            <td>deviatoric stress</td>
            <tr></tr>
            <td width="250px"><a href="tensor.diag.html"><tt>diag</tt></a><span>   (tensor)</span></td>
            <td>convert rank 1 or rank 0 tensor into diagonal rank 2 tensor</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.diameter.html"><tt>diameter</tt></a><span>   (grain2d)</span></td>
            <td>diameter of a grain in measurement units longest distance between any two vertices of the grain boundary</td>
            <tr></tr>
            <td width="250px"><a href="dim2deg.html"><tt>dim2deg</tt></a></td>
            <td>dimension to harmonic degree of Wiegner D functions</td>
            <tr></tr>
            <td width="250px"><a href="tensor.directionalMagnitude.html"><tt>directionalMagnitude</tt></a><span>   (tensor)</span></td>
            <td>magnitude of a tensor in direction v</td>
            <tr></tr>
            <td width="250px"><a href="directionColorKey.html"><tt>directionColorKey</tt></a></td>
            <td>converts directions to rgb values</td>
            <tr></tr>
            <td width="250px"><a href="DirichletKernel.html"><tt>DirichletKernel</tt></a></td>
            <td>the Dirichlet kernel in the orientation space</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.discreteSample.html"><tt>discreteSample</tt></a><span>   (S2Fun)</span></td>
            <td>takes a random sample of n directions from S2Fun</td>
            <tr></tr>
            <td width="250px"><a href="ODF.discreteSample.html"><tt>discreteSample</tt></a><span>   (ODF)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (ODFComponent)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (femComponent)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (fibreComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (uniformComponent)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.discreteSample.html"><tt>discreteSample</tt></a><span>   (unimodalComponent)</span></td>
            <td>draw a random sample</td>
            <tr></tr>
            <td width="250px"><a href="discreteSample.html"><tt>discreteSample</tt></a></td>
            <td>take a diskrete sample from a list of vectors, orientations, grains, EBSD</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.disjoint.html"><tt>disjoint</tt></a><span>   (symmetry)</span></td>
            <td>returns the disjoint of two symmetry groups</td>
            <tr></tr>
            <td width="250px"><a href="curvatureTensor.dislocationDensity.html"><tt>dislocationDensity</tt></a><span>   (curvatureTensor)</span></td>
            <td>compute the dislocationDensity tensor from a curvature tensor</td>
            <tr></tr>
            <td width="250px"><a href="dislocationDensityTensor.dislocationDensityTensor.html"><tt>dislocationDensityTensor</tt></a><span>   (dislocationDensityTensor)</span></td>
            <td>dislocation density or Nye tensor</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.dislocationSystem.html"><tt>dislocationSystem</tt></a><span>   (dislocationSystem)</span></td>
            <td>class representing dislocation systems</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldHarmonic.display.html"><tt>display</tt></a><span>   (S2AxisFieldHarmonic)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.display.html"><tt>display</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.display.html"><tt>display</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.display.html"><tt>display</tt></a><span>   (S2FunTri)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.display.html"><tt>display</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.display.html"><tt>display</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.display.html"><tt>display</tt></a><span>   (EBSD)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.display.html"><tt>display</tt></a><span>   (grain2d)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.display.html"><tt>display</tt></a><span>   (grainBoundary)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="triplePointList.display.html"><tt>display</tt></a><span>   (triplePointList)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.display.html"><tt>display</tt></a><span>   (BinghamComponent)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.display.html"><tt>display</tt></a><span>   (FourierComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="ODF.display.html"><tt>display</tt></a><span>   (ODF)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.display.html"><tt>display</tt></a><span>   (femComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.display.html"><tt>display</tt></a><span>   (fibreComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.display.html"><tt>display</tt></a><span>   (uniformComponent)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.display.html"><tt>display</tt></a><span>   (unimodalComponent)</span></td>
            <td>called by standard output</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.display.html"><tt>display</tt></a><span>   (PoleFigure)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="tensor.display.html"><tt>display</tt></a><span>   (tensor)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.display.html"><tt>display</tt></a><span>   (DelaunaySO3)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="Miller.display.html"><tt>display</tt></a><span>   (Miller)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.display.html"><tt>display</tt></a><span>   (S1Grid)</span></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.display.html"><tt>display</tt></a><span>   (S2Grid)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.display.html"><tt>display</tt></a><span>   (SO3Grid)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.display.html"><tt>display</tt></a><span>   (crystalShape)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.display.html"><tt>display</tt></a><span>   (crystalSymmetry)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="fibre.display.html"><tt>display</tt></a><span>   (fibre)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="orientation.display.html"><tt>display</tt></a><span>   (orientation)</span></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.display.html"><tt>display</tt></a><span>   (orientationRegion)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.display.html"><tt>display</tt></a><span>   (quaternion)</span></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="rotation.display.html"><tt>display</tt></a><span>   (rotation)</span></td>
            <td>standart output</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.display.html"><tt>display</tt></a><span>   (sphericalRegion)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.display.html"><tt>display</tt></a><span>   (vector3d)</span></td>
            <td>standard output</td>
            <tr></tr>
            <td width="250px"><a href="displayClass.html"><tt>displayClass</tt></a></td>
            <td>displayClass is a function. displayClass(obj, input)</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.dispLine.html"><tt>dispLine</tt></a><span>   (crystalSymmetry)</span></td>
            <td>display symmetry as a one-liner</td>
            <tr></tr>
            <td width="250px"><a href="specimenSymmetry.dispLine.html"><tt>dispLine</tt></a><span>   (specimenSymmetry)</span></td>
            <td>display symmetry as a one-liner</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.dist.html"><tt>dist</tt></a><span>   (S1Grid)</span></td>
            <td>distance to all points of S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.dist_outer.html"><tt>dist_outer</tt></a><span>   (S1Grid)</span></td>
            <td>distance to all points of S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="doclink.html"><tt>doclink</tt></a></td>
            <td>doclink is a function. linkText = doclink(fname, lname)</td>
            <tr></tr>
            <td width="250px"><a href="docmethods.html"><tt>docmethods</tt></a></td>
            <td>display all methods for a certain class</td>
            <tr></tr>
            <td width="250px"><a href="docopt.html"><tt>docopt</tt></a></td>
            <td>DOCOPT Web browser for UNIX platforms. DOCOPT is an M-file that you or your system manager can edit to specify the Web browser
               to use with MATLAB. It is used for the WEB function with the -BROWSER option. It is also used for links to external Web sites
               from the the Help browser and from Web menu items. DOCOPT applies only to non-Macintosh UNIX platforms.
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.doHClustering.html"><tt>doHClustering</tt></a><span>   (orientation)</span></td>
            <td>sort orientations into clusters</td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.doIter.html"><tt>doIter</tt></a><span>   (MLSSolver)</span></td>
            <td>perform one iteration step of the modified least squares algorithm</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldHarmonic.dot.html"><tt>dot</tt></a><span>   (S2AxisFieldHarmonic)</span></td>
            <td>syntax f = dot(sAF,v) f = dot(sAF1,sAF2) f = dot(sAF,sVF)</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldTri.dot.html"><tt>dot</tt></a><span>   (S2AxisFieldTri)</span></td>
            <td>Syntax sVF = dot(sVF,sVF2) sVF = dot(sVF,v)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.dot.html"><tt>dot</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>inner product</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.dot.html"><tt>dot</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>pointwise inner product</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.dot.html"><tt>dot</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>Syntax sVF = dot(sVF,sVF2) sVF = dot(sVF,v)</td>
            <tr></tr>
            <td width="250px"><a href="Miller.dot.html"><tt>dot</tt></a><span>   (Miller)</span></td>
            <td>inner product between two Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="orientation.dot.html"><tt>dot</tt></a><span>   (orientation)</span></td>
            <td>compute minimum dot(o1,o2) modulo symmetry</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot.html"><tt>dot</tt></a><span>   (quaternion)</span></td>
            <td>inner product of quaternions g1 and g2</td>
            <tr></tr>
            <td width="250px"><a href="rotation.dot.html"><tt>dot</tt></a><span>   (rotation)</span></td>
            <td>compute rot1 . rot2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.dot.html"><tt>dot</tt></a><span>   (vector3d)</span></td>
            <td>pointwise inner product</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot_angle.html"><tt>dot_angle</tt></a><span>   (quaternion)</span></td>
            <td>compute minimum q1 . q2 modulo rotation about zaxis and angle omega</td>
            <tr></tr>
            <td width="250px"><a href="Miller.dot_outer.html"><tt>dot_outer</tt></a><span>   (Miller)</span></td>
            <td>inner product between two Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.dot_outer.html"><tt>dot_outer</tt></a><span>   (SO3Grid)</span></td>
            <td>return outer inner product of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="orientation.dot_outer.html"><tt>dot_outer</tt></a><span>   (orientation)</span></td>
            <td>dot_outer</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.dot_outer.html"><tt>dot_outer</tt></a><span>   (quaternion)</span></td>
            <td>outer inner product between two quaternions</td>
            <tr></tr>
            <td width="250px"><a href="rotation.dot_outer.html"><tt>dot_outer</tt></a><span>   (rotation)</span></td>
            <td>dot_outer</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.dot_outer.html"><tt>dot_outer</tt></a><span>   (vector3d)</span></td>
            <td>outer dot product</td>
            <tr></tr>
            <td width="250px"><a href="tensor.double.html"><tt>double</tt></a><span>   (tensor)</span></td>
            <td>convert tensor values to matrix</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.double.html"><tt>double</tt></a><span>   (S1Grid)</span></td>
            <td>convert to double</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.double.html"><tt>double</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to double</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.double.html"><tt>double</tt></a><span>   (vector3d)</span></td>
            <td>converts vector3d to double Input v - @vector3d Output x, y, z - double</td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.doZeroRange.html"><tt>doZeroRange</tt></a><span>   (MLSSolver)</span></td>
            <td>MLSSolver/doZeroRange is a function. doZeroRange(solver, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.drawNow.html"><tt>drawNow</tt></a><span>   (mtexFigure)</span></td>
            <td>mtexFigure/drawNow is a function. drawNow(mtexFig, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="Miller.dspacing.html"><tt>dspacing</tt></a><span>   (Miller)</span></td>
            <td>space between crystal planes</td>
            <tr></tr>
            <td width="250px"><a href="DubnaGrid.html"><tt>DubnaGrid</tt></a></td>
            <td>construct specimen grid of the Dubna goniometer</td>
            <tr></tr>
            <td width="250px"><a href="DubnaPoleFigure.html"><tt>DubnaPoleFigure</tt></a></td>
            <td>construct pole figure using Dubna struct file</td>
            <tr></tr>
            <td width="250px"><a href="dyad.html"><tt>dyad</tt></a></td>
            <td>dyadic tensor product</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.dyad.html"><tt>dyad</tt></a><span>   (vector3d)</span></td>
            <td>dyadic tensor product</td>
            <tr></tr>
            <td width="250px"><a href="dynOption.html"><tt>dynOption</tt></a></td>
            <td>class to add dynamic options to a static class Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="dynProp.html"><tt>dynProp</tt></a></td>
            <td>class to add dynamic properties to a static class Detailed explanation goes here</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>E<a name="5"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="eangleProjection.html"><tt>eangleProjection</tt></a></td>
            <td>stereographic, conformal or equal angle projection</td>
            <tr></tr>
            <td width="250px"><a href="eareaProjection.html"><tt>eareaProjection</tt></a></td>
            <td>equal area projection</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.EBSD.html"><tt>EBSD</tt></a><span>   (EBSD)</span></td>
            <td>constructor</td>
            <tr></tr>
            <td width="250px"><a href="EBSDhex.EBSDhex.html"><tt>EBSDhex</tt></a><span>   (EBSDhex)</span></td>
            <td>EBSD data on a hexagonal grid. In contrast to arbitrary EBSD data the values are stored in a matrix.</td>
            <tr></tr>
            <td width="250px"><a href="EBSDsquare.EBSDsquare.html"><tt>EBSDsquare</tt></a><span>   (EBSDsquare)</span></td>
            <td>EBSD data on a rectangular grid. In contrast to arbitrary EBSD data the values are stored in a matrix.</td>
            <tr></tr>
            <td width="250px"><a href="edistProjection.html"><tt>edistProjection</tt></a></td>
            <td>equal distant projection</td>
            <tr></tr>
            <td width="250px"><a href="efopen.html"><tt>efopen</tt></a></td>
            <td>file open with error message</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.eig.html"><tt>eig</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>eigen value of a spherical function</td>
            <tr></tr>
            <td width="250px"><a href="tensor.eig.html"><tt>eig</tt></a><span>   (tensor)</span></td>
            <td>compute the eigenvalues and eigenvectors of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="eig2.html"><tt>eig2</tt></a></td>
            <td>eigenvalue and vectors of a symmetric 2x2 matrix</td>
            <tr></tr>
            <td width="250px"><a href="eig3.html"><tt>eig3</tt></a></td>
            <td>eigenvalue and vectors of a symmetric 3x3 matrix</td>
            <tr></tr>
            <td width="250px"><a href="EinsteinSum.html"><tt>EinsteinSum</tt></a></td>
            <td>tensor multiplication according to Einstein summation convention</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.EinsteinSum.html"><tt>EinsteinSum</tt></a><span>   (quaternion)</span></td>
            <td>tensor multiplication according to Einstein summation</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.elements.html"><tt>elements</tt></a><span>   (symmetry)</span></td>
            <td>extract symmetry elements by multiplicity</td>
            <tr></tr>
            <td width="250px"><a href="ellipse.html"><tt>ellipse</tt></a></td>
            <td>annotate an ellipse in a spherical plot</td>
            <tr></tr>
            <td width="250px"><a href="strainTensor.ellipsoid.html"><tt>ellipsoid</tt></a><span>   (strainTensor)</span></td>
            <td>Length (1+e) and direction of principal axes of strain ellipsoid from finite, lagrangian/eulerian strain tensor E with eigenvalues
               lambda with (1+e) = sqrt(1+2*lambda) for a Lagranage strain tensor (default) (1+e) = sqrt(1-2*lambda) for a Euler strain tensor
               Syntax [fe,qe] = ellipsoid(E)
            </td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.end.html"><tt>end</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="tensor.end.html"><tt>end</tt></a><span>   (tensor)</span></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.end.html"><tt>end</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="fibre.end.html"><tt>end</tt></a><span>   (fibre)</span></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.end.html"><tt>end</tt></a><span>   (quaternion)</span></td>
            <td>overloads end function</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.end.html"><tt>end</tt></a><span>   (slipSystem)</span></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.end.html"><tt>end</tt></a><span>   (vector3d)</span></td>
            <td>overloaded end function</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.energyVector.html"><tt>energyVector</tt></a><span>   (stiffnessTensor)</span></td>
            <td>Calculates Energy velocity vector (km/s)</td>
            <tr></tr>
            <td width="250px"><a href="ensurecell.html"><tt>ensurecell</tt></a></td>
            <td>ensures that v is a cell with size s</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.ensureCS.html"><tt>ensureCS</tt></a><span>   (symmetry)</span></td>
            <td>ensures that an obj has the right crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="ensureNonNeg.html"><tt>ensureNonNeg</tt></a></td>
            <td>remove small negative values</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.entropy.html"><tt>entropy</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>entropy of a function</td>
            <tr></tr>
            <td width="250px"><a href="ODF.entropy.html"><tt>entropy</tt></a><span>   (ODF)</span></td>
            <td>caclulate entropy of ODF</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.eq.html"><tt>eq</tt></a><span>   (grain2d)</span></td>
            <td>==  Equal. A == B does element by element comparisons between A and B and returns an array with elements set to logical 1
               (TRUE) where the relation is true and elements set to logical 0 (FALSE) where it is not. A and B must have compatible sizes.
               In the simplest cases, they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension,
               the dimension sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.eq.html"><tt>eq</tt></a><span>   (tensor)</span></td>
            <td>checks whether two tensors are equal</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.eq.html"><tt>eq</tt></a><span>   (S1Grid)</span></td>
            <td>implements G1 == G2</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.eq.html"><tt>eq</tt></a><span>   (crystalSymmetry)</span></td>
            <td>check S1 == S2</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.eq.html"><tt>eq</tt></a><span>   (dislocationSystem)</span></td>
            <td>? sS1 == sS2</td>
            <tr></tr>
            <td width="250px"><a href="fibre.eq.html"><tt>eq</tt></a><span>   (fibre)</span></td>
            <td>? sS1 == sS2</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.eq.html"><tt>eq</tt></a><span>   (orientationRegion)</span></td>
            <td>==  Equal. A == B does element by element comparisons between A and B and returns an array with elements set to logical 1
               (TRUE) where the relation is true and elements set to logical 0 (FALSE) where it is not. A and B must have compatible sizes.
               In the simplest cases, they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension,
               the dimension sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.eq.html"><tt>eq</tt></a><span>   (quaternion)</span></td>
            <td>? q1 == q2</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.eq.html"><tt>eq</tt></a><span>   (slipSystem)</span></td>
            <td>? sS1 == sS2</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.eq.html"><tt>eq</tt></a><span>   (sphericalRegion)</span></td>
            <td>==  Equal. A == B does element by element comparisons between A and B and returns an array with elements set to logical 1
               (TRUE) where the relation is true and elements set to logical 0 (FALSE) where it is not. A and B must have compatible sizes.
               In the simplest cases, they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension,
               the dimension sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="symmetry.eq.html"><tt>eq</tt></a><span>   (symmetry)</span></td>
            <td>check S1 == S2</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.eq.html"><tt>eq</tt></a><span>   (vector3d)</span></td>
            <td>? v1 == v2</td>
            <tr></tr>
            <td width="250px"><a href="equal.html"><tt>equal</tt></a></td>
            <td>check all elements of A to be equal</td>
            <tr></tr>
            <td width="250px"><a href="equispacedS2Grid.html"><tt>equispacedS2Grid</tt></a></td>
            <td>defines an equispaced spherical grid</td>
            <tr></tr>
            <td width="250px"><a href="equispacedSO3Grid.html"><tt>equispacedSO3Grid</tt></a></td>
            <td>defines a equispaced grid in the orientation space</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.equivalentPerimeter.html"><tt>equivalentPerimeter</tt></a><span>   (grain2d)</span></td>
            <td>returns the equivalent perimeter of grain-polygon</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.equivalentRadius.html"><tt>equivalentRadius</tt></a><span>   (grain2d)</span></td>
            <td>returns the equivalent radius of grain-polygon</td>
            <tr></tr>
            <td width="250px"><a href="strainTensor.equivalentStrain.html"><tt>equivalentStrain</tt></a><span>   (strainTensor)</span></td>
            <td>von Mises equivalent strain</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.equivalentStrain.html"><tt>equivalentStrain</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>equivalent strain of a strain tensor</td>
            <tr></tr>
            <td width="250px"><a href="stressTensor.equivalentStress.html"><tt>equivalentStress</tt></a><span>   (stressTensor)</span></td>
            <td>von Mises equivalent stress</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.Euler.html"><tt>Euler</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to euler angle</td>
            <tr></tr>
            <td width="250px"><a href="euler2quat.html"><tt>euler2quat</tt></a></td>
            <td>converts euler angle to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="EulerAngleConvention.html"><tt>EulerAngleConvention</tt></a></td>
            <td>EulerAngleConvention is a function. [convention, labels] = EulerAngleConvention(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="EulerCycles.html"><tt>EulerCycles</tt></a></td>
            <td>retrieve Euler cycles from an not oriented edge list</td>
            <tr></tr>
            <td width="250px"><a href="EulerTours.html"><tt>EulerTours</tt></a></td>
            <td>find Euler tours in an adjacency matrix</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldHarmonic.eval.html"><tt>eval</tt></a><span>   (S2AxisFieldHarmonic)</span></td>
            <td>syntax f = eval(sF,v)</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldTri.eval.html"><tt>eval</tt></a><span>   (S2AxisFieldTri)</span></td>
            <td>Syntax v = eval(sFV,nodes)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.eval.html"><tt>eval</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>evaluates the spherical harmonic on a given set of points Syntax f = eval(sF,v)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.eval.html"><tt>eval</tt></a><span>   (S2FunTri)</span></td>
            <td>syntax f = eval(sF,v)</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.eval.html"><tt>eval</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>syntax f = eval(sVF,v)</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.eval.html"><tt>eval</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>Syntax v = eval(sFV,nodes)</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.eval.html"><tt>eval</tt></a><span>   (BinghamComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.eval.html"><tt>eval</tt></a><span>   (FourierComponent)</span></td>
            <td>evaluate odf using NSOFT</td>
            <tr></tr>
            <td width="250px"><a href="ODF.eval.html"><tt>eval</tt></a><span>   (ODF)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.eval.html"><tt>eval</tt></a><span>   (femComponent)</span></td>
            <td>evaluate an odf at orientation ori</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.eval.html"><tt>eval</tt></a><span>   (fibreComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.eval.html"><tt>eval</tt></a><span>   (uniformComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.eval.html"><tt>eval</tt></a><span>   (unimodalComponent)</span></td>
            <td>evaluate sum of unimodal components at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="evalkappa.html"><tt>evalkappa</tt></a></td>
            <td>eigenvalues of orientation tensor to bingham distribution parameters</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.even.html"><tt>even</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>even or antipodal part of a spherical function</td>
            <tr></tr>
            <td width="250px"><a href="Miller.exp.html"><tt>exp</tt></a><span>   (Miller)</span></td>
            <td>misorientation vector to misorientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.exp.html"><tt>exp</tt></a><span>   (orientation)</span></td>
            <td>exponential function</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.exp.html"><tt>exp</tt></a><span>   (vector3d)</span></td>
            <td>rotation vector to rotation</td>
            <tr></tr>
            <td width="250px"><a href="tensor.expm.html"><tt>expm</tt></a><span>   (tensor)</span></td>
            <td>matrix exponential of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.expm.html"><tt>expm</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>deformation gradient tensor from velocity gradient tensor</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.export.html"><tt>export</tt></a><span>   (EBSD)</span></td>
            <td>export EBSD data to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export.html"><tt>export</tt></a><span>   (ODF)</span></td>
            <td>export an ODF to an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.export.html"><tt>export</tt></a><span>   (PoleFigure)</span></td>
            <td>export pole figure in an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.export.html"><tt>export</tt></a><span>   (quaternion)</span></td>
            <td>export quaternions to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.export.html"><tt>export</tt></a><span>   (vector3d)</span></td>
            <td>export quaternions to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_generic.html"><tt>export_generic</tt></a><span>   (ODF)</span></td>
            <td>export an ODF to an ASCII file</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.export_h5.html"><tt>export_h5</tt></a><span>   (EBSD)</span></td>
            <td>export EBSD data to a ascii file</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_mtex.html"><tt>export_mtex</tt></a><span>   (ODF)</span></td>
            <td>export an ODF into the MTEX format</td>
            <tr></tr>
            <td width="250px"><a href="ODF.export_VPSC.html"><tt>export_VPSC</tt></a><span>   (ODF)</span></td>
            <td>export an ODF to the VPSC format</td>
            <tr></tr>
            <td width="250px"><a href="orientation.export_VPSC.html"><tt>export_VPSC</tt></a><span>   (orientation)</span></td>
            <td>export individual orientations to the VPSC format</td>
            <tr></tr>
            <td width="250px"><a href="expquat.html"><tt>expquat</tt></a></td>
            <td>matrix exponential to convert skew symmetric matrices into quaternions</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.extend.html"><tt>extend</tt></a><span>   (EBSD)</span></td>
            <td>returns the boundings of spatial EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.extensionDirection.html"><tt>extensionDirection</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>extension direction</td>
            <tr></tr>
            <td width="250px"><a href="extract_argoption.html"><tt>extract_argoption</tt></a></td>
            <td>extract options from option list</td>
            <tr></tr>
            <td width="250px"><a href="extract_data.html"><tt>extract_data</tt></a></td>
            <td>extract data</td>
            <tr></tr>
            <td width="250px"><a href="extract_option.html"><tt>extract_option</tt></a></td>
            <td>extract options from option list</td>
            <tr></tr>
            <td width="250px"><a href="extract_SO3grid.html"><tt>extract_SO3grid</tt></a></td>
            <td>extract_SO3grid is a function. [S3G, options] = extract_SO3grid(obj, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="extractSphericalRegion.html"><tt>extractSphericalRegion</tt></a></td>
            <td>TODO: maybe consider option 'antipodal'</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>F<a name="6"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="symmetry.factor.html"><tt>factor</tt></a><span>   (symmetry)</span></td>
            <td>factorizes s1 and s2 into l, d, r such that s1 = l * d and s2 = d * r</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.FCE.html"><tt>FCE</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>finite strain ellipsoid</td>
            <tr></tr>
            <td width="250px"><a href="fclencurt.html"><tt>fclencurt</tt></a></td>
            <td>Fast Clenshaw Curtis Quadrature</td>
            <tr></tr>
            <td width="250px"><a href="fdct.html"><tt>fdct</tt></a></td>
            <td>fdct is a function. C = fdct(x)</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.femComponent.html"><tt>femComponent</tt></a><span>   (femComponent)</span></td>
            <td>defines an ODF by finite elements</td>
            <tr></tr>
            <td width="250px"><a href="femODF.html"><tt>femODF</tt></a></td>
            <td>defines an ODF by finite elements</td>
            <tr></tr>
            <td width="250px"><a href="fibre.fibre.html"><tt>fibre</tt></a><span>   (fibre)</span></td>
            <td>fibre is a class representing a fibre in orientation space. Examples are alpha, beta or gamma fibres. In general a fibre is
               defined by a crystal direction h of type &lt;Miller_index.html Miller&gt; and a specimen direction of type &lt;vector3d_index.html
               vector3d&gt;.
            </td>
            <tr></tr>
            <td width="250px"><a href="fibre2quat.html"><tt>fibre2quat</tt></a></td>
            <td>arbitrary quaternion q with q * h = r</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.fibreComponent.html"><tt>fibreComponent</tt></a><span>   (fibreComponent)</span></td>
            <td>defines an fibre symmetric component</td>
            <tr></tr>
            <td width="250px"><a href="fibreODF.html"><tt>fibreODF</tt></a></td>
            <td>defines an fibre symmetric ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.fibreVolume.html"><tt>fibreVolume</tt></a><span>   (ODF)</span></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientation.fibreVolume.html"><tt>fibreVolume</tt></a><span>   (orientation)</span></td>
            <td>ratio of orientations close to a certain fibre</td>
            <tr></tr>
            <td width="250px"><a href="fibreVonMisesFisherKernel.html"><tt>fibreVonMisesFisherKernel</tt></a></td>
            <td>extract parameter and halfwidth</td>
            <tr></tr>
            <td width="250px"><a href="file2cell.html"><tt>file2cell</tt></a></td>
            <td>reads a file rowise into a cellstr</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.fill.html"><tt>fill</tt></a><span>   (EBSD)</span></td>
            <td>extrapolate spatial EBSD data by nearest neighbour for tetragonal lattice</td>
            <tr></tr>
            <td width="250px"><a href="EBSDhex.fill.html"><tt>fill</tt></a><span>   (EBSDhex)</span></td>
            <td>fill spatial EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSDsquare.fill.html"><tt>fill</tt></a><span>   (EBSDsquare)</span></td>
            <td>fill spatial EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.fillByGrainId.html"><tt>fillByGrainId</tt></a><span>   (EBSD)</span></td>
            <td>extrapolate spatial EBSD data by nearest neighbour for tetragonal lattice</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.find.html"><tt>find</tt></a><span>   (S1Grid)</span></td>
            <td>find close points</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.find.html"><tt>find</tt></a><span>   (S2Grid)</span></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.find.html"><tt>find</tt></a><span>   (SO3Grid)</span></td>
            <td>return indece and distance of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.find.html"><tt>find</tt></a><span>   (quaternion)</span></td>
            <td>return indece and distance of all nodes within a eps neighborhood</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.find.html"><tt>find</tt></a><span>   (vector3d)</span></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="find_option.html"><tt>find_option</tt></a></td>
            <td>find postions of the options in option_list</td>
            <tr></tr>
            <td width="250px"><a href="find_type.html"><tt>find_type</tt></a></td>
            <td>parse arguments list for a specific type an returns the first occurance</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.findByLocation.html"><tt>findByLocation</tt></a><span>   (EBSD)</span></td>
            <td>select EBSD data by spatial coordinates</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.findByLocation.html"><tt>findByLocation</tt></a><span>   (grain2d)</span></td>
            <td>select a grain by spatial coordinates</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.findByOrientation.html"><tt>findByOrientation</tt></a><span>   (EBSD)</span></td>
            <td>select ebsd data by orientation</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.findByOrientation.html"><tt>findByOrientation</tt></a><span>   (grain2d)</span></td>
            <td>select grains by orientation</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.findOutlier.html"><tt>findOutlier</tt></a><span>   (PoleFigure)</span></td>
            <td>find outliers in pole figures</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.findTetra.html"><tt>findTetra</tt></a><span>   (DelaunaySO3)</span></td>
            <td>find tetrahegon</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.finiteStrain.html"><tt>finiteStrain</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>derive finte strain axes and magnitudes from deformation tensor after n-steps (in strain rate units of L) using the solution
               of Provost et al.2014 doi:10.1029/2001JB001734
            </td>
            <tr></tr>
            <td width="250px"><a href="BinghamS2.fit.html"><tt>fit</tt></a><span>   (BinghamS2)</span></td>
            <td>function to fit Bingham parameters</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.fitArea.html"><tt>fitArea</tt></a><span>   (crystalShape)</span></td>
            <td>change habitus of crystal shape to fit given faceAreas</td>
            <tr></tr>
            <td width="250px"><a href="curvatureTensor.fitDislocationSystems.html"><tt>fitDislocationSystems</tt></a><span>   (curvatureTensor)</span></td>
            <td>fit dislocation systems to a curvature tensor</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.fitEllipse.html"><tt>fitEllipse</tt></a><span>   (grain2d)</span></td>
            <td>fit ellipses to grains using the method described in Mulchrone&amp; Choudhury,2004 (https://doi.org/10.1016/S0191-8141(03)00093-2)</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.flip.html"><tt>flip</tt></a><span>   (grainBoundary)</span></td>
            <td>flip a boundary from phase1/phase2 to phase2/phase1</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.fliplr.html"><tt>fliplr</tt></a><span>   (EBSD)</span></td>
            <td>flip spatial ebsd-data from left to right</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.flipud.html"><tt>flipud</tt></a><span>   (EBSD)</span></td>
            <td>flip spatial ebsd-data from upside down</td>
            <tr></tr>
            <td width="250px"><a href="FMC_Coarsen.html"><tt>FMC_Coarsen</tt></a></td>
            <td>Performs one coarsening step.</td>
            <tr></tr>
            <td width="250px"><a href="FMC_interpret.html"><tt>FMC_interpret</tt></a></td>
            <td>Interpretation of FMC data and grain assignment</td>
            <tr></tr>
            <td width="250px"><a href="FMC_MTEX.html"><tt>FMC_MTEX</tt></a></td>
            <td>setup Wnext</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.Fourier.html"><tt>Fourier</tt></a><span>   (FourierComponent)</span></td>
            <td>get Fourier coefficients of and ODF</td>
            <tr></tr>
            <td width="250px"><a href="tensor.Fourier.html"><tt>Fourier</tt></a><span>   (tensor)</span></td>
            <td>compute the Fourier coefficients of the tensor</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.FourierComponent.html"><tt>FourierComponent</tt></a><span>   (FourierComponent)</span></td>
            <td>defines an ODF component by its Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="ODF.FourierODF.html"><tt>FourierODF</tt></a><span>   (ODF)</span></td>
            <td>compute FourierODF from another ODF</td>
            <tr></tr>
            <td width="250px"><a href="FourierODF.html"><tt>FourierODF</tt></a></td>
            <td>defines an ODF by its Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.free_nfft.html"><tt>free_nfft</tt></a><span>   (MLSSolver)</span></td>
            <td>MLSSolver/free_nfft is a function. free_nfft(solver)</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.fundamentalRegion.html"><tt>fundamentalRegion</tt></a><span>   (symmetry)</span></td>
            <td>fundamental region in orientation space for a (pair) of symmetries</td>
            <tr></tr>
            <td width="250px"><a href="fundamentalRegion.html"><tt>fundamentalRegion</tt></a></td>
            <td>get the fundamental zone in orientation space for a symmetry</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.fundamentalRegionEuler.html"><tt>fundamentalRegionEuler</tt></a><span>   (symmetry)</span></td>
            <td>get the fundamental region in Euler angles</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.fundamentalSector.html"><tt>fundamentalSector</tt></a><span>   (symmetry)</span></td>
            <td>get the fundamental sector for a symmetry in the inverse pole figure</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>G<a name="7"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="gammaSections.html"><tt>gammaSections</tt></a></td>
            <td>gamma sections for ODF and orientation plotting</td>
            <tr></tr>
            <td width="250px"><a href="GaussWeierstrassKernel.html"><tt>GaussWeierstrassKernel</tt></a></td>
            <td>extract parameter and halfwidth</td>
            <tr></tr>
            <td width="250px"><a href="gcm.html"><tt>gcm</tt></a></td>
            <td>gcm is a function. mfig = mtexFig</td>
            <tr></tr>
            <td width="250px"><a href="generic_wizard.html"><tt>generic_wizard</tt></a></td>
            <td>generic_wizard is a function. values = generic_wizard(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.geodesic.html"><tt>geodesic</tt></a><span>   (quaternion)</span></td>
            <td>Calculats the rotation, which is described by the geodesic  gamma(t)_{rot1,rot2} from rot1 to rot2 at the location t, for
               vectors of n rotations.
            </td>
            <tr></tr>
            <td width="250px"><a href="get_flag.html"><tt>get_flag</tt></a></td>
            <td>extract flag from option list</td>
            <tr></tr>
            <td width="250px"><a href="get_obj_fields.html"><tt>get_obj_fields</tt></a></td>
            <td>get_obj_fields is a function. varargout = get_obj_fields(obj, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="get_option.html"><tt>get_option</tt></a></td>
            <td>extract option from option list</td>
            <tr></tr>
            <td width="250px"><a href="getCamera.html"><tt>getCamera</tt></a></td>
            <td>get xAxis and zAxis position from axis</td>
            <tr></tr>
            <td width="250px"><a href="getClass.html"><tt>getClass</tt></a></td>
            <td>getClass is a function. out = getClass(list, className, default)</td>
            <tr></tr>
            <td width="250px"><a href="getColormaps.html"><tt>getColormaps</tt></a></td>
            <td>getColormaps is a function. [cm, cmd] = getColormaps</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.getdata.html"><tt>getdata</tt></a><span>   (S2Grid)</span></td>
            <td>return index of all points in a epsilon neighborhood of a vector</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.getDataCursorPos.html"><tt>getDataCursorPos</tt></a><span>   (mtexFigure)</span></td>
            <td>get the position and value of the data cursor</td>
            <tr></tr>
            <td width="250px"><a href="orientation.getFundamentalRegion.html"><tt>getFundamentalRegion</tt></a><span>   (orientation)</span></td>
            <td>projects orientations to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="getHoldState.html"><tt>getHoldState</tt></a></td>
            <td>getHoldState is a function. ishold = getHoldState(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="getmem.html"><tt>getmem</tt></a></td>
            <td>return total system memory in kb</td>
            <tr></tr>
            <td width="250px"><a href="rotation.getMinAxes.html"><tt>getMinAxes</tt></a><span>   (rotation)</span></td>
            <td>rotation/getMinAxes is a function. [axes, angle] = getMinAxes(rot)</td>
            <tr></tr>
            <td width="250px"><a href="getMTEXpref.html"><tt>getMTEXpref</tt></a></td>
            <td>getMTEXpref is a function. value = getMTEXpref(pref, default)</td>
            <tr></tr>
            <td width="250px"><a href="getSubDirs.html"><tt>getSubDirs</tt></a></td>
            <td>getSubDirs - gets recursively all subdirectories of a given directory.</td>
            <tr></tr>
            <td width="250px"><a href="getUnitScale.html"><tt>getUnitScale</tt></a></td>
            <td>Syntax factor = getUnitScale(unit)</td>
            <tr></tr>
            <td width="250px"><a href="gnonomicProjection.html"><tt>gnonomicProjection</tt></a></td>
            <td>gnonomic projection</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.grad.html"><tt>grad</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>calculates the gradiet of a spherical harmonic</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.grad.html"><tt>grad</tt></a><span>   (S2FunTri)</span></td>
            <td>S2FunTri/grad is a function. g = grad(sF, v)</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.grad.html"><tt>grad</tt></a><span>   (FourierComponent)</span></td>
            <td>gradient at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="ODF.grad.html"><tt>grad</tt></a><span>   (ODF)</span></td>
            <td>gradient of odf at orientation ori</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.grad.html"><tt>grad</tt></a><span>   (ODFComponent)</span></td>
            <td>gradient at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.grad.html"><tt>grad</tt></a><span>   (fibreComponent)</span></td>
            <td>evaluate an odf at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.grad.html"><tt>grad</tt></a><span>   (uniformComponent)</span></td>
            <td>gradient of the ODF at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.grad.html"><tt>grad</tt></a><span>   (unimodalComponent)</span></td>
            <td>gradient at orientation g</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.grain2d.html"><tt>grain2d</tt></a><span>   (grain2d)</span></td>
            <td>two dimensional grains</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.grainBoundary.html"><tt>grainBoundary</tt></a><span>   (grainBoundary)</span></td>
            <td>grainBoundary list of grain boundaries in 2-D</td>
            <tr></tr>
            <td width="250px"><a href="deformationGradientTensor.GreenStrain.html"><tt>GreenStrain</tt></a><span>   (deformationGradientTensor)</span></td>
            <td>Syntax E = GreenStrain(F)</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.gridify.html"><tt>gridify</tt></a><span>   (EBSD)</span></td>
            <td>extend EBSD data to an grid</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.GridLength.html"><tt>GridLength</tt></a><span>   (S1Grid)</span></td>
            <td>return number of points</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>H<a name="8"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="h5group2struct.html"><tt>h5group2struct</tt></a></td>
            <td>read h5 group to struct</td>
            <tr></tr>
            <td width="250px"><a href="halfQuadraticFilter.html"><tt>halfQuadraticFilter</tt></a></td>
            <td>haldQuadraticFilter uses the techniques elaborated half-quadratic minmization on manifolds to smooth EBSD data. Properties:
                 alpha:  regularisation parameter in [x,y] direction weight: function handle specified by the regularising function \varphi,
               @(t,eps), where eps is its parameter eps:    Parameter for the weight tol:    Tolerance for the gradient descent threshold:
               threshold for subgrain boundaries Methods:      smooth: Applies the HQ minimization on the quaternions of the given orientations
            </td>
            <tr></tr>
            <td width="250px"><a href="grain2d.hasHole.html"><tt>hasHole</tt></a><span>   (grain2d)</span></td>
            <td>test if a grain has a hole or not</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.hist.html"><tt>hist</tt></a><span>   (grain2d)</span></td>
            <td>plot a grain size histogram</td>
            <tr></tr>
            <td width="250px"><a href="ODF.hist.html"><tt>hist</tt></a><span>   (ODF)</span></td>
            <td>calcualtes a histogram of ODF</td>
            <tr></tr>
            <td width="250px"><a href="HKLDirectionKey.html"><tt>HKLDirectionKey</tt></a></td>
            <td>HKLDirectionKey is a class. dM = HKLDirectionKey(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="homochoricPlot.html"><tt>homochoricPlot</tt></a></td>
            <td>create a 3d Euler angle plot</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.horzcat.html"><tt>horzcat</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads horzcat</td>
            <tr></tr>
            <td width="250px"><a href="tensor.horzcat.html"><tt>horzcat</tt></a><span>   (tensor)</span></td>
            <td>overloads [T1,T2,T3..]</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.horzcat.html"><tt>horzcat</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="fibre.horzcat.html"><tt>horzcat</tt></a><span>   (fibre)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.horzcat.html"><tt>horzcat</tt></a><span>   (orientationRegion)</span></td>
            <td>HORZCAT Horizontal concatenation. [A B] is the horizontal concatenation of matrices A and B.  A and B must have the same number
               of rows.  [A,B] is the same thing.  Any number of matrices can be concatenated within one pair of brackets. Horizontal and
               vertical concatenation can be combined together as in [1 2;3 4].
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.horzcat.html"><tt>horzcat</tt></a><span>   (quaternion)</span></td>
            <td>implements [q1,q2,q3..]</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.horzcat.html"><tt>horzcat</tt></a><span>   (slipSystem)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.horzcat.html"><tt>horzcat</tt></a><span>   (sphericalRegion)</span></td>
            <td>HORZCAT Horizontal concatenation. [A B] is the horizontal concatenation of matrices A and B.  A and B must have the same number
               of rows.  [A,B] is the same thing.  Any number of matrices can be concatenated within one pair of brackets. Horizontal and
               vertical concatenation can be combined together as in [1 2;3 4].
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.horzcat.html"><tt>horzcat</tt></a><span>   (vector3d)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="hotColorMap.html"><tt>hotColorMap</tt></a></td>
            <td>HOT    Black-red-yellow-white color map HOT(M) returns an M-by-3 matrix containing a "hot" colormap. HOT, by itself, is the
               same length as the current figure's colormap. If no figure exists, MATLAB creates one.
            </td>
            <tr></tr>
            <td width="250px"><a href="hr2quat.html"><tt>hr2quat</tt></a></td>
            <td>arbitrary quaternion q with q * h = r</td>
            <tr></tr>
            <td width="250px"><a href="hsl2hsv.html"><tt>hsl2hsv</tt></a></td>
            <td>hsl2hsv is a function. [h, s, v] = hsl2hsv(hh, ss, ll)</td>
            <tr></tr>
            <td width="250px"><a href="hsvColorMap.html"><tt>hsvColorMap</tt></a></td>
            <td>HSV    Hue-saturation-value color map HSV(M) returns an M-by-3 matrix containing an HSV colormap. HSV, by itself, is the same
               length as the current figure's colormap. If no figure exists, MATLAB creates one.
            </td>
            <tr></tr>
            <td width="250px"><a href="HSVDirectionKey.html"><tt>HSVDirectionKey</tt></a></td>
            <td>converts crystal or specimen directions to rgb values</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.hull.html"><tt>hull</tt></a><span>   (grain2d)</span></td>
            <td>replace grains by its convex hull</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>I<a name="9"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="EBSD.id2ind.html"><tt>id2ind</tt></a><span>   (EBSD)</span></td>
            <td>find ind such that ebsd.id(ind) == id</td>
            <tr></tr>
            <td width="250px"><a href="import_wizard.html"><tt>import_wizard</tt></a></td>
            <td>import_wizard is a function. import_wizard(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="ind2char.html"><tt>ind2char</tt></a></td>
            <td>calculates coordinate from one index i - index s - size of matrix</td>
            <tr></tr>
            <td width="250px"><a href="infernoColorMap.html"><tt>infernoColorMap</tt></a></td>
            <td>infernoColorMap is a function. varargout = infernoColorMap(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="infimalConvolutionFilter.html"><tt>infimalConvolutionFilter</tt></a></td>
            <td>matrix-valued image with the TV-norm. \argmin_u{\|u-u_0\|_2^2 + \lambda \|\nabla u\|_{2,1} + \mu \|H u\|_{2,1}}, \lambda,\mu
               &gt; 0 Written by Johannes Persch, Ronny Bergmann, 09.06.2015 function ma_val_im_reg_2nd_ord minimzes the second order model
               of a OUTPUT: u_hat:       computed minimizer diff:        differences of u and v between two successive iterations
            </td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.init.html"><tt>init</tt></a><span>   (MLSSolver)</span></td>
            <td>extract pole figures</td>
            <tr></tr>
            <td width="250px"><a href="zeroRangeMethod.init.html"><tt>init</tt></a><span>   (zeroRangeMethod)</span></td>
            <td>zeroRangeMethod/init is a function. init(zrm, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.initIter.html"><tt>initIter</tt></a><span>   (MLSSolver)</span></td>
            <td>maybe no starting vector of coefficients has been specified</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.inpolygon.html"><tt>inpolygon</tt></a><span>   (EBSD)</span></td>
            <td>checks which ebsd data are within given polygon</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.inpolygon.html"><tt>inpolygon</tt></a><span>   (grain2d)</span></td>
            <td>checks which grains are within given polygon</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.inpolygon.html"><tt>inpolygon</tt></a><span>   (grainBoundary)</span></td>
            <td>checks which gb data are within given polygon</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.interp.html"><tt>interp</tt></a><span>   (vector3d)</span></td>
            <td>spherical interpolation - including some smoothing</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.intersect.html"><tt>intersect</tt></a><span>   (grainBoundary)</span></td>
            <td>length of a boundary segment</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.inv.html"><tt>inv</tt></a><span>   (complianceTensor)</span></td>
            <td>compliance to stiffness tensor</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.inv.html"><tt>inv</tt></a><span>   (stiffnessTensor)</span></td>
            <td>stiffness to compliance tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.inv.html"><tt>inv</tt></a><span>   (tensor)</span></td>
            <td>inverse of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.inv.html"><tt>inv</tt></a><span>   (quaternion)</span></td>
            <td>quaternion of the inverse roation</td>
            <tr></tr>
            <td width="250px"><a href="ipfColorKey.html"><tt>ipfColorKey</tt></a></td>
            <td>defines an orientation mapping based on a certain inverse pole figure Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="ipfHKLKey.html"><tt>ipfHKLKey</tt></a></td>
            <td>defines an orientation mapping based on a certain inverse pole figure Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="ipfHSVKey.html"><tt>ipfHSVKey</tt></a></td>
            <td>defines an orientation mapping based on a certain inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="ipfSections.html"><tt>ipfSections</tt></a></td>
            <td>ipfSections is a class. oS = ipfSections(CS1, CS2, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="ipfSpotKey.html"><tt>ipfSpotKey</tt></a></td>
            <td>Maps an individual color to each given crystal directions being  parallel to a specimen direction (fibre) Properties: center
                - list of crystal directions @Miller color   - n-by-3 list representing RGB values, one for each center psi     - @kernel
               providing the width and brightness for colored fibre inversePoleFigureDirection - specimen direction @vector3d
            </td>
            <tr></tr>
            <td width="250px"><a href="ipfTSLKey.html"><tt>ipfTSLKey</tt></a></td>
            <td>orientation mapping as it is used by TSL and HKL software</td>
            <tr></tr>
            <td width="250px"><a href="isappr.html"><tt>isappr</tt></a></td>
            <td>check double == double</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.isempty.html"><tt>isempty</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.isempty.html"><tt>isempty</tt></a><span>   (PoleFigure)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.isempty.html"><tt>isempty</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="fibre.isempty.html"><tt>isempty</tt></a><span>   (fibre)</span></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.isempty.html"><tt>isempty</tt></a><span>   (quaternion)</span></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.isempty.html"><tt>isempty</tt></a><span>   (slipSystem)</span></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.isempty.html"><tt>isempty</tt></a><span>   (vector3d)</span></td>
            <td>overloads isempty</td>
            <tr></tr>
            <td width="250px"><a href="isempty_cell.html"><tt>isempty_cell</tt></a></td>
            <td>isempty for cells</td>
            <tr></tr>
            <td width="250px"><a href="iseven.html"><tt>iseven</tt></a></td>
            <td>check double mod 2 == 0</td>
            <tr></tr>
            <td width="250px"><a href="ODF.isFourier.html"><tt>isFourier</tt></a><span>   (ODF)</span></td>
            <td>check whether odf is given by Fourier coefficients</td>
            <tr></tr>
            <td width="250px"><a href="rotation.isImproper.html"><tt>isImproper</tt></a><span>   (rotation)</span></td>
            <td>rotation/isImproper is a function. out = isImproper(r)</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.isLower.html"><tt>isLower</tt></a><span>   (sphericalRegion)</span></td>
            <td>sphericalRegion/isLower is a function. out = isLower(sR)</td>
            <tr></tr>
            <td width="250px"><a href="orientation.isMisorientation.html"><tt>isMisorientation</tt></a><span>   (orientation)</span></td>
            <td>check whether o is a misorientation</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.isnan.html"><tt>isnan</tt></a><span>   (quaternion)</span></td>
            <td>check for nan values</td>
            <tr></tr>
            <td width="250px"><a href="isnull.html"><tt>isnull</tt></a></td>
            <td>ckeck double == 0</td>
            <tr></tr>
            <td width="250px"><a href="isOctave.html"><tt>isOctave</tt></a></td>
            <td>isOctave is a function. result = isOctave</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.isOutlier.html"><tt>isOutlier</tt></a><span>   (PoleFigure)</span></td>
            <td>find outliers in pole figures</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.isPerp.html"><tt>isPerp</tt></a><span>   (vector3d)</span></td>
            <td>check whether v1 and v2 are orthogonal</td>
            <tr></tr>
            <td width="250px"><a href="ispos.html"><tt>ispos</tt></a></td>
            <td>check double &gt; 0</td>
            <tr></tr>
            <td width="250px"><a href="isRGB.html"><tt>isRGB</tt></a></td>
            <td>isRGB is a function. out = isRGB(fig)</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.isTwinning.html"><tt>isTwinning</tt></a><span>   (grainBoundary)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.isUpper.html"><tt>isUpper</tt></a><span>   (sphericalRegion)</span></td>
            <td>sphericalRegion/isUpper is a function. out = isUpper(sR)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>K<a name="10"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="kernel.K_symmetrised.html"><tt>K_symmetrised</tt></a><span>   (kernel)</span></td>
            <td>evaluate kernel modulo symmetries</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.KAM.html"><tt>KAM</tt></a><span>   (EBSD)</span></td>
            <td>intragranular average misorientation angle per orientation</td>
            <tr></tr>
            <td width="250px"><a href="kde.html"><tt>kde</tt></a></td>
            <td>Reliable and extremely fast kernel density estimator for one-dimensional data; Gaussian kernel is assumed and the bandwidth
               is chosen automatically; Unlike many other implementations, this one is immune to problems caused by multimodal densities
               with widely separated modes (see example). The estimation does not deteriorate for multimodal densities, because we never
               assume a parametric model for the data. INPUTS: data    - a vector of data from which the density estimate is constructed;
               n  - the number of mesh points used in the uniform discretization of the interval [MIN, MAX]; n has to be a power of two;
               if n is not a power of two, then n is rounded up to the next power of two, i.e., n is set to n=2^ceil(log2(n)); the default
               value of n is n=2^12; MIN, MAX  - defines the interval [MIN,MAX] on which the density estimate is constructed; the default
               values of MIN and MAX are: MIN=min(data)-Range/10 and MAX=max(data)+Range/10, where Range=max(data)-min(data); OUTPUTS: bandwidth
               - the optimal bandwidth (Gaussian kernel assumed); density - column vector of length 'n' with the values of the density estimate
               at the grid points; xmesh   - the grid over which the density estimate is computed; - If no output is requested, then the
               code automatically plots a graph of the density estimate. cdf  - column vector of length 'n' with the values of the cdf Reference:
               Kernel density estimation via diffusion Z. I. Botev, J. F. Grotowski, and D. P. Kroese (2010) Annals of Statistics, Volume
               38, Number 5, pages 2916-2957.
            </td>
            <tr></tr>
            <td width="250px"><a href="kernel.kernel.html"><tt>kernel</tt></a><span>   (kernel)</span></td>
            <td>kernel is a class. psi = kernel(A)</td>
            <tr></tr>
            <td width="250px"><a href="orientation.KLCV.html"><tt>KLCV</tt></a><span>   (orientation)</span></td>
            <td>Kullback Leibler cross validation for optimal kernel estimation</td>
            <tr></tr>
            <td width="250px"><a href="kmeans.html"><tt>kmeans</tt></a></td>
            <td>k-means++: The Advantages of Careful Seeding", by David Arthur and  Sergei Vassilvitskii, SODA 2007.</td>
            <tr></tr>
            <td width="250px"><a href="KuwaharaFilter.html"><tt>KuwaharaFilter</tt></a></td>
            <td>KuwaharaFilter is a class. F = KuwaharaFilter(varargin)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>L<a name="11"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="l1TVFilter.l1TVFilter.html"><tt>l1TVFilter</tt></a><span>   (l1TVFilter)</span></td>
            <td>smoothes quaternions by projecting them into tangential space and performing there smoothing spline approximation</td>
            <tr></tr>
            <td width="250px"><a href="LaboTeXColorMap.html"><tt>LaboTeXColorMap</tt></a></td>
            <td>return LaboTeX colormap</td>
            <tr></tr>
            <td width="250px"><a href="LaplaceKernel.html"><tt>LaplaceKernel</tt></a></td>
            <td>extract bandwidth</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.Laue.html"><tt>Laue</tt></a><span>   (symmetry)</span></td>
            <td>return the corresponding Laue group</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.LaueName.html"><tt>LaueName</tt></a><span>   (symmetry)</span></td>
            <td>get Laue name</td>
            <tr></tr>
            <td width="250px"><a href="orientation.ldivide.html"><tt>ldivide</tt></a><span>   (orientation)</span></td>
            <td>o .\ v</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.le.html"><tt>le</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads sF1 &lt;= sF2</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.le.html"><tt>le</tt></a><span>   (S2FunTri)</span></td>
            <td>overloads sF1 &lt;= sF2</td>
            <tr></tr>
            <td width="250px"><a href="legendre0.html"><tt>legendre0</tt></a></td>
            <td>Legendrepolynome bis zur Odnung N und gibt sie als Matrix zur&#65533;ck erste Dimension -&gt; Ordnung zweite Dimension -&gt; x</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.length.html"><tt>length</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="tensor.length.html"><tt>length</tt></a><span>   (tensor)</span></td>
            <td>returns the number of tensors</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.length.html"><tt>length</tt></a><span>   (crystalShape)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.length.html"><tt>length</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="fibre.length.html"><tt>length</tt></a><span>   (fibre)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.length.html"><tt>length</tt></a><span>   (quaternion)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.length.html"><tt>length</tt></a><span>   (slipSystem)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.length.html"><tt>length</tt></a><span>   (symmetry)</span></td>
            <td>number of symmetry elements</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.length.html"><tt>length</tt></a><span>   (vector3d)</span></td>
            <td>overloads length</td>
            <tr></tr>
            <td width="250px"><a href="rotation.line.html"><tt>line</tt></a><span>   (rotation)</span></td>
            <td>draw rotations connected by lines</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.line.html"><tt>line</tt></a><span>   (vector3d)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.linearCompressibility.html"><tt>linearCompressibility</tt></a><span>   (complianceTensor)</span></td>
            <td>computes the linear compressibility of an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.linearCompressibility.html"><tt>linearCompressibility</tt></a><span>   (stiffnessTensor)</span></td>
            <td>computes the linear compressibility of an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="load_generic.html"><tt>load_generic</tt></a></td>
            <td>load file using import data and txt2mat</td>
            <tr></tr>
            <td width="250px"><a href="loadallspectra.html"><tt>loadallspectra</tt></a></td>
            <td>load all spectra files of a Dubna meassurement cycle</td>
            <tr></tr>
            <td width="250px"><a href="loadCIF.html"><tt>loadCIF</tt></a></td>
            <td>import crystal symmetry from cif file</td>
            <tr></tr>
            <td width="250px"><a href="loadData.html"><tt>loadData</tt></a></td>
            <td>import PoleFigure, EBSD, and ODF data</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD.html"><tt>loadEBSD</tt></a></td>
            <td>import ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_ACOM.html"><tt>loadEBSD_ACOM</tt></a></td>
            <td>read ACOM files (converted from *.res ASTAR)</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_ang.html"><tt>loadEBSD_ang</tt></a></td>
            <td>read TSL *.ang file</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_brukertxt.html"><tt>loadEBSD_brukertxt</tt></a></td>
            <td>read Bruker *.txt file</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_crc.html"><tt>loadEBSD_crc</tt></a></td>
            <td>interface for Oxford Chanel 5 crc and cpr EBSD data files</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_csv.html"><tt>loadEBSD_csv</tt></a></td>
            <td>loadEBSD_csv is a function. ebsd = loadEBSD_csv(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_ctf.html"><tt>loadEBSD_ctf</tt></a></td>
            <td>read HKL *.ctf file</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_dream3d.html"><tt>loadEBSD_dream3d</tt></a></td>
            <td>loadEBSD_dream3d is a function. ebsd = loadEBSD_dream3d(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_ebsdimage.html"><tt>loadEBSD_ebsdimage</tt></a></td>
            <td>Check extension</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_generic.html"><tt>loadEBSD_generic</tt></a></td>
            <td>load ebsd data from generic text files</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_h5.html"><tt>loadEBSD_h5</tt></a></td>
            <td>loadEBSD_h5 is a function. [ebsd, header] = loadEBSD_h5(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_hdf5.html"><tt>loadEBSD_hdf5</tt></a></td>
            <td>Read rotations</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_osc.html"><tt>loadEBSD_osc</tt></a></td>
            <td>loadEBSD_osc is a function. ebsd = loadEBSD_osc(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_Oxfordcsv.html"><tt>loadEBSD_Oxfordcsv</tt></a></td>
            <td>loadEBSD_Oxfordcsv is a function. ebsd = loadEBSD_Oxfordcsv(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadEBSD_sor.html"><tt>loadEBSD_sor</tt></a></td>
            <td>load LaboTex *.sor file</td>
            <tr></tr>
            <td width="250px"><a href="loadGrainSet_hdf5.html"><tt>loadGrainSet_hdf5</tt></a></td>
            <td>Read EBSD</td>
            <tr></tr>
            <td width="250px"><a href="loadHelper.html"><tt>loadHelper</tt></a></td>
            <td>helps to load data-matrix with ColumnNames restricts also data according to conventions (e.g. &gt;4pi)</td>
            <tr></tr>
            <td width="250px"><a href="loadODF.html"><tt>loadODF</tt></a></td>
            <td>import ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="loadODF_generic.html"><tt>loadODF_generic</tt></a></td>
            <td>load pole figure data from (alpha,beta,gamma) files</td>
            <tr></tr>
            <td width="250px"><a href="loadODF_VPSC.html"><tt>loadODF_VPSC</tt></a></td>
            <td>loadODF_VPSC is a function. [odf, options] = loadODF_VPSC(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadOrientation.html"><tt>loadOrientation</tt></a></td>
            <td>import orientation data from data files</td>
            <tr></tr>
            <td width="250px"><a href="loadOrientation_DRex.html"><tt>loadOrientation_DRex</tt></a></td>
            <td>loadOrientation_DRex is a function. ori = loadOrientation_DRex(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadOrientation_generic.html"><tt>loadOrientation_generic</tt></a></td>
            <td>load Orientation data from generic text files</td>
            <tr></tr>
            <td width="250px"><a href="loadOrientation_generic2.html"><tt>loadOrientation_generic2</tt></a></td>
            <td>load Orientation data from generic text files</td>
            <tr></tr>
            <td width="250px"><a href="loadPHL.html"><tt>loadPHL</tt></a></td>
            <td>loadPHL is a function. cs = loadPHL(fname)</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure.html"><tt>loadPoleFigure</tt></a></td>
            <td>import pole figure data</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_aachen.html"><tt>loadPoleFigure_aachen</tt></a></td>
            <td>import data fom aachen ptx file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_aachen_exp.html"><tt>loadPoleFigure_aachen_exp</tt></a></td>
            <td>import data fom aachen_exp file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_ana.html"><tt>loadPoleFigure_ana</tt></a></td>
            <td>import data fom ana file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_beartex.html"><tt>loadPoleFigure_beartex</tt></a></td>
            <td>import data fom BeaTex file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_dubna.html"><tt>loadPoleFigure_dubna</tt></a></td>
            <td>load dubna cnv file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_geesthacht.html"><tt>loadPoleFigure_geesthacht</tt></a></td>
            <td>load ptx file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_generic.html"><tt>loadPoleFigure_generic</tt></a></td>
            <td>load pole figure data from (theta,rho,intensity) files</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_gpol.html"><tt>loadPoleFigure_gpol</tt></a></td>
            <td>loadPoleFigure_gpol is a function. pf = loadPoleFigure_gpol(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_ibm.html"><tt>loadPoleFigure_ibm</tt></a></td>
            <td>import data fom ibm file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_juelich.html"><tt>loadPoleFigure_juelich</tt></a></td>
            <td>load juelich data format</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_labotex.html"><tt>loadPoleFigure_labotex</tt></a></td>
            <td>load labotex pole figure data</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_nja.html"><tt>loadPoleFigure_nja</tt></a></td>
            <td>loadPoleFigure_nja is a function. pf = loadPoleFigure_nja(fname, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_out1.html"><tt>loadPoleFigure_out1</tt></a></td>
            <td>import polfigure-data form Graz</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_philips.html"><tt>loadPoleFigure_philips</tt></a></td>
            <td>load philips *.txt file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_plf.html"><tt>loadPoleFigure_plf</tt></a></td>
            <td>load plf file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_popla.html"><tt>loadPoleFigure_popla</tt></a></td>
            <td>import data fom Popla file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_pwd.html"><tt>loadPoleFigure_pwd</tt></a></td>
            <td>load D5000 powder data file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rigaku.html"><tt>loadPoleFigure_rigaku</tt></a></td>
            <td>import data fom Rigaku SamrtLab txt file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rigaku_dat.html"><tt>loadPoleFigure_rigaku_dat</tt></a></td>
            <td>load *.dat files of rigaku devices</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rigaku_txt.html"><tt>loadPoleFigure_rigaku_txt</tt></a></td>
            <td>import data fom ana file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rigaku_txt2.html"><tt>loadPoleFigure_rigaku_txt2</tt></a></td>
            <td>import data fom ana file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_rw1.html"><tt>loadPoleFigure_rw1</tt></a></td>
            <td>import data from Philip's Xpert binary file format rw1</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_scintag.html"><tt>loadPoleFigure_scintag</tt></a></td>
            <td>import data fom scintag ascii file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_siemens.html"><tt>loadPoleFigure_siemens</tt></a></td>
            <td>load D5000 data file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_slc.html"><tt>loadPoleFigure_slc</tt></a></td>
            <td>load *.txt file with regular grid</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_uxd.html"><tt>loadPoleFigure_uxd</tt></a></td>
            <td>import data fom ana file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_xrd.html"><tt>loadPoleFigure_xrd</tt></a></td>
            <td>import data fom aachen xrd file</td>
            <tr></tr>
            <td width="250px"><a href="loadPoleFigure_xrdml.html"><tt>loadPoleFigure_xrdml</tt></a></td>
            <td>load xrdMeasurement (xrdml) file</td>
            <tr></tr>
            <td width="250px"><a href="loadspectra.html"><tt>loadspectra</tt></a></td>
            <td>load a single spectrum o a Dubna meassurement</td>
            <tr></tr>
            <td width="250px"><a href="loadTensor.html"><tt>loadTensor</tt></a></td>
            <td>import Tensor data</td>
            <tr></tr>
            <td width="250px"><a href="loadTensor_generic.html"><tt>loadTensor_generic</tt></a></td>
            <td>load a Tensor from a file</td>
            <tr></tr>
            <td width="250px"><a href="loadTensor_mpod.html"><tt>loadTensor_mpod</tt></a></td>
            <td>import Tensor data</td>
            <tr></tr>
            <td width="250px"><a href="loadTensor_P.html"><tt>loadTensor_P</tt></a></td>
            <td>load a Tensor from a file</td>
            <tr></tr>
            <td width="250px"><a href="loadVector3d.html"><tt>loadVector3d</tt></a></td>
            <td>import ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="loadVector3d_generic.html"><tt>loadVector3d_generic</tt></a></td>
            <td>load pole figure data from (alpha,beta,gamma) files</td>
            <tr></tr>
            <td width="250px"><a href="localOrientationGrid.html"><tt>localOrientationGrid</tt></a></td>
            <td>define a equispaced grid localized to a center orientation</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.log.html"><tt>log</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>log of a function</td>
            <tr></tr>
            <td width="250px"><a href="orientation.log.html"><tt>log</tt></a><span>   (orientation)</span></td>
            <td>the misorientation vector between two orientations</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.log.html"><tt>log</tt></a><span>   (quaternion)</span></td>
            <td>the logarithmic map that translates a rotation into a rotation vector</td>
            <tr></tr>
            <td width="250px"><a href="tensor.logm.html"><tt>logm</tt></a><span>   (tensor)</span></td>
            <td>matrix logarithm of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="orientation.logm.html"><tt>logm</tt></a><span>   (orientation)</span></td>
            <td>the logarithmic map that translates a rotation into a spin tensor</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.logm.html"><tt>logm</tt></a><span>   (quaternion)</span></td>
            <td>the logarithmic map that translates a rotation into a spin tensor</td>
            <tr></tr>
            <td width="250px"><a href="orientation.LSCV.html"><tt>LSCV</tt></a><span>   (orientation)</span></td>
            <td>least squares cross valiadation</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>M<a name="12"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="magmaColorMap.html"><tt>magmaColorMap</tt></a></td>
            <td>magmaColorMap is a function. varargout = magmaColorMap(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="makeS2FunDoc.html"><tt>makeS2FunDoc</tt></a></td>
            <td>makeS2FunDoc is a function.</td>
            <tr></tr>
            <td width="250px"><a href="orientation.map.html"><tt>map</tt></a><span>   (orientation)</span></td>
            <td>define orientations by pairs of vectors</td>
            <tr></tr>
            <td width="250px"><a href="rotation.map.html"><tt>map</tt></a><span>   (rotation)</span></td>
            <td>define rotations by pairs of vectors</td>
            <tr></tr>
            <td width="250px"><a href="mapPlot.html"><tt>mapPlot</tt></a></td>
            <td>class to handle spatial plots of EBSD data and grains</td>
            <tr></tr>
            <td width="250px"><a href="mat2quat.html"><tt>mat2quat</tt></a></td>
            <td>converts direction cosine matrix to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="tensor.matrix.html"><tt>matrix</tt></a><span>   (tensor)</span></td>
            <td>return tensor as a matrix</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.matrix.html"><tt>matrix</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to direction cosine matrix conversion converts direction cosine matrix to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="rotation.matrix.html"><tt>matrix</tt></a><span>   (rotation)</span></td>
            <td>quaternion to direction cosine matrix conversion converts direction cosine matrix to quaternion</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.max.html"><tt>max</tt></a><span>   (S2Fun)</span></td>
            <td>global, local and pointwise maxima of spherical functions</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.max.html"><tt>max</tt></a><span>   (S2FunTri)</span></td>
            <td>MAX    Maximum elements of an array. M = MAX(X) is the largest element in the vector X. If X is a matrix, M  is a row vector
               containing the maximum element from each column. For  N-D arrays, MAX(X) operates along the first non-singleton dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="ODF.max.html"><tt>max</tt></a><span>   (ODF)</span></td>
            <td>heuristic to find local modal orientations</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.max.html"><tt>max</tt></a><span>   (PoleFigure)</span></td>
            <td>maximum of two pole figures or the maximum of a single polefigure</td>
            <tr></tr>
            <td width="250px"><a href="tensor.max.html"><tt>max</tt></a><span>   (tensor)</span></td>
            <td>MAX    Maximum elements of an array. M = MAX(X) is the largest element in the vector X. If X is a matrix, M  is a row vector
               containing the maximum element from each column. For  N-D arrays, MAX(X) operates along the first non-singleton dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.max.html"><tt>max</tt></a><span>   (S1Grid)</span></td>
            <td>return maximum value</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.maxAngle.html"><tt>maxAngle</tt></a><span>   (orientationRegion)</span></td>
            <td>get the maximum angle of the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.maxAngle.html"><tt>maxAngle</tt></a><span>   (symmetry)</span></td>
            <td>get the maximum angle of the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.mean.html"><tt>mean</tt></a><span>   (S2Fun)</span></td>
            <td>calculates the mean value for an univariate S2Fun or calculates the mean along a specified dimension fo a multimodal S2Fun</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.mean.html"><tt>mean</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>calculates the mean value for an univariate S2Fun or calculates the mean along a specified dimension fo a multimodal S2Fun</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.mean.html"><tt>mean</tt></a><span>   (S2FunTri)</span></td>
            <td>mean value of a spherical function</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.mean.html"><tt>mean</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>syntax f = mean(sVF)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mean.html"><tt>mean</tt></a><span>   (ODF)</span></td>
            <td>expected value of an ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mean.html"><tt>mean</tt></a><span>   (PoleFigure)</span></td>
            <td>mean of pole figure intensities</td>
            <tr></tr>
            <td width="250px"><a href="tensor.mean.html"><tt>mean</tt></a><span>   (tensor)</span></td>
            <td>mean of a list of tensors</td>
            <tr></tr>
            <td width="250px"><a href="orientation.mean.html"><tt>mean</tt></a><span>   (orientation)</span></td>
            <td>mean of a list of orientations, principle axes and moments of inertia</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mean.html"><tt>mean</tt></a><span>   (quaternion)</span></td>
            <td>mean of a list of quaternions, principle axes and moments of inertia</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.mean.html"><tt>mean</tt></a><span>   (vector3d)</span></td>
            <td>computes the mean vector</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mean_CS.html"><tt>mean_CS</tt></a><span>   (quaternion)</span></td>
            <td>fast mean of</td>
            <tr></tr>
            <td width="250px"><a href="meanFilter.html"><tt>meanFilter</tt></a></td>
            <td>implements a convolution filter for quaternion</td>
            <tr></tr>
            <td width="250px"><a href="stressTensor.meanStress.html"><tt>meanStress</tt></a><span>   (stressTensor)</span></td>
            <td>mean stress</td>
            <tr></tr>
            <td width="250px"><a href="medianFilter.html"><tt>medianFilter</tt></a></td>
            <td>medianFilter is a class. F = medianFilter(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.merge.html"><tt>merge</tt></a><span>   (grain2d)</span></td>
            <td>merge grains along special grain boundaries</td>
            <tr></tr>
            <td width="250px"><a href="mhyper.html"><tt>mhyper</tt></a></td>
            <td>multivariat hypergeometric function 1F1(1/2,p/2, kappa)</td>
            <tr></tr>
            <td width="250px"><a href="Miller.Miller.html"><tt>Miller</tt></a><span>   (Miller)</span></td>
            <td>define a crystal direction by Miller indice</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.min.html"><tt>min</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>global, local and pointwise minima of spherical functions</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.min.html"><tt>min</tt></a><span>   (S2FunTri)</span></td>
            <td>MIN    Minimum elements of an array. M = MIN(X) is the smallest element in the vector X. If X is a matrix, M is a row vector
               containing the minimum element from each column. For  N-D arrays, MIN(X) operates along the first non-singleton dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.min.html"><tt>min</tt></a><span>   (PoleFigure)</span></td>
            <td>minimum of two pole figures or the minimum of a single polefigure</td>
            <tr></tr>
            <td width="250px"><a href="tensor.min.html"><tt>min</tt></a><span>   (tensor)</span></td>
            <td>MIN    Minimum elements of an array. M = MIN(X) is the smallest element in the vector X. If X is a matrix, M is a row vector
               containing the minimum element from each column. For  N-D arrays, MIN(X) operates along the first non-singleton dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.min.html"><tt>min</tt></a><span>   (S1Grid)</span></td>
            <td>return maximum value</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.minAngle.html"><tt>minAngle</tt></a><span>   (orientationRegion)</span></td>
            <td>get the minimum angle of the boundary of the fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.minus.html"><tt>minus</tt></a><span>   (S2Fun)</span></td>
            <td>overload minus</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.minus.html"><tt>minus</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>Syntax sVF = sVF1-sVF2 sVF = a-sVF1 sVF = sVF1-a</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.minus.html"><tt>minus</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>Syntax sVF = sVF1 - sVF2 sVF = sVF - v</td>
            <tr></tr>
            <td width="250px"><a href="ODF.minus.html"><tt>minus</tt></a><span>   (ODF)</span></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.minus.html"><tt>minus</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 - pf2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.minus.html"><tt>minus</tt></a><span>   (tensor)</span></td>
            <td>T1 - T2;</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.minus.html"><tt>minus</tt></a><span>   (S1Grid)</span></td>
            <td>-   Minus.  X - Y subtracts matrix Y from X. X and Y must have compatible sizes. In the simplest cases, they can be the same
               size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension sizes of the inputs are
               either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.minus.html"><tt>minus</tt></a><span>   (quaternion)</span></td>
            <td>overloads minus</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.minus.html"><tt>minus</tt></a><span>   (vector3d)</span></td>
            <td>overload minus</td>
            <tr></tr>
            <td width="250px"><a href="mix2.html"><tt>mix2</tt></a></td>
            <td>mix2 sample ODF</td>
            <tr></tr>
            <td width="250px"><a href="orientation.mldivide.html"><tt>mldivide</tt></a><span>   (orientation)</span></td>
            <td>o \ v</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mldivide.html"><tt>mldivide</tt></a><span>   (quaternion)</span></td>
            <td>\   Backslash or left matrix divide. A\B is the matrix division of A into B, which is roughly the same as INV(A)*B , except
               it is computed in a different way. If A is an N-by-N matrix and B is a column vector with N components, or a matrix with several
               such columns, then X = A\B is the solution to the equation A*X = B. A warning  message is printed if A is badly scaled or
               nearly singular. A\EYE(SIZE(A)) produces the inverse of A.
            </td>
            <tr></tr>
            <td width="250px"><a href="rotation.mldivide.html"><tt>mldivide</tt></a><span>   (rotation)</span></td>
            <td>o \ v</td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.MLSSolver.html"><tt>MLSSolver</tt></a><span>   (MLSSolver)</span></td>
            <td>modified least squares solver</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mpower.html"><tt>mpower</tt></a><span>   (quaternion)</span></td>
            <td>q^n</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.mpower.html"><tt>mpower</tt></a><span>   (vector3d)</span></td>
            <td>n-th dyadic product</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.mPrime.html"><tt>mPrime</tt></a><span>   (slipSystem)</span></td>
            <td>m' parameter from Luster and Morris in 1995</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mrdivide.html"><tt>mrdivide</tt></a><span>   (ODF)</span></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mrdivide.html"><tt>mrdivide</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 ./ b and a ./ pf2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.mrdivide.html"><tt>mrdivide</tt></a><span>   (tensor)</span></td>
            <td>implements T / S</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mrdivide.html"><tt>mrdivide</tt></a><span>   (quaternion)</span></td>
            <td>scalar division</td>
            <tr></tr>
            <td width="250px"><a href="mtex_assert.html"><tt>mtex_assert</tt></a></td>
            <td>mtex_assert is a function. mtex_assert(cond, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="mtex_path.html"><tt>mtex_path</tt></a></td>
            <td>return install dir of mtex</td>
            <tr></tr>
            <td width="250px"><a href="mtexCifPath.html"><tt>mtexCifPath</tt></a></td>
            <td>returns the default path to crystallographic information files (CIF)</td>
            <tr></tr>
            <td width="250px"><a href="mtexColorbar.html"><tt>mtexColorbar</tt></a></td>
            <td>overide buildin Matlab colorbar function</td>
            <tr></tr>
            <td width="250px"><a href="mtexColorMap.html"><tt>mtexColorMap</tt></a></td>
            <td>define an MTEX colormap</td>
            <tr></tr>
            <td width="250px"><a href="mtexdata.html"><tt>mtexdata</tt></a></td>
            <td>load of data provided with mtex and often used in documentation</td>
            <tr></tr>
            <td width="250px"><a href="mtexDataPath.html"><tt>mtexDataPath</tt></a></td>
            <td>returns the default path to mtex sample data</td>
            <tr></tr>
            <td width="250px"><a href="mtexdegchar.html"><tt>mtexdegchar</tt></a></td>
            <td>returns the degree character</td>
            <tr></tr>
            <td width="250px"><a href="mtexEBSDPath.html"><tt>mtexEBSDPath</tt></a></td>
            <td>returns the default path to EBSD data files</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.mtexFigure.html"><tt>mtexFigure</tt></a><span>   (mtexFigure)</span></td>
            <td>class to handles figures with equaly sized axes</td>
            <tr></tr>
            <td width="250px"><a href="MTEXmenu.html"><tt>MTEXmenu</tt></a></td>
            <td>show up MTEX menu</td>
            <tr></tr>
            <td width="250px"><a href="mtexODFPath.html"><tt>mtexODFPath</tt></a></td>
            <td>returns the default path to ODF-files</td>
            <tr></tr>
            <td width="250px"><a href="mtexPoleFigurePath.html"><tt>mtexPoleFigurePath</tt></a></td>
            <td>returns the default path to PoleFigure data files</td>
            <tr></tr>
            <td width="250px"><a href="mtexTensorPath.html"><tt>mtexTensorPath</tt></a></td>
            <td>returns the default path to tensor-files</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.mtimes.html"><tt>mtimes</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>Syntax sF = sF1 * sF2 sF = a * sF1 sF = sF1 * a</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.mtimes.html"><tt>mtimes</tt></a><span>   (S2FunTri)</span></td>
            <td>*   Matrix multiply. X*Y is the matrix product of X and Y.  Any scalar (a 1-by-1 matrix) may multiply anything.  Otherwise,
               the number of columns of X must equal the number of rows of Y.
            </td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.mtimes.html"><tt>mtimes</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>Syntax sF = sF1*sF2 sF = a*sF1 sF = sF1*a</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.mtimes.html"><tt>mtimes</tt></a><span>   (EBSD)</span></td>
            <td>rotating the ebsd data by a certain rotation</td>
            <tr></tr>
            <td width="250px"><a href="ODF.mtimes.html"><tt>mtimes</tt></a><span>   (ODF)</span></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.mtimes.html"><tt>mtimes</tt></a><span>   (PoleFigure)</span></td>
            <td>scaling of PoleFigures, implements pf1 * b and a * pf2</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.mtimes.html"><tt>mtimes</tt></a><span>   (complianceTensor)</span></td>
            <td>tensor product S * sigma</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.mtimes.html"><tt>mtimes</tt></a><span>   (stiffnessTensor)</span></td>
            <td>tensor product C * eps</td>
            <tr></tr>
            <td width="250px"><a href="tensor.mtimes.html"><tt>mtimes</tt></a><span>   (tensor)</span></td>
            <td>implements T1 * T2</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.mtimes.html"><tt>mtimes</tt></a><span>   (SO3Grid)</span></td>
            <td>outer quaternion multiplication</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.mtimes.html"><tt>mtimes</tt></a><span>   (crystalShape)</span></td>
            <td>*   Matrix multiply. X*Y is the matrix product of X and Y.  Any scalar (a 1-by-1 matrix) may multiply anything.  Otherwise,
               the number of columns of X must equal the number of rows of Y.
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.mtimes.html"><tt>mtimes</tt></a><span>   (orientation)</span></td>
            <td>orientation times Miller and orientation times orientation</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.mtimes.html"><tt>mtimes</tt></a><span>   (quaternion)</span></td>
            <td>quaternionen multiplication q1 * q2</td>
            <tr></tr>
            <td width="250px"><a href="rotation.mtimes.html"><tt>mtimes</tt></a><span>   (rotation)</span></td>
            <td>r = a * b</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.mtimes.html"><tt>mtimes</tt></a><span>   (vector3d)</span></td>
            <td>scalar multiplication</td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.Mtv.html"><tt>Mtv</tt></a><span>   (MLSSolver)</span></td>
            <td>forward operator</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.multiplicityPerpZ.html"><tt>multiplicityPerpZ</tt></a><span>   (symmetry)</span></td>
            <td>maximum angle rho</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.multiplicityZ.html"><tt>multiplicityZ</tt></a><span>   (symmetry)</span></td>
            <td>maximum angle rho</td>
            <tr></tr>
            <td width="250px"><a href="MLSSolver.Mv.html"><tt>Mv</tt></a><span>   (MLSSolver)</span></td>
            <td>forward operator</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>N<a name="13"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="S2VectorField.n.html"><tt>n</tt></a><span>   (S2VectorField)</span></td>
            <td>Gives the normal vector of the tangential plane in v</td>
            <tr></tr>
            <td width="250px"><a href="n2str.html"><tt>n2str</tt></a></td>
            <td>num2str with exact zero</td>
            <tr></tr>
            <td width="250px"><a href="nadjacent.html"><tt>nadjacent</tt></a></td>
            <td>Returns the adjacency matrix of the n-neighbours.</td>
            <tr></tr>
            <td width="250px"><a href="nanmax.html"><tt>nanmax</tt></a></td>
            <td>FORMAT: [Y,IDX] = NANMAX(A,DIM,[B])</td>
            <tr></tr>
            <td width="250px"><a href="nanmean.html"><tt>nanmean</tt></a></td>
            <td>FORMAT: Y = NANMEAN(X,DIM)</td>
            <tr></tr>
            <td width="250px"><a href="nanmedian.html"><tt>nanmedian</tt></a></td>
            <td>FORMAT: Y = NANMEDIAN(X,DIM)</td>
            <tr></tr>
            <td width="250px"><a href="nanmin.html"><tt>nanmin</tt></a></td>
            <td>FORMAT: [Y,IDX] = NANMIN(A,DIM,[B])</td>
            <tr></tr>
            <td width="250px"><a href="nanplus.html"><tt>nanplus</tt></a></td>
            <td>nanplus is a function. [a, count] = nanplus(a, b, count, alpha)</td>
            <tr></tr>
            <td width="250px"><a href="nansum.html"><tt>nansum</tt></a></td>
            <td>FORMAT: Y = NANSUM(X,DIM)</td>
            <tr></tr>
            <td width="250px"><a href="tensor.ndims.html"><tt>ndims</tt></a><span>   (tensor)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ndims.html"><tt>ndims</tt></a><span>   (quaternion)</span></td>
            <td>overloads ndims</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.ne.html"><tt>ne</tt></a><span>   (grain2d)</span></td>
            <td>~=  Not equal. A ~= B does element by element comparisons between A and B and returns an array with elements set to logical
               1 (TRUE) where the relation is true and elements set to logical 0 (FALSE) where it is not. A and B must have compatible sizes.
               In the simplest cases, they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension,
               the dimension sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.ne.html"><tt>ne</tt></a><span>   (tensor)</span></td>
            <td>checks whether two tensors are not equal</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.ne.html"><tt>ne</tt></a><span>   (dislocationSystem)</span></td>
            <td>? sS1 ~= sS2</td>
            <tr></tr>
            <td width="250px"><a href="fibre.ne.html"><tt>ne</tt></a><span>   (fibre)</span></td>
            <td>? sS1 ~= sS2</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.ne.html"><tt>ne</tt></a><span>   (orientationRegion)</span></td>
            <td>~=  Not equal. A ~= B does element by element comparisons between A and B and returns an array with elements set to logical
               1 (TRUE) where the relation is true and elements set to logical 0 (FALSE) where it is not. A and B must have compatible sizes.
               In the simplest cases, they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension,
               the dimension sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.ne.html"><tt>ne</tt></a><span>   (quaternion)</span></td>
            <td>q1 ~= q2 ?</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.ne.html"><tt>ne</tt></a><span>   (slipSystem)</span></td>
            <td>? sS1 ~= sS2</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.ne.html"><tt>ne</tt></a><span>   (sphericalRegion)</span></td>
            <td>~=  Not equal. A ~= B does element by element comparisons between A and B and returns an array with elements set to logical
               1 (TRUE) where the relation is true and elements set to logical 0 (FALSE) where it is not. A and B must have compatible sizes.
               In the simplest cases, they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension,
               the dimension sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.ne.html"><tt>ne</tt></a><span>   (vector3d)</span></td>
            <td>? v1 == v2</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.neighbors.html"><tt>neighbors</tt></a><span>   (grain2d)</span></td>
            <td>returns the number of neighboring grains</td>
            <tr></tr>
            <td width="250px"><a href="ODF.neuralgas.html"><tt>neuralgas</tt></a><span>   (ODF)</span></td>
            <td>attempt to distribute measure-sites equally according to invers polefigure density (experimental)</td>
            <tr></tr>
            <td width="250px"><a href="newer_version.html"><tt>newer_version</tt></a></td>
            <td>check matlab version</td>
            <tr></tr>
            <td width="250px"><a href="newMapPlot.html"><tt>newMapPlot</tt></a></td>
            <td>newMapPlot is a function. [mP, isNew] = newMapPlot(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="newMtexFigure.html"><tt>newMtexFigure</tt></a></td>
            <td>set uo a new plotting figure</td>
            <tr></tr>
            <td width="250px"><a href="newODFSectionPlot.html"><tt>newODFSectionPlot</tt></a></td>
            <td>generate a new ODF section plot</td>
            <tr></tr>
            <td width="250px"><a href="newOrientationPlot.html"><tt>newOrientationPlot</tt></a></td>
            <td>prepare a 3d orientation plot</td>
            <tr></tr>
            <td width="250px"><a href="newSphericalPlot.html"><tt>newSphericalPlot</tt></a></td>
            <td>split plot in upper and lower hemisphere</td>
            <tr></tr>
            <td width="250px"><a href="mtexFigure.nextAxis.html"><tt>nextAxis</tt></a><span>   (mtexFigure)</span></td>
            <td>go to next plot</td>
            <tr></tr>
            <td width="250px"><a href="nextAxis.html"><tt>nextAxis</tt></a></td>
            <td>nextAxis is a function. ax = nextAxis(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="nextstyle.html"><tt>nextstyle</tt></a></td>
            <td>NEXTSTYLE Get next plot linespec [L,C,M] = NEXTSTYLE(AX) gets the next line style, color and marker for plotting from the
               ColorOrder and LineStyleOrder of axes AX.
            </td>
            <tr></tr>
            <td width="250px"><a href="symmetry.nfold.html"><tt>nfold</tt></a><span>   (symmetry)</span></td>
            <td>maximal n-fold of symmetry axes</td>
            <tr></tr>
            <td width="250px"><a href="orientation.niceEuler.html"><tt>niceEuler</tt></a><span>   (orientation)</span></td>
            <td>orientation to euler angle</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.noisepf.html"><tt>noisepf</tt></a><span>   (PoleFigure)</span></td>
            <td>simulate diffraction counts</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.norm.html"><tt>norm</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>the L2 norm of a spherical function</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.norm.html"><tt>norm</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>pointwise norm of the vectorfield</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.norm.html"><tt>norm</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>pointwise norm of the vectorfield</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.norm.html"><tt>norm</tt></a><span>   (FourierComponent)</span></td>
            <td>caclulate texture index of ODF</td>
            <tr></tr>
            <td width="250px"><a href="ODF.norm.html"><tt>norm</tt></a><span>   (ODF)</span></td>
            <td>caclulate texture index of ODF</td>
            <tr></tr>
            <td width="250px"><a href="tensor.norm.html"><tt>norm</tt></a><span>   (tensor)</span></td>
            <td>tensor frobenius norm</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.norm.html"><tt>norm</tt></a><span>   (quaternion)</span></td>
            <td>quaternion norm sqrt(a^2+b^2+c^2+c^2)</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.norm.html"><tt>norm</tt></a><span>   (vector3d)</span></td>
            <td>vector norm</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.normalDirection.html"><tt>normalDirection</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>normal direction</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorField.normalize.html"><tt>normalize</tt></a><span>   (S2VectorField)</span></td>
            <td>Gives the normal vector of the tangential plane in v</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.normalize.html"><tt>normalize</tt></a><span>   (PoleFigure)</span></td>
            <td>normalization of a meassured pole figure with respect to an ODF</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.normalize.html"><tt>normalize</tt></a><span>   (quaternion)</span></td>
            <td>normalize quaternion</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.normalize.html"><tt>normalize</tt></a><span>   (vector3d)</span></td>
            <td>normalize a vector</td>
            <tr></tr>
            <td width="250px"><a href="tensor.numel.html"><tt>numel</tt></a><span>   (tensor)</span></td>
            <td>returns the number of tensors</td>
            <tr></tr>
            <td width="250px"><a href="NWSE.html"><tt>NWSE</tt></a></td>
            <td>NWSE is a function. out = NWSE(in)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>O<a name="14"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="strainTensor.octahedralStrain.html"><tt>octahedralStrain</tt></a><span>   (strainTensor)</span></td>
            <td>the octahedral strains</td>
            <tr></tr>
            <td width="250px"><a href="ODF.ODF.html"><tt>ODF</tt></a><span>   (ODF)</span></td>
            <td>ODF is a class. odf = ODF(components, weights)</td>
            <tr></tr>
            <td width="250px"><a href="ODFSections.ODFSections.html"><tt>ODFSections</tt></a><span>   (ODFSections)</span></td>
            <td>ODFSECTIONS Summary of this class goes here Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="omegaSections.html"><tt>omegaSections</tt></a></td>
            <td>omegaSections is a class. oS = omegaSections(CS1, CS2, h1, h2, r_ref, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="refractiveIndexTensor.opticalAxis.html"><tt>opticalAxis</tt></a><span>   (refractiveIndexTensor)</span></td>
            <td>optical axis or axes for a refractive index tensor</td>
            <tr></tr>
            <td width="250px"><a href="option2str.html"><tt>option2str</tt></a></td>
            <td>transforms option list to comma separated list</td>
            <tr></tr>
            <td width="250px"><a href="optiondraw.html"><tt>optiondraw</tt></a></td>
            <td>apply options to handle</td>
            <tr></tr>
            <td width="250px"><a href="optionplot.html"><tt>optionplot</tt></a></td>
            <td>plot y against x using the options in varargin</td>
            <tr></tr>
            <td width="250px"><a href="fibre.orientation.html"><tt>orientation</tt></a><span>   (fibre)</span></td>
            <td>generate a list of orientation out of a fibre</td>
            <tr></tr>
            <td width="250px"><a href="orientation.orientation.html"><tt>orientation</tt></a><span>   (orientation)</span></td>
            <td>orientation - class representing orientations</td>
            <tr></tr>
            <td width="250px"><a href="orientationColorKey.html"><tt>orientationColorKey</tt></a></td>
            <td>abstract class for defining (mis)orientation color keys</td>
            <tr></tr>
            <td width="250px"><a href="orientationPlot.html"><tt>orientationPlot</tt></a></td>
            <td>ODFSECTIONS</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.orientationRegion.html"><tt>orientationRegion</tt></a><span>   (orientationRegion)</span></td>
            <td>sphericalRegion implements a region in orientation space The region is bounded by planes normal to quaternions N i.e., all
               quaternions q inside a region satisfy the condition dot(q, N) &lt;= 0 or dot(-q, N) &lt;= 0 for all N
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.orth.html"><tt>orth</tt></a><span>   (vector3d)</span></td>
            <td>an arbitrary orthogonal vector</td>
            <tr></tr>
            <td width="250px"><a href="orthographicProjection.html"><tt>orthographicProjection</tt></a></td>
            <td>orthographic projection</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.orthProj.html"><tt>orthProj</tt></a><span>   (vector3d)</span></td>
            <td>vector3d/orthProj is a function. v = orthProj(v, N)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>P<a name="15"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="orientation.parents.html"><tt>parents</tt></a><span>   (orientation)</span></td>
            <td>variants of an orientation relationship</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.paris.html"><tt>paris</tt></a><span>   (grain2d)</span></td>
            <td>Percentile Average Relative Indented Surface</td>
            <tr></tr>
            <td width="250px"><a href="parseXML.html"><tt>parseXML</tt></a></td>
            <td>PARSEXML Convert XML file to a MATLAB structure.</td>
            <tr></tr>
            <td width="250px"><a href="parulaColorMap.html"><tt>parulaColorMap</tt></a></td>
            <td>PARULA Blue-green-orange-yellow color map PARULA(M) returns an M-by-3 matrix containing a colormap.  The colors begin with
               dark purplish-blue and blue, range through green and orange, and end with bright yellow. PARULA is named after a bird, the
               tropical parula, which has these colors.
            </td>
            <tr></tr>
            <td width="250px"><a href="PatalaColorKey.PatalaColorKey.html"><tt>PatalaColorKey</tt></a><span>   (PatalaColorKey)</span></td>
            <td>converts misorientations to rgb values as described in</td>
            <tr></tr>
            <td width="250px"><a href="pauseline.html"><tt>pauseline</tt></a></td>
            <td>pauseline is a function.</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.pcolor.html"><tt>pcolor</tt></a><span>   (S2Fun)</span></td>
            <td>spherical contour plot</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.pcolor.html"><tt>pcolor</tt></a><span>   (vector3d)</span></td>
            <td>spherical contour plot</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.pdfMatrix.html"><tt>pdfMatrix</tt></a><span>   (femComponent)</span></td>
            <td>called by pdf</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.pdfMatrix.html"><tt>pdfMatrix</tt></a><span>   (DelaunaySO3)</span></td>
            <td>called by pdf</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.perimeter.html"><tt>perimeter</tt></a><span>   (grain2d)</span></td>
            <td>calculates the perimeter of a grain without or without inclusions</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.perimeter.html"><tt>perimeter</tt></a><span>   (grainBoundary)</span></td>
            <td>boundary length per grain including holes</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.permute.html"><tt>permute</tt></a><span>   (quaternion)</span></td>
            <td>overloads permute</td>
            <tr></tr>
            <td width="250px"><a href="rotation.permute.html"><tt>permute</tt></a><span>   (rotation)</span></td>
            <td>overloads permute</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.perp.html"><tt>perp</tt></a><span>   (vector3d)</span></td>
            <td>conmpute an vector best orthogonal to a list of directions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.perturbe.html"><tt>perturbe</tt></a><span>   (quaternion)</span></td>
            <td>pertube data randomly by epsilon</td>
            <tr></tr>
            <td width="250px"><a href="pf2odfSolver.html"><tt>pf2odfSolver</tt></a></td>
            <td>pf2odfSolver is a class. obj = pf2odfSolver(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="pfSections.html"><tt>pfSections</tt></a></td>
            <td>pfSections is a class. oS = pfSections(CS1, CS2, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="phaseList.html"><tt>phaseList</tt></a></td>
            <td>handles a list of phases</td>
            <tr></tr>
            <td width="250px"><a href="phi1Sections.html"><tt>phi1Sections</tt></a></td>
            <td>phi1 sections for ODF and orientation plotting</td>
            <tr></tr>
            <td width="250px"><a href="phi2Sections.html"><tt>phi2Sections</tt></a></td>
            <td>phi2 sections for ODF and orientation plotting</td>
            <tr></tr>
            <td width="250px"><a href="PhiSections.html"><tt>PhiSections</tt></a></td>
            <td>PhiSections is a class. oS = PhiSections(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="plainProjection.html"><tt>plainProjection</tt></a></td>
            <td>sphericalProjection</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.planeIntersect.html"><tt>planeIntersect</tt></a><span>   (vector3d)</span></td>
            <td>pointwise determinant or triple product of three vector3d</td>
            <tr></tr>
            <td width="250px"><a href="plasmaColorMap.html"><tt>plasmaColorMap</tt></a></td>
            <td>plasmaColorMap is a function. varargout = plasmaColorMap(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisField.plot.html"><tt>plot</tt></a><span>   (S2AxisField)</span></td>
            <td>plot spherical axis field</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.plot.html"><tt>plot</tt></a><span>   (S2Fun)</span></td>
            <td>plot spherical Function</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.plot.html"><tt>plot</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.plot.html"><tt>plot</tt></a><span>   (S2FunTri)</span></td>
            <td>PLOT   Linear plot.  PLOT(X,Y) plots vector Y versus vector X. If X or Y is a matrix, then the vector is plotted versus the
               rows or columns of the matrix, whichever line up.  If X is a scalar and Y is a vector, disconnected line objects are created
               and plotted as discrete points vertically at X.
            </td>
            <tr></tr>
            <td width="250px"><a href="S2VectorField.plot.html"><tt>plot</tt></a><span>   (S2VectorField)</span></td>
            <td>plot spherical vector field</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.plot.html"><tt>plot</tt></a><span>   (EBSD)</span></td>
            <td>spatial EBSD plot</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.plot.html"><tt>plot</tt></a><span>   (grain2d)</span></td>
            <td>colorize grains</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.plot.html"><tt>plot</tt></a><span>   (grainBoundary)</span></td>
            <td>plot grain boundaries</td>
            <tr></tr>
            <td width="250px"><a href="triplePointList.plot.html"><tt>plot</tt></a><span>   (triplePointList)</span></td>
            <td>plot grain boundaries</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plot.html"><tt>plot</tt></a><span>   (ODF)</span></td>
            <td>plots odf or append to a previous plot using 'add2all'</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plot.html"><tt>plot</tt></a><span>   (PoleFigure)</span></td>
            <td>plot pole figure</td>
            <tr></tr>
            <td width="250px"><a href="zeroRangeMethod.plot.html"><tt>plot</tt></a><span>   (zeroRangeMethod)</span></td>
            <td>plot zero regions in pole figures</td>
            <tr></tr>
            <td width="250px"><a href="tensor.plot.html"><tt>plot</tt></a><span>   (tensor)</span></td>
            <td>plot a tensor T</td>
            <tr></tr>
            <td width="250px"><a href="ODFSections.plot.html"><tt>plot</tt></a><span>   (ODFSections)</span></td>
            <td>plot data into ODF sections</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.plot.html"><tt>plot</tt></a><span>   (S1Grid)</span></td>
            <td>plot grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Triangulation.plot.html"><tt>plot</tt></a><span>   (S2Triangulation)</span></td>
            <td>find all edges given by vertex i and vertex j</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.plot.html"><tt>plot</tt></a><span>   (crystalShape)</span></td>
            <td>colorize grains</td>
            <tr></tr>
            <td width="250px"><a href="fibre.plot.html"><tt>plot</tt></a><span>   (fibre)</span></td>
            <td>plot a fibre</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plot.html"><tt>plot</tt></a><span>   (orientation)</span></td>
            <td>annotate a orientation to an existing plot</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.plot.html"><tt>plot</tt></a><span>   (orientationRegion)</span></td>
            <td>plots a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.plot.html"><tt>plot</tt></a><span>   (quaternion)</span></td>
            <td>PLOT   Linear plot.  PLOT(X,Y) plots vector Y versus vector X. If X or Y is a matrix, then the vector is plotted versus the
               rows or columns of the matrix, whichever line up.  If X is a scalar and Y is a vector, disconnected line objects are created
               and plotted as discrete points vertically at X.
            </td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.plot.html"><tt>plot</tt></a><span>   (sphericalRegion)</span></td>
            <td>plots a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.plot.html"><tt>plot</tt></a><span>   (symmetry)</span></td>
            <td>visualize symmetry elements according to international table</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plot.html"><tt>plot</tt></a><span>   (vector3d)</span></td>
            <td>plot vectors as two dimensional projections on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plot.html"><tt>plot</tt></a><span>   (kernel)</span></td>
            <td>plot the kernel function</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.plot3d.html"><tt>plot3d</tt></a><span>   (S2Fun)</span></td>
            <td>plot spherical Function</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plot3d.html"><tt>plot3d</tt></a><span>   (ODF)</span></td>
            <td>plots odf</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plot3d.html"><tt>plot3d</tt></a><span>   (vector3d)</span></td>
            <td>plot spherical data</td>
            <tr></tr>
            <td width="250px"><a href="plot_spectra.html"><tt>plot_spectra</tt></a></td>
            <td>plot spectra of the Dubna goniometer</td>
            <tr></tr>
            <td width="250px"><a href="plota2east.html"><tt>plota2east</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plota2north.html"><tt>plota2north</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plota2south.html"><tt>plota2south</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plota2west.html"><tt>plota2west</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotAngleDistribution.html"><tt>plotAngleDistribution</tt></a></td>
            <td>plot axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="plotAxisDistribution.html"><tt>plotAxisDistribution</tt></a></td>
            <td>plot axis distribution</td>
            <tr></tr>
            <td width="250px"><a href="plotb2east.html"><tt>plotb2east</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotb2north.html"><tt>plotb2north</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotb2south.html"><tt>plotb2south</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotb2west.html"><tt>plotb2west</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plotCustom.html"><tt>plotCustom</tt></a><span>   (vector3d)</span></td>
            <td>Syntax plotcustom(v,@(x,y) drawCommand(x,y))  %</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotDiff.html"><tt>plotDiff</tt></a><span>   (ODF)</span></td>
            <td>difference plot between two odfs or an odf and a pole figure</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plotDiff.html"><tt>plotDiff</tt></a><span>   (PoleFigure)</span></td>
            <td>difference plot between two pole figures or an odf and a pole figure</td>
            <tr></tr>
            <td width="250px"><a href="plotEllipse.html"><tt>plotEllipse</tt></a></td>
            <td>plot multiple ellipses</td>
            <tr></tr>
            <td width="250px"><a href="plotEmptySphere.html"><tt>plotEmptySphere</tt></a></td>
            <td>plots white sphere</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotFibre.html"><tt>plotFibre</tt></a><span>   (ODF)</span></td>
            <td>plot odf along a fibre</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotFourier.html"><tt>plotFourier</tt></a><span>   (ODF)</span></td>
            <td>plots Fourier coefficients of the odf</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plotFourier.html"><tt>plotFourier</tt></a><span>   (kernel)</span></td>
            <td>plot the Chybeyshev coefficients of the kernel function</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.plotHKL.html"><tt>plotHKL</tt></a><span>   (crystalSymmetry)</span></td>
            <td>plot symmetry</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotIPDF.html"><tt>plotIPDF</tt></a><span>   (ODF)</span></td>
            <td>plot inverse pole figures</td>
            <tr></tr>
            <td width="250px"><a href="fibre.plotIPDF.html"><tt>plotIPDF</tt></a><span>   (fibre)</span></td>
            <td>plot orientations into inverse pole figures</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotIPDF.html"><tt>plotIPDF</tt></a><span>   (orientation)</span></td>
            <td>plot orientations into inverse pole figures</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotPDF.html"><tt>plotPDF</tt></a><span>   (ODF)</span></td>
            <td>plot pole figures</td>
            <tr></tr>
            <td width="250px"><a href="fibre.plotPDF.html"><tt>plotPDF</tt></a><span>   (fibre)</span></td>
            <td>plot a fibre into pole figures</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotPDF.html"><tt>plotPDF</tt></a><span>   (orientation)</span></td>
            <td>plot orientations into pole figures</td>
            <tr></tr>
            <td width="250px"><a href="kernel.plotPDF.html"><tt>plotPDF</tt></a><span>   (kernel)</span></td>
            <td>plot Radon transformed kernel</td>
            <tr></tr>
            <td width="250px"><a href="plotS2Grid.html"><tt>plotS2Grid</tt></a></td>
            <td>create a regular S2Grid for plotting</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.plotSection.html"><tt>plotSection</tt></a><span>   (S2Fun)</span></td>
            <td>Syntax plotSection(sF,vector3d.Z) plotSection(sF,vector3d.Z,pi/3)</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorField.plotSection.html"><tt>plotSection</tt></a><span>   (S2VectorField)</span></td>
            <td>Syntax plotSection(sVF,vector3d.Z) plotSection(sVF,vector3d.Z,pi/3)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plotSection.html"><tt>plotSection</tt></a><span>   (ODF)</span></td>
            <td>plot ODF sections</td>
            <tr></tr>
            <td width="250px"><a href="orientation.plotSection.html"><tt>plotSection</tt></a><span>   (orientation)</span></td>
            <td>plot orientations to ODF sections</td>
            <tr></tr>
            <td width="250px"><a href="plotSO3Grid.html"><tt>plotSO3Grid</tt></a></td>
            <td>give a regular grid in orientation space</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.plotSpektra.html"><tt>plotSpektra</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>plots Fourier coefficients of a spherical function</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.plotUnitCells.html"><tt>plotUnitCells</tt></a><span>   (EBSD)</span></td>
            <td>low level plotting routine for EBSD maps</td>
            <tr></tr>
            <td width="250px"><a href="EBSDhex.plotUnitCells.html"><tt>plotUnitCells</tt></a><span>   (EBSDhex)</span></td>
            <td>approximate plot of hexagonal ebsd data</td>
            <tr></tr>
            <td width="250px"><a href="EBSDsquare.plotUnitCells.html"><tt>plotUnitCells</tt></a><span>   (EBSDsquare)</span></td>
            <td>plot EBSD map through imagesc</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.plotUVW.html"><tt>plotUVW</tt></a><span>   (crystalSymmetry)</span></td>
            <td>plot symmetry</td>
            <tr></tr>
            <td width="250px"><a href="plotx2east.html"><tt>plotx2east</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2north.html"><tt>plotx2north</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2south.html"><tt>plotx2south</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotx2west.html"><tt>plotx2west</tt></a></td>
            <td>set the default plot direction of the x-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotzIntoPlane.html"><tt>plotzIntoPlane</tt></a></td>
            <td>set the default plot direction of the z-axis</td>
            <tr></tr>
            <td width="250px"><a href="plotzOutOfPlane.html"><tt>plotzOutOfPlane</tt></a></td>
            <td>set the default plot direction of the z-axis</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.plus.html"><tt>plus</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>impements sF1 + sF2</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.plus.html"><tt>plus</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>Syntax sF = sF1.^a</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.plus.html"><tt>plus</tt></a><span>   (S2FunTri)</span></td>
            <td>+   Plus. X + Y adds matrices X and Y. X and Y must have compatible sizes. In the simplest cases, they can be the same size
               or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension sizes of the inputs are either
               the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.plus.html"><tt>plus</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>Syntax sVF = sVF1+sVF2 sVF = a+sVF1 sVF = sVF1+a</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.plus.html"><tt>plus</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>Syntax sVF = sVF1 + sVF2 sVF = sVF + v</td>
            <tr></tr>
            <td width="250px"><a href="ODF.plus.html"><tt>plus</tt></a><span>   (ODF)</span></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.plus.html"><tt>plus</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 + pf2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.plus.html"><tt>plus</tt></a><span>   (tensor)</span></td>
            <td>add two tensors</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.plus.html"><tt>plus</tt></a><span>   (S1Grid)</span></td>
            <td>+   Plus. X + Y adds matrices X and Y. X and Y must have compatible sizes. In the simplest cases, they can be the same size
               or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension sizes of the inputs are either
               the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.plus.html"><tt>plus</tt></a><span>   (crystalShape)</span></td>
            <td>crystal shape should be first argument</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.plus.html"><tt>plus</tt></a><span>   (quaternion)</span></td>
            <td>pointwise addition</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.plus.html"><tt>plus</tt></a><span>   (vector3d)</span></td>
            <td>poitwise addition</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.PoissonRatio.html"><tt>PoissonRatio</tt></a><span>   (complianceTensor)</span></td>
            <td>computes the Poisson ratio of an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.PoissonRatio.html"><tt>PoissonRatio</tt></a><span>   (stiffnessTensor)</span></td>
            <td>computes the Poisson ratio of an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="tensor.polar.html"><tt>polar</tt></a><span>   (tensor)</span></td>
            <td>compute the polar decomposition of rank 2 tensors</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.polar.html"><tt>polar</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>polar decomposition of velocity gradient tensor</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.polar.html"><tt>polar</tt></a><span>   (S2Grid)</span></td>
            <td>polar coordinates of S2Grid</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.polar.html"><tt>polar</tt></a><span>   (vector3d)</span></td>
            <td>cartesian to spherical coordinates Input v - @vector3d Output theta  - polar angle rho    - azimuthal angle  r      - radius</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.polarCoordinates.html"><tt>polarCoordinates</tt></a><span>   (sphericalRegion)</span></td>
            <td>compute polar coordinates of with respect to a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.PoleFigure.html"><tt>PoleFigure</tt></a><span>   (PoleFigure)</span></td>
            <td>constructor</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.polyArea.html"><tt>polyArea</tt></a><span>   (vector3d)</span></td>
            <td>area of a flat polygon given by vertices v1, v2, ..., v_n</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.power.html"><tt>power</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>Syntax sF = sF1.^a</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.power.html"><tt>power</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>Syntax sF = sF1.^a</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.power.html"><tt>power</tt></a><span>   (S2FunTri)</span></td>
            <td>.^  Array power. Z = X.^Y denotes element-by-element powers. X and Y must have compatible sizes. In the simplest cases, they
               can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension sizes
               of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.power.html"><tt>power</tt></a><span>   (orientation)</span></td>
            <td>ori.^n</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.power.html"><tt>power</tt></a><span>   (quaternion)</span></td>
            <td>q.^n</td>
            <tr></tr>
            <td width="250px"><a href="rotation.power.html"><tt>power</tt></a><span>   (rotation)</span></td>
            <td>r.^n</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.principalComponents.html"><tt>principalComponents</tt></a><span>   (grain2d)</span></td>
            <td>returns the principalcomponents of grain polygon, without Holes</td>
            <tr></tr>
            <td width="250px"><a href="proceed_spectra.html"><tt>proceed_spectra</tt></a></td>
            <td>procede Dubna spectra</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.prod.html"><tt>prod</tt></a><span>   (quaternion)</span></td>
            <td>overloads q1 * q2 * q3</td>
            <tr></tr>
            <td width="250px"><a href="progress.html"><tt>progress</tt></a></td>
            <td>display progress</td>
            <tr></tr>
            <td width="250px"><a href="ODFSections.project.html"><tt>project</tt></a><span>   (ODFSections)</span></td>
            <td>project orientation to ODF sections used by plotSection</td>
            <tr></tr>
            <td width="250px"><a href="orientation.project2EulerFR.html"><tt>project2EulerFR</tt></a><span>   (orientation)</span></td>
            <td>projects orientation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.project2EulerFR.html"><tt>project2EulerFR</tt></a><span>   (quaternion)</span></td>
            <td>projects quaternions to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="Miller.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (Miller)</span></td>
            <td>projects vectors to the fundamental sector of the inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="orientation.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (orientation)</span></td>
            <td>projects orientation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (quaternion)</span></td>
            <td>projects quaternions to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="rotation.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (rotation)</span></td>
            <td>projects rotation to a fundamental region</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.project2FundamentalRegion.html"><tt>project2FundamentalRegion</tt></a><span>   (vector3d)</span></td>
            <td>projects vectors to the fundamental sector of the inverse pole figure</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.properGroup.html"><tt>properGroup</tt></a><span>   (symmetry)</span></td>
            <td>return the corresponding Laue group</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.properSubGroup.html"><tt>properSubGroup</tt></a><span>   (symmetry)</span></td>
            <td>return the corresponding Laue group</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>Q<a name="16"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="quaternion.qmatrix.html"><tt>qmatrix</tt></a><span>   (quaternion)</span></td>
            <td>returns the quaternion multiplication matrix</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.qq.html"><tt>qq</tt></a><span>   (quaternion)</span></td>
            <td>returns w * q' * q</td>
            <tr></tr>
            <td width="250px"><a href="orientation.qqplot.html"><tt>qqplot</tt></a><span>   (orientation)</span></td>
            <td>quantile-quantile of misorientation angle against random angular misorientation</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldHarmonic.quadrature.html"><tt>quadrature</tt></a><span>   (S2AxisFieldHarmonic)</span></td>
            <td>Syntax sF = S2AxisField.quadrature(v, value) sF = S2AxisField.quadrature(f) sF = S2AxisField.quadrature(f, 'bandwidth', M)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.quadrature.html"><tt>quadrature</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>Syntax sF = S2FunHarmonic.quadrature(nodes,values,'weights',w) sF = S2FunHarmonic.quadrature(f) sF = S2FunHarmonic.quadrature(f,
               'bandwidth', bandwidth)
            </td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.quadrature.html"><tt>quadrature</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>Syntax sF = S2FunHarmonicSym.quadrature(nodes,values,'weights',w,CS) sF = S2FunHarmonicSym.quadrature(f,CS) sF = S2FunHarmonicSym.quadrature(f,
               'bandwidth', bandwidth,CS)
            </td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.quadrature.html"><tt>quadrature</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>Syntax sVF = S2VectorField.quadrature(v, value) sVF = S2VectorField.quadrature(f) sVF = S2VectorField.quadrature(f, 'bandwidth',
               bw)
            </td>
            <tr></tr>
            <td width="250px"><a href="quadratureS2Grid.html"><tt>quadratureS2Grid</tt></a></td>
            <td>Syntax [S2G, W, M2] = quadratureS2Grid(M) quadrature grid of type chebyshev [S2G, W, M2] = quadratureS2Grid(M, 'gauss') quadrature
               grid of type gauss
            </td>
            <tr></tr>
            <td width="250px"><a href="tensor.quadric.html"><tt>quadric</tt></a><span>   (tensor)</span></td>
            <td>quadric</td>
            <tr></tr>
            <td width="250px"><a href="ODF.quantile.html"><tt>quantile</tt></a><span>   (ODF)</span></td>
            <td>quantile orientations of an ODF</td>
            <tr></tr>
            <td width="250px"><a href="quantile.html"><tt>quantile</tt></a></td>
            <td>n percent quantile of x</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.quaternion.html"><tt>quaternion</tt></a><span>   (quaternion)</span></td>
            <td>quaternion is a class. q = quaternion(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="quaternionPlot.html"><tt>quaternionPlot</tt></a></td>
            <td>create a 3d Euler angle plot</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisField.quiver.html"><tt>quiver</tt></a><span>   (S2AxisField)</span></td>
            <td>quiver spherical axis field</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorField.quiver.html"><tt>quiver</tt></a><span>   (S2VectorField)</span></td>
            <td>quiver spherical vector field</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.quiver.html"><tt>quiver</tt></a><span>   (EBSD)</span></td>
            <td>plot directions at ebsd centers</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.quiver.html"><tt>quiver</tt></a><span>   (grain2d)</span></td>
            <td>plot directions at grain centers</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.quiver.html"><tt>quiver</tt></a><span>   (grainBoundary)</span></td>
            <td>plot directions at grain boundaries</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.quiver.html"><tt>quiver</tt></a><span>   (vector3d)</span></td>
            <td>Syntax quiver(v,d)</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisField.quiver3.html"><tt>quiver3</tt></a><span>   (S2AxisField)</span></td>
            <td>3-dimensional quiver spherical axis field</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.quiver3.html"><tt>quiver3</tt></a><span>   (S2Fun)</span></td>
            <td>a quiver plot on top of a surface plot</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorField.quiver3.html"><tt>quiver3</tt></a><span>   (S2VectorField)</span></td>
            <td>3-dimensional quiver spherical vector field</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.quiver3.html"><tt>quiver3</tt></a><span>   (vector3d)</span></td>
            <td>Syntax quiver(v,d)</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.quiverSection.html"><tt>quiverSection</tt></a><span>   (S2Fun)</span></td>
            <td>Syntax quiverSection(sF,v,vector3d.Z) quiverSection(sF,sVF,vector3d.Z) quiverSection(sF,v,vector3d.Z,pi/3)</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorField.quiverSection.html"><tt>quiverSection</tt></a><span>   (S2VectorField)</span></td>
            <td>plot a vector field along another vectorfield</td>
            <tr></tr>
            <td width="250px"><a href="qwarning.html"><tt>qwarning</tt></a></td>
            <td>warning with option to stop</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>R<a name="17"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.radon.html"><tt>radon</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>Radon transform of a spherical function</td>
            <tr></tr>
            <td width="250px"><a href="randp.html"><tt>randp</tt></a></td>
            <td>randp(lambda) returns Poisson distributed Vector with mean lambda</td>
            <tr></tr>
            <td width="250px"><a href="range.html"><tt>range</tt></a></td>
            <td>RANGE  Sample range. Y = RANGE(X) returns the range of the values in X.  For a vector input, Y is the difference between the
               maximum and minimum values.  For a matrix input, Y is a vector containing the range for each column.  For N-D arrays, RANGE
               operates along the first non-singleton dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rank.html"><tt>rank</tt></a><span>   (vector3d)</span></td>
            <td>rank = 1</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.rdivide.html"><tt>rdivide</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>Syntax sF = sF1/sF2 sF = sF1/a sF = a/sF1</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.rdivide.html"><tt>rdivide</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>Syntax sF = sF1/sF2 sF = sF1/a sF = a/sF1</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.rdivide.html"><tt>rdivide</tt></a><span>   (S2FunTri)</span></td>
            <td>./  Right array divide. A./B denotes element-by-element division. X and Y must have compatible sizes. In the simplest cases,
               they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension
               sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.rdivide.html"><tt>rdivide</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.rdivide.html"><tt>rdivide</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>Syntax sVF = sVF ./ sF sVF = sVF ./ a</td>
            <tr></tr>
            <td width="250px"><a href="ODF.rdivide.html"><tt>rdivide</tt></a><span>   (ODF)</span></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.rdivide.html"><tt>rdivide</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 ./ b and a ./ pf2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rdivide.html"><tt>rdivide</tt></a><span>   (tensor)</span></td>
            <td>./  Right array divide. A./B denotes element-by-element division. X and Y must have compatible sizes. In the simplest cases,
               they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension
               sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.rdivide.html"><tt>rdivide</tt></a><span>   (quaternion)</span></td>
            <td>scalar division</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rdivide.html"><tt>rdivide</tt></a><span>   (vector3d)</span></td>
            <td>scalar division v ./ s</td>
            <tr></tr>
            <td width="250px"><a href="tensor.real.html"><tt>real</tt></a><span>   (tensor)</span></td>
            <td>REAL   Complex real part. REAL(X) is the real part of X. See I or J to enter complex numbers.</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.real.html"><tt>real</tt></a><span>   (quaternion)</span></td>
            <td>real-part of of quaternion</td>
            <tr></tr>
            <td width="250px"><a href="red2blueColorMap.html"><tt>red2blueColorMap</tt></a></td>
            <td>creates a colormap, ranging from dark blue via white to dark red.</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.reduce.html"><tt>reduce</tt></a><span>   (EBSD)</span></td>
            <td>reduce ebsd data by a factor</td>
            <tr></tr>
            <td width="250px"><a href="EBSDhex.reduce.html"><tt>reduce</tt></a><span>   (EBSDhex)</span></td>
            <td>reduce ebsd data by taking only second pixel</td>
            <tr></tr>
            <td width="250px"><a href="DelaunaySO3.refine.html"><tt>refine</tt></a><span>   (DelaunaySO3)</span></td>
            <td>step 1: compute center of any two orientation connected by an edge</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.refine.html"><tt>refine</tt></a><span>   (S1Grid)</span></td>
            <td>refine S1Grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.refine.html"><tt>refine</tt></a><span>   (S2Grid)</span></td>
            <td>refine S2Grid</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.refine.html"><tt>refine</tt></a><span>   (vector3d)</span></td>
            <td>refine vectors</td>
            <tr></tr>
            <td width="250px"><a href="reflection.html"><tt>reflection</tt></a></td>
            <td>defines a reflection at plane with normal n</td>
            <tr></tr>
            <td width="250px"><a href="refractiveIndexTensor.refractiveIndex.html"><tt>refractiveIndex</tt></a><span>   (refractiveIndexTensor)</span></td>
            <td>refractive index with respect to a propagation direction</td>
            <tr></tr>
            <td width="250px"><a href="refractiveIndexTensor.refractiveIndexTensor.html"><tt>refractiveIndexTensor</tt></a><span>   (refractiveIndexTensor)</span></td>
            <td>refractiveIndexTensor is a class. rI = refractiveIndexTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="Miller.region.html"><tt>region</tt></a><span>   (Miller)</span></td>
            <td>return spherical region associated to a set of crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.region.html"><tt>region</tt></a><span>   (vector3d)</span></td>
            <td>vector3d/region is a function. sR = region(v, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.regularisation.html"><tt>regularisation</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>computes a regularisation Syntax sF = S2FunHarmonic.regularisation(S2Grid,f,lambda) sF = S2FunHarmonic.regularisation(S2Grid,f,lambda,'bandwidth',
               bandwidth,'node_weights',W,'fourier_weights',What)
            </td>
            <tr></tr>
            <td width="250px"><a href="regularS2Grid.html"><tt>regularS2Grid</tt></a></td>
            <td>Syntax regularS2Grid('points',[72 19]) regularS2Grid('resolution',[5*degree 2.5*degree]) regularS2Grid('theta',theta,'rho',rho)</td>
            <tr></tr>
            <td width="250px"><a href="regularSO3Grid.html"><tt>regularSO3Grid</tt></a></td>
            <td>regular grid in Euler orientation space</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.reorder.html"><tt>reorder</tt></a><span>   (grainBoundary)</span></td>
            <td>nicely reorder grain boundaries</td>
            <tr></tr>
            <td width="250px"><a href="repcell.html"><tt>repcell</tt></a></td>
            <td>equivalent to repmat for cells</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.repmat.html"><tt>repmat</tt></a><span>   (crystalShape)</span></td>
            <td>implements repmat for crystalShape</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.repmat.html"><tt>repmat</tt></a><span>   (quaternion)</span></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="rotation.repmat.html"><tt>repmat</tt></a><span>   (rotation)</span></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.repmat.html"><tt>repmat</tt></a><span>   (vector3d)</span></td>
            <td>overloads repmat</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.reshape.html"><tt>reshape</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="tensor.reshape.html"><tt>reshape</tt></a><span>   (tensor)</span></td>
            <td>reshape for tensors</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.reshape.html"><tt>reshape</tt></a><span>   (crystalShape)</span></td>
            <td>RESHAPE Reshape array. RESHAPE(X,M,N) or RESHAPE(X,[M,N]) returns the M-by-N matrix  whose elements are taken columnwise from
               X. An error results  if X does not have M*N elements.
            </td>
            <tr></tr>
            <td width="250px"><a href="quaternion.reshape.html"><tt>reshape</tt></a><span>   (quaternion)</span></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="rotation.reshape.html"><tt>reshape</tt></a><span>   (rotation)</span></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.reshape.html"><tt>reshape</tt></a><span>   (vector3d)</span></td>
            <td>overloads reshape</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.residualBurgersVector.html"><tt>residualBurgersVector</tt></a><span>   (slipSystem)</span></td>
            <td>compute the Schmid factor</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.restrict2Lower.html"><tt>restrict2Lower</tt></a><span>   (sphericalRegion)</span></td>
            <td>sphericalRegion/restrict2Lower is a function. sR = restrict2Lower(sR)</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.restrict2Upper.html"><tt>restrict2Upper</tt></a><span>   (sphericalRegion)</span></td>
            <td>sphericalRegion/restrict2Upper is a function. sR = restrict2Upper(sR)</td>
            <tr></tr>
            <td width="250px"><a href="restrictEBSD_ang.html"><tt>restrictEBSD_ang</tt></a></td>
            <td>read file header</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorField.rho.html"><tt>rho</tt></a><span>   (S2VectorField)</span></td>
            <td>Gives the vector in the tangential plane in v in the direction rho</td>
            <tr></tr>
            <td width="250px"><a href="rhoInside.html"><tt>rhoInside</tt></a></td>
            <td>rhoInside is a function. ind = rhoInside(rho, minRho, maxRho)</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.rhoRange.html"><tt>rhoRange</tt></a><span>   (sphericalRegion)</span></td>
            <td>compute range of the polar angle of a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="kernel.RK_symmetrised.html"><tt>RK_symmetrised</tt></a><span>   (kernel)</span></td>
            <td>sum Radon trasformed kernel</td>
            <tr></tr>
            <td width="250px"><a href="rmallappdata.html"><tt>rmallappdata</tt></a></td>
            <td>removes all figure appdata</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.Rodrigues.html"><tt>Rodrigues</tt></a><span>   (quaternion)</span></td>
            <td>quaternion to rodrigues representation</td>
            <tr></tr>
            <td width="250px"><a href="rodrigues2quat.html"><tt>rodrigues2quat</tt></a></td>
            <td>rodrigues2quat is a function. q = rodrigues2quat(R, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="RodriguesPlot.html"><tt>RodriguesPlot</tt></a></td>
            <td>create a 3d Euler angle plot</td>
            <tr></tr>
            <td width="250px"><a href="BinghamS2.rotate.html"><tt>rotate</tt></a><span>   (BinghamS2)</span></td>
            <td>rotate a BinghamS2 function</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.rotate.html"><tt>rotate</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>rotate a function by a rotation</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.rotate.html"><tt>rotate</tt></a><span>   (S2FunTri)</span></td>
            <td>ROTATE Rotate objects about specified origin and direction. ROTATE(H,[THETA PHI],ALPHA) rotates the objects with handles H
               through angle ALPHA about an axis described by the 2-element direction vector [THETA PHI] (spherical coordinates).   All the
               angles are in degrees.  The handles in H must be children of the same axes.
            </td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.rotate.html"><tt>rotate</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>rotate a function by a rotation</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.rotate.html"><tt>rotate</tt></a><span>   (EBSD)</span></td>
            <td>rotate EBSD orientations or spatial data around point of origin</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.rotate.html"><tt>rotate</tt></a><span>   (BinghamComponent)</span></td>
            <td>rotate component</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.rotate.html"><tt>rotate</tt></a><span>   (FourierComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="ODF.rotate.html"><tt>rotate</tt></a><span>   (ODF)</span></td>
            <td>rotate ODF</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.rotate.html"><tt>rotate</tt></a><span>   (femComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.rotate.html"><tt>rotate</tt></a><span>   (fibreComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.rotate.html"><tt>rotate</tt></a><span>   (uniformComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.rotate.html"><tt>rotate</tt></a><span>   (unimodalComponent)</span></td>
            <td>called by ODF/rotate</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.rotate.html"><tt>rotate</tt></a><span>   (PoleFigure)</span></td>
            <td>rotates pole figures by a certain rotation</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rotate.html"><tt>rotate</tt></a><span>   (tensor)</span></td>
            <td>rotate a tensor by a list of rotations</td>
            <tr></tr>
            <td width="250px"><a href="Miller.rotate.html"><tt>rotate</tt></a><span>   (Miller)</span></td>
            <td>rotate crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="S2Triangulation.rotate.html"><tt>rotate</tt></a><span>   (S2Triangulation)</span></td>
            <td>ROTATE Rotate objects about specified origin and direction. ROTATE(H,[THETA PHI],ALPHA) rotates the objects with handles H
               through angle ALPHA about an axis described by the 2-element direction vector [THETA PHI] (spherical coordinates).   All the
               angles are in degrees.  The handles in H must be children of the same axes.
            </td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.rotate.html"><tt>rotate</tt></a><span>   (crystalShape)</span></td>
            <td>rotate a crystal shape by an rotation or orientation</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.rotate.html"><tt>rotate</tt></a><span>   (dislocationSystem)</span></td>
            <td>rotate dislocation systems system</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.rotate.html"><tt>rotate</tt></a><span>   (orientationRegion)</span></td>
            <td>rotate of a orientation region</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.rotate.html"><tt>rotate</tt></a><span>   (slipSystem)</span></td>
            <td>rotate slip system</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.rotate.html"><tt>rotate</tt></a><span>   (sphericalRegion)</span></td>
            <td>rotate of a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rotate.html"><tt>rotate</tt></a><span>   (vector3d)</span></td>
            <td>rotate vector3d by rotation or orientation</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHandle.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (S2FunHandle)</span></td>
            <td>rotate a function by a rotation</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>rotate a function by a rotation</td>
            <tr></tr>
            <td width="250px"><a href="ODF.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (ODF)</span></td>
            <td>rotate ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (PoleFigure)</span></td>
            <td>is called by rot * pf</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (tensor)</span></td>
            <td>rotate a tensor by a list of rotations</td>
            <tr></tr>
            <td width="250px"><a href="Miller.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (Miller)</span></td>
            <td>rotate crystal directions</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (crystalShape)</span></td>
            <td>rotate a crystal shape by an rotation or orientation</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (dislocationSystem)</span></td>
            <td>rotate dislocation systems</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (slipSystem)</span></td>
            <td>rotate slip system</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.rotate_outer.html"><tt>rotate_outer</tt></a><span>   (vector3d)</span></td>
            <td>rotate vector3d by quaternion</td>
            <tr></tr>
            <td width="250px"><a href="tensor.rotation.html"><tt>rotation</tt></a><span>   (tensor)</span></td>
            <td>convertes orthogonal rank 2 tensors into rotations</td>
            <tr></tr>
            <td width="250px"><a href="fibre.rotation.html"><tt>rotation</tt></a><span>   (fibre)</span></td>
            <td>generate a list of orientation out of a fibre</td>
            <tr></tr>
            <td width="250px"><a href="rotation.rotation.html"><tt>rotation</tt></a><span>   (rotation)</span></td>
            <td>defines an rotation</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.rotation_special.html"><tt>rotation_special</tt></a><span>   (symmetry)</span></td>
            <td>returns symmetry elements different from rotation about c-axis</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.rotationRate.html"><tt>rotationRate</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>rotation rate</td>
            <tr></tr>
            <td width="250px"><a href="Miller.round.html"><tt>round</tt></a><span>   (Miller)</span></td>
            <td>tries to round miller indizes to greatest common divisor</td>
            <tr></tr>
            <td width="250px"><a href="orientation.round2Miller.html"><tt>round2Miller</tt></a><span>   (orientation)</span></td>
            <td>find lattice alignements for arbitrary orientations and misorientations</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>S<a name="18"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="S1Grid.S1Grid.html"><tt>S1Grid</tt></a><span>   (S1Grid)</span></td>
            <td>Constructor</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisField.S2AxisField.html"><tt>S2AxisField</tt></a><span>   (S2AxisField)</span></td>
            <td>a class represeneting a axis field on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldHarmonic.S2AxisFieldHarmonic.html"><tt>S2AxisFieldHarmonic</tt></a><span>   (S2AxisFieldHarmonic)</span></td>
            <td>a class represeneting a axis field on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2AxisFieldTri.S2AxisFieldTri.html"><tt>S2AxisFieldTri</tt></a><span>   (S2AxisFieldTri)</span></td>
            <td>a class represeneting a function on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2DeLaValleePoussin.html"><tt>S2DeLaValleePoussin</tt></a></td>
            <td>extract parameter and halfwidth</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.S2Fun.html"><tt>S2Fun</tt></a><span>   (S2Fun)</span></td>
            <td>a class represeneting a function on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun_index.html"><tt>S2Fun_index</tt></a></td>
            <td>*|S2Fun|*</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHandle.S2FunHandle.html"><tt>S2FunHandle</tt></a><span>   (S2FunHandle)</span></td>
            <td>a class represeneting a function on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.S2FunHarmonic.html"><tt>S2FunHarmonic</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>a class representing a function on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.S2FunHarmonicSym.html"><tt>S2FunHarmonicSym</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>a class represeneting a symmetrised function on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.S2FunTri.html"><tt>S2FunTri</tt></a><span>   (S2FunTri)</span></td>
            <td>a class represeneting a function on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.S2Grid.html"><tt>S2Grid</tt></a><span>   (S2Grid)</span></td>
            <td>Syntax S2Grid(theta,rho)      % fills a Sphere with N--nodes regularS2Grid('resolution',5*degree)     % construct regular
               polar and azimuthal spacing equispacedS2Grid('resolution',5*degree)  % construct equispaced nodes
            </td>
            <tr></tr>
            <td width="250px"><a href="S2Kernel.S2Kernel.html"><tt>S2Kernel</tt></a><span>   (S2Kernel)</span></td>
            <td>S2Kernel is a class. S2K = S2Kernel(A)</td>
            <tr></tr>
            <td width="250px"><a href="S2Triangulation.S2Triangulation.html"><tt>S2Triangulation</tt></a><span>   (S2Triangulation)</span></td>
            <td>a class represeneting a triangulation on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.S2VectorFieldHarmonic.html"><tt>S2VectorFieldHarmonic</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>a class represeneting a function on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.S2VectorFieldTri.html"><tt>S2VectorFieldTri</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>a class represeneting a function on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="SantaFe.html"><tt>SantaFe</tt></a></td>
            <td>the SantaFe-sample ODF</td>
            <tr></tr>
            <td width="250px"><a href="save_sparse.html"><tt>save_sparse</tt></a></td>
            <td>convert sparse matrix to jc, ir, pr</td>
            <tr></tr>
            <td width="250px"><a href="saveFigure.html"><tt>saveFigure</tt></a></td>
            <td>save figure as graphics file</td>
            <tr></tr>
            <td width="250px"><a href="saveGrainSet_hdf5.html"><tt>saveGrainSet_hdf5</tt></a></td>
            <td>Save GrainSet object to HDF5 format</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.scale.html"><tt>scale</tt></a><span>   (PoleFigure)</span></td>
            <td>scale polefigure by a factor</td>
            <tr></tr>
            <td width="250px"><a href="scaleBar.html"><tt>scaleBar</tt></a></td>
            <td>Inserts a scale bar on the current ebsd or grain map.</td>
            <tr></tr>
            <td width="250px"><a href="Miller.scatter.html"><tt>scatter</tt></a><span>   (Miller)</span></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="orientation.scatter.html"><tt>scatter</tt></a><span>   (orientation)</span></td>
            <td>plots orientations in 3d</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.scatter.html"><tt>scatter</tt></a><span>   (quaternion)</span></td>
            <td>plot function</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.scatter.html"><tt>scatter</tt></a><span>   (vector3d)</span></td>
            <td>Syntax scatter(v)              % plot the directions v scatter(v,data)         % colorize directions according to data scatter(v,'label',text)
               % plot text below markers scatter(v,'label',text,'textaboveMarker') % plot text above markers
            </td>
            <tr></tr>
            <td width="250px"><a href="vector3d.scatter3d.html"><tt>scatter3d</tt></a><span>   (vector3d)</span></td>
            <td>plot spherical data</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.SchmidFactor.html"><tt>SchmidFactor</tt></a><span>   (slipSystem)</span></td>
            <td>compute the Schmid factor</td>
            <tr></tr>
            <td width="250px"><a href="SchmidTensor.html"><tt>SchmidTensor</tt></a></td>
            <td>computes the Schmidt tensor</td>
            <tr></tr>
            <td width="250px"><a href="sectionLabels.html"><tt>sectionLabels</tt></a></td>
            <td>sectionLabels is a function. [symbol, labelx, labely] = sectionLabels(type)</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.segLength.html"><tt>segLength</tt></a><span>   (grainBoundary)</span></td>
            <td>length of a boundary segment</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.select.html"><tt>select</tt></a><span>   (PoleFigure)</span></td>
            <td>select PoleFigures</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.selectInteractive.html"><tt>selectInteractive</tt></a><span>   (EBSD)</span></td>
            <td>select interactively a rectangular region of an EBSD data set</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.selectInteractive.html"><tt>selectInteractive</tt></a><span>   (grain2d)</span></td>
            <td>select interactively a rectangular region of an EBSD data set</td>
            <tr></tr>
            <td width="250px"><a href="selectMaxbyColumn.html"><tt>selectMaxbyColumn</tt></a></td>
            <td>find maximum in each row</td>
            <tr></tr>
            <td width="250px"><a href="selectMaxbyRow.html"><tt>selectMaxbyRow</tt></a></td>
            <td>find maximum in each column</td>
            <tr></tr>
            <td width="250px"><a href="selectMinbyColumn.html"><tt>selectMinbyColumn</tt></a></td>
            <td>find minimum in each column</td>
            <tr></tr>
            <td width="250px"><a href="selectMinbyRow.html"><tt>selectMinbyRow</tt></a></td>
            <td>find minimum in each row</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.selector_old.html"><tt>selector_old</tt></a><span>   (grain2d)</span></td>
            <td>Grain Selector</td>
            <tr></tr>
            <td width="250px"><a href="selectPolygon.html"><tt>selectPolygon</tt></a></td>
            <td>select a polygon by mouse</td>
            <tr></tr>
            <td width="250px"><a href="set_default_option.html"><tt>set_default_option</tt></a></td>
            <td>set option in option list if not yet present</td>
            <tr></tr>
            <td width="250px"><a href="set_option.html"><tt>set_option</tt></a></td>
            <td>set option in option list</td>
            <tr></tr>
            <td width="250px"><a href="setappdata.html"><tt>setappdata</tt></a></td>
            <td>make setappdata work with multiple handles</td>
            <tr></tr>
            <td width="250px"><a href="setCamera.html"><tt>setCamera</tt></a></td>
            <td>set Camera according to xAxis and zAxis position</td>
            <tr></tr>
            <td width="250px"><a href="setColorRange.html"><tt>setColorRange</tt></a></td>
            <td>set color range for figures</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.setdiff.html"><tt>setdiff</tt></a><span>   (vector3d)</span></td>
            <td>remove vectors v2 from a set of vectors v1</td>
            <tr></tr>
            <td width="250px"><a href="setFont.html"><tt>setFont</tt></a></td>
            <td>FontName = "Consolas"; FontName = "Nimbus Mono PS";</td>
            <tr></tr>
            <td width="250px"><a href="setMTEXpref.html"><tt>setMTEXpref</tt></a></td>
            <td>setMTEXpref is a function. setMTEXpref(pref, value)</td>
            <tr></tr>
            <td width="250px"><a href="setNull.html"><tt>setNull</tt></a></td>
            <td>set approx zero to exact zero</td>
            <tr></tr>
            <td width="250px"><a href="setOption.html"><tt>setOption</tt></a></td>
            <td>set option in option list</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.setSubSet.html"><tt>setSubSet</tt></a><span>   (quaternion)</span></td>
            <td>indexing of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.shapeFactor.html"><tt>shapeFactor</tt></a><span>   (grain2d)</span></td>
            <td>calculates the shapefactor of the grain-polygon, without Holes</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.shearDirection.html"><tt>shearDirection</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>shear direction</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.shearModulus.html"><tt>shearModulus</tt></a><span>   (complianceTensor)</span></td>
            <td>shear modulus for an compliance tensor</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.shearModulus.html"><tt>shearModulus</tt></a><span>   (stiffnessTensor)</span></td>
            <td>shear modulus for an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.shift.html"><tt>shift</tt></a><span>   (EBSD)</span></td>
            <td>shift spatial ebsd-data about (x,y)</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.shift.html"><tt>shift</tt></a><span>   (S1Grid)</span></td>
            <td>shifts S1Grid by delta</td>
            <tr></tr>
            <td width="250px"><a href="sigmaSections.html"><tt>sigmaSections</tt></a></td>
            <td>sigmaSections is a class. oS = sigmaSections(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.simultaniousCG.html"><tt>simultaniousCG</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>calculates the minimum of a spherical harminc Syntax [v,pos] = simultaniousCG(sF) % the position where the minimum is atained</td>
            <tr></tr>
            <td width="250px"><a href="tensor.size.html"><tt>size</tt></a><span>   (tensor)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.size.html"><tt>size</tt></a><span>   (crystalShape)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.size.html"><tt>size</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="fibre.size.html"><tt>size</tt></a><span>   (fibre)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.size.html"><tt>size</tt></a><span>   (quaternion)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.size.html"><tt>size</tt></a><span>   (slipSystem)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.size.html"><tt>size</tt></a><span>   (vector3d)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="size2str.html"><tt>size2str</tt></a></td>
            <td>convert size to string</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.slipSystem.html"><tt>slipSystem</tt></a><span>   (slipSystem)</span></td>
            <td>class representing slip systems</td>
            <tr></tr>
            <td width="250px"><a href="ODF.slope.html"><tt>slope</tt></a><span>   (ODF)</span></td>
            <td>| grad(r) |</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.smiley.html"><tt>smiley</tt></a><span>   (S2Fun)</span></td>
            <td>S2Fun.smiley is a function. f = smiley(v, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.smooth.html"><tt>smooth</tt></a><span>   (EBSD)</span></td>
            <td>smooth spatial EBSD</td>
            <tr></tr>
            <td width="250px"><a href="EBSDhex.smooth.html"><tt>smooth</tt></a><span>   (EBSDhex)</span></td>
            <td>smooth spatial EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSDsquare.smooth.html"><tt>smooth</tt></a><span>   (EBSDsquare)</span></td>
            <td>smooth spatial EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.smooth.html"><tt>smooth</tt></a><span>   (grain2d)</span></td>
            <td>constraint laplacian smoothing of grain boundaries  and inner boundaries.</td>
            <tr></tr>
            <td width="250px"><a href="BinghamComponent.smooth.html"><tt>smooth</tt></a><span>   (BinghamComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="FourierComponent.smooth.html"><tt>smooth</tt></a><span>   (FourierComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="ODF.smooth.html"><tt>smooth</tt></a><span>   (ODF)</span></td>
            <td>smooth ODF</td>
            <tr></tr>
            <td width="250px"><a href="femComponent.smooth.html"><tt>smooth</tt></a><span>   (femComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="fibreComponent.smooth.html"><tt>smooth</tt></a><span>   (fibreComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.smooth.html"><tt>smooth</tt></a><span>   (uniformComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.smooth.html"><tt>smooth</tt></a><span>   (unimodalComponent)</span></td>
            <td>smooth ODF component</td>
            <tr></tr>
            <td width="250px"><a href="Miller.smooth.html"><tt>smooth</tt></a><span>   (Miller)</span></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.smooth.html"><tt>smooth</tt></a><span>   (vector3d)</span></td>
            <td>low level function for plotting functions on the sphere</td>
            <tr></tr>
            <td width="250px"><a href="smoothn.html"><tt>smoothn</tt></a></td>
            <td>SMOOTHN Robust spline smoothing for 1-D to N-D data. SMOOTHN provides a fast, automatized and robust discretized spline smoothing
               for data of arbitrary dimension.
            </td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.SO3Grid.html"><tt>SO3Grid</tt></a><span>   (SO3Grid)</span></td>
            <td>represent orientations in a gridded structure to allow quick access</td>
            <tr></tr>
            <td width="250px"><a href="SobolevKernel.html"><tt>SobolevKernel</tt></a></td>
            <td>SobolevKernel is a class. psi = SobolevKernel(s, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.sparse.html"><tt>sparse</tt></a><span>   (vector3d)</span></td>
            <td>SPARSE Create sparse matrix. S = SPARSE(X) converts a sparse or full matrix to sparse form by squeezing out any zero elements.</td>
            <tr></tr>
            <td width="250px"><a href="sparseConcat.html"><tt>sparseConcat</tt></a></td>
            <td>sparseConcat is a function. newSparse = sparseConcat(oldSparse, newRows, newCols, newVals, newSize)</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.spatialProfile.html"><tt>spatialProfile</tt></a><span>   (EBSD)</span></td>
            <td>select EBSD data along line segments</td>
            <tr></tr>
            <td width="250px"><a href="specimenSymmetry.specimenSymmetry.html"><tt>specimenSymmetry</tt></a><span>   (specimenSymmetry)</span></td>
            <td>defines a specimen symmetry</td>
            <tr></tr>
            <td width="250px"><a href="refractiveIndexTensor.spectralTransmission.html"><tt>spectralTransmission</tt></a><span>   (refractiveIndexTensor)</span></td>
            <td>Syntax rgb = spectralTransmission(rI,vprop,p,thickness)</td>
            <tr></tr>
            <td width="250px"><a href="spectralTransmissionColorKey.html"><tt>spectralTransmissionColorKey</tt></a></td>
            <td>spectralTransmissionColorKey is a class. oM = spectralTransmissionColorKey(rI, thickness, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="orientation.sphereVolume.html"><tt>sphereVolume</tt></a><span>   (orientation)</span></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="sphericalClebschGordan.html"><tt>sphericalClebschGordan</tt></a></td>
            <td>use global wigner3j</td>
            <tr></tr>
            <td width="250px"><a href="sphericalPlot.html"><tt>sphericalPlot</tt></a></td>
            <td>sphericalPlot is responsible for visualizing spherical data</td>
            <tr></tr>
            <td width="250px"><a href="sphericalProjection.html"><tt>sphericalProjection</tt></a></td>
            <td>sphericalProjection</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.sphericalRegion.html"><tt>sphericalRegion</tt></a><span>   (sphericalRegion)</span></td>
            <td>sphericalRegion implements a region on the sphere The region is bounded by small circles given by there normal vectors and
               the maximum inner product, i.e., all points v inside a region satisfy the conditions dot(v, N) &lt;= alpha
            </td>
            <tr></tr>
            <td width="250px"><a href="sphericalY.html"><tt>sphericalY</tt></a></td>
            <td>spherical harmonics of degree l</td>
            <tr></tr>
            <td width="250px"><a href="spinTensor.spinTensor.html"><tt>spinTensor</tt></a><span>   (spinTensor)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="splineFilter.html"><tt>splineFilter</tt></a></td>
            <td>smoothes quaternions by projecting them into tangential space and performing there smoothing spline approximation</td>
            <tr></tr>
            <td width="250px"><a href="splitdata.html"><tt>splitdata</tt></a></td>
            <td>make n - partitions of a list, returns its indices</td>
            <tr></tr>
            <td width="250px"><a href="spotColorKey.html"><tt>spotColorKey</tt></a></td>
            <td>Detailed explanation goes here</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.spy.html"><tt>spy</tt></a><span>   (SO3Grid)</span></td>
            <td>spy distance matrix</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.sqrt.html"><tt>sqrt</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>square root of a function Syntax sF = sqrt(sF) sF = sqrt(sF, 'bandwidth', bandwidth)</td>
            <tr></tr>
            <td width="250px"><a href="tensor.sqrtm.html"><tt>sqrtm</tt></a><span>   (tensor)</span></td>
            <td>matrix exponential of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="squareProjection.html"><tt>squareProjection</tt></a></td>
            <td>equal area projection</td>
            <tr></tr>
            <td width="250px"><a href="SquareSingularityKernel.html"><tt>SquareSingularityKernel</tt></a></td>
            <td>extract parameter and halfwidth</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.steepestDescent.html"><tt>steepestDescent</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>calculates the minimum of a spherical harminc Syntax [v,pos] = steepestDescent(sF) % the position where the minimum is atained</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.steepestDescent.html"><tt>steepestDescent</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>calculates the minimum of a spherical harminc Syntax [f,pos] = steepestDescent(sF) % the position where the minimum is atained</td>
            <tr></tr>
            <td width="250px"><a href="ODF.steepestDescent.html"><tt>steepestDescent</tt></a><span>   (ODF)</span></td>
            <td>find maximum with steepest descent</td>
            <tr></tr>
            <td width="250px"><a href="ODF.steepestDescentX.html"><tt>steepestDescentX</tt></a><span>   (ODF)</span></td>
            <td>find maximum with steepest descent</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.stiffnessTensor.html"><tt>stiffnessTensor</tt></a><span>   (stiffnessTensor)</span></td>
            <td>stiffnessTensor is a class. sT = stiffnessTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.strainRate.html"><tt>strainRate</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>strain rate</td>
            <tr></tr>
            <td width="250px"><a href="strainRateTensor.strainRateTensor.html"><tt>strainRateTensor</tt></a><span>   (strainRateTensor)</span></td>
            <td>strainRateTensor is the symmetric part of a velocity gradient tensor</td>
            <tr></tr>
            <td width="250px"><a href="strainTensor.strainTensor.html"><tt>strainTensor</tt></a><span>   (strainTensor)</span></td>
            <td>strainTensor is a class. sT = strainTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="stressTensor.stressTensor.html"><tt>stressTensor</tt></a><span>   (stressTensor)</span></td>
            <td>stressTensor is a class. sT = stressTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="string2Miller.html"><tt>string2Miller</tt></a></td>
            <td>converts string to Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="S1Grid.subGrid.html"><tt>subGrid</tt></a><span>   (S1Grid)</span></td>
            <td>epsilon - neighborhood of a point in the grid</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subGrid.html"><tt>subGrid</tt></a><span>   (S2Grid)</span></td>
            <td>subgrid</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subGrid.html"><tt>subGrid</tt></a><span>   (SO3Grid)</span></td>
            <td>sub-SO3Grid as epsilon neigborhood of a node</td>
            <tr></tr>
            <td width="250px"><a href="submatrix.html"><tt>submatrix</tt></a></td>
            <td>B = A(ind) with size as A if possible</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.subsasgn.html"><tt>subsasgn</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subsasgn.html"><tt>subsasgn</tt></a><span>   (EBSD)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.subsasgn.html"><tt>subsasgn</tt></a><span>   (grain2d)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.subsasgn.html"><tt>subsasgn</tt></a><span>   (grainBoundary)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="triplePointList.subsasgn.html"><tt>subsasgn</tt></a><span>   (triplePointList)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.subsasgn.html"><tt>subsasgn</tt></a><span>   (PoleFigure)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="tensor.subsasgn.html"><tt>subsasgn</tt></a><span>   (tensor)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subsasgn.html"><tt>subsasgn</tt></a><span>   (S2Grid)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subsasgn.html"><tt>subsasgn</tt></a><span>   (SO3Grid)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.subsasgn.html"><tt>subsasgn</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subsasgn.html"><tt>subsasgn</tt></a><span>   (quaternion)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subsasgn.html"><tt>subsasgn</tt></a><span>   (rotation)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.subsasgn.html"><tt>subsasgn</tt></a><span>   (slipSystem)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subsasgn.html"><tt>subsasgn</tt></a><span>   (vector3d)</span></td>
            <td>overloads subsasgn</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subSet.html"><tt>subSet</tt></a><span>   (EBSD)</span></td>
            <td>indexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.subSet.html"><tt>subSet</tt></a><span>   (grain2d)</span></td>
            <td></td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.subSet.html"><tt>subSet</tt></a><span>   (grainBoundary)</span></td>
            <td>restrict boundary</td>
            <tr></tr>
            <td width="250px"><a href="triplePointList.subSet.html"><tt>subSet</tt></a><span>   (triplePointList)</span></td>
            <td>restrict boundary</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.subSet.html"><tt>subSet</tt></a><span>   (crystalShape)</span></td>
            <td>crystalShape/subSet is a function. cS = subSet(cS, NSelect)</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.subSet.html"><tt>subSet</tt></a><span>   (dislocationSystem)</span></td>
            <td>subindex vector3d</td>
            <tr></tr>
            <td width="250px"><a href="fibre.subSet.html"><tt>subSet</tt></a><span>   (fibre)</span></td>
            <td>subindex vector3d</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subSet.html"><tt>subSet</tt></a><span>   (quaternion)</span></td>
            <td>indexing of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subSet.html"><tt>subSet</tt></a><span>   (rotation)</span></td>
            <td>indexing of rotation</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.subSet.html"><tt>subSet</tt></a><span>   (slipSystem)</span></td>
            <td>subindex vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subSet.html"><tt>subSet</tt></a><span>   (vector3d)</span></td>
            <td>subindex vector3d</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subsind.html"><tt>subsind</tt></a><span>   (EBSD)</span></td>
            <td>subindexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSDhex.subsind.html"><tt>subsind</tt></a><span>   (EBSDhex)</span></td>
            <td>subindexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="EBSDsquare.subsind.html"><tt>subsind</tt></a><span>   (EBSDsquare)</span></td>
            <td>subindexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.subsref.html"><tt>subsref</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.subsref.html"><tt>subsref</tt></a><span>   (EBSD)</span></td>
            <td>indexing of EBSD data</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.subsref.html"><tt>subsref</tt></a><span>   (grain2d)</span></td>
            <td>implements grains(1:3)</td>
            <tr></tr>
            <td width="250px"><a href="grainBoundary.subsref.html"><tt>subsref</tt></a><span>   (grainBoundary)</span></td>
            <td>implements gB(1:10)</td>
            <tr></tr>
            <td width="250px"><a href="triplePointList.subsref.html"><tt>subsref</tt></a><span>   (triplePointList)</span></td>
            <td>implements tP(1:10)</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.subsref.html"><tt>subsref</tt></a><span>   (PoleFigure)</span></td>
            <td>overide polefigure() and polefigure{}</td>
            <tr></tr>
            <td width="250px"><a href="tensor.subsref.html"><tt>subsref</tt></a><span>   (tensor)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="S2Grid.subsref.html"><tt>subsref</tt></a><span>   (S2Grid)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="SO3Grid.subsref.html"><tt>subsref</tt></a><span>   (SO3Grid)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.subsref.html"><tt>subsref</tt></a><span>   (crystalShape)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.subsref.html"><tt>subsref</tt></a><span>   (crystalSymmetry)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.subsref.html"><tt>subsref</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="fibre.subsref.html"><tt>subsref</tt></a><span>   (fibre)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.subsref.html"><tt>subsref</tt></a><span>   (quaternion)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="rotation.subsref.html"><tt>subsref</tt></a><span>   (rotation)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.subsref.html"><tt>subsref</tt></a><span>   (slipSystem)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.subsref.html"><tt>subsref</tt></a><span>   (symmetry)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.subsref.html"><tt>subsref</tt></a><span>   (vector3d)</span></td>
            <td>overloads subsref</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.sum.html"><tt>sum</tt></a><span>   (S2Fun)</span></td>
            <td>calculates the mean value for an univariate S2Fun or calculates the mean along a specified dimension fo a multimodal S2Fun</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.sum.html"><tt>sum</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>calculates the integral for an univariate S2Fun or sums up along a specified dimension fo a multimodal S2Fun</td>
            <tr></tr>
            <td width="250px"><a href="tensor.sum.html"><tt>sum</tt></a><span>   (tensor)</span></td>
            <td>sum of a list of tensors</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.sum.html"><tt>sum</tt></a><span>   (quaternion)</span></td>
            <td>overloads sum</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.sum.html"><tt>sum</tt></a><span>   (vector3d)</span></td>
            <td>sum of vectors</td>
            <tr></tr>
            <td width="250px"><a href="S2Fun.surf.html"><tt>surf</tt></a><span>   (S2Fun)</span></td>
            <td>SURF   3-D colored surface. SURF(X,Y,Z,C) plots the colored parametric surface defined by four matrix arguments.  The view
               point is specified by VIEW. The axis labels are determined by the range of X, Y and Z, or by the current setting of AXIS.
                The color scaling is determined by the range of C, or by the current setting of CAXIS.  The scaled color values are used
               as indices into the current COLORMAP. The shading model is set by SHADING.
            </td>
            <tr></tr>
            <td width="250px"><a href="Miller.surf.html"><tt>surf</tt></a><span>   (Miller)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.surf.html"><tt>surf</tt></a><span>   (vector3d)</span></td>
            <td>Syntax</td>
            <tr></tr>
            <td width="250px"><a href="switchUnit.html"><tt>switchUnit</tt></a></td>
            <td>returns the closest length to a known unit. For example, 10e3m will give 10km.</td>
            <tr></tr>
            <td width="250px"><a href="tensor.sym.html"><tt>sym</tt></a><span>   (tensor)</span></td>
            <td>the symmetric part S = 0.5(T + T.') of a tensor</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.symmetrise.html"><tt>symmetrise</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>symmetrises a function with respect to a symmetry or a direction</td>
            <tr></tr>
            <td width="250px"><a href="tensor.symmetrise.html"><tt>symmetrise</tt></a><span>   (tensor)</span></td>
            <td>symmetrise a tensor according to its crystal symmetry</td>
            <tr></tr>
            <td width="250px"><a href="Miller.symmetrise.html"><tt>symmetrise</tt></a><span>   (Miller)</span></td>
            <td>directions symmetrically equivalent to m</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.symmetrise.html"><tt>symmetrise</tt></a><span>   (dislocationSystem)</span></td>
            <td>find all symmetrically equivalent slips systems</td>
            <tr></tr>
            <td width="250px"><a href="fibre.symmetrise.html"><tt>symmetrise</tt></a><span>   (fibre)</span></td>
            <td>all crystallographically equivalent fibres</td>
            <tr></tr>
            <td width="250px"><a href="orientation.symmetrise.html"><tt>symmetrise</tt></a><span>   (orientation)</span></td>
            <td>all crystallographically equivalent orientations</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.symmetrise.html"><tt>symmetrise</tt></a><span>   (quaternion)</span></td>
            <td>symmetrcially equivalent orientations</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.symmetrise.html"><tt>symmetrise</tt></a><span>   (slipSystem)</span></td>
            <td>find all symmetrically equivalent slips systems</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.symmetrise.html"><tt>symmetrise</tt></a><span>   (vector3d)</span></td>
            <td>symmetrcially equivalent directions and its multiple</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.symmetry.html"><tt>symmetry</tt></a><span>   (symmetry)</span></td>
            <td>Supported Symmetries</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>T<a name="19"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="tensor.tensor.html"><tt>tensor</tt></a><span>   (tensor)</span></td>
            <td>constructor</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.tensor.html"><tt>tensor</tt></a><span>   (dislocationSystem)</span></td>
            <td>tensor representation of a dislocation system</td>
            <tr></tr>
            <td width="250px"><a href="tensor.tensorSize.html"><tt>tensorSize</tt></a><span>   (tensor)</span></td>
            <td>overloads size</td>
            <tr></tr>
            <td width="250px"><a href="grain2d.text.html"><tt>text</tt></a><span>   (grain2d)</span></td>
            <td>plot directions at grain centers</td>
            <tr></tr>
            <td width="250px"><a href="Miller.text.html"><tt>text</tt></a><span>   (Miller)</span></td>
            <td>plot Miller indece</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.text.html"><tt>text</tt></a><span>   (vector3d)</span></td>
            <td>display a text in a spherical plot</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.text3.html"><tt>text3</tt></a><span>   (vector3d)</span></td>
            <td>plot three dimensional arrows</td>
            <tr></tr>
            <td width="250px"><a href="ODF.textureindex.html"><tt>textureindex</tt></a><span>   (ODF)</span></td>
            <td>caclulate texture index of ODF</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorField.theta.html"><tt>theta</tt></a><span>   (S2VectorField)</span></td>
            <td>Gives the vector in the tangential plane in v in the direction theta</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.times.html"><tt>times</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads sF1 .* sF2</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonicSym.times.html"><tt>times</tt></a><span>   (S2FunHarmonicSym)</span></td>
            <td>overloads sF1 .* sF2</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.times.html"><tt>times</tt></a><span>   (S2FunTri)</span></td>
            <td>.*  Array multiply. X.*Y denotes element-by-element multiplication. X and Y must have compatible sizes. In the simplest cases,
               they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension
               sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.times.html"><tt>times</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>Syntax sVF = sVF1.*sVF2 sVF = a.*sVF1 sVF = sVF1.*a</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.times.html"><tt>times</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>Syntax sVF = sVF .* sF sVF = sVF .* a</td>
            <tr></tr>
            <td width="250px"><a href="ODF.times.html"><tt>times</tt></a><span>   (ODF)</span></td>
            <td>scaling of the ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.times.html"><tt>times</tt></a><span>   (PoleFigure)</span></td>
            <td>implements pf1 .* b and a .* pf2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.times.html"><tt>times</tt></a><span>   (tensor)</span></td>
            <td>multiply a tensor by a scalar</td>
            <tr></tr>
            <td width="250px"><a href="crystalShape.times.html"><tt>times</tt></a><span>   (crystalShape)</span></td>
            <td>.*  Array multiply. X.*Y denotes element-by-element multiplication. X and Y must have compatible sizes. In the simplest cases,
               they can be the same size or one can be a scalar. Two inputs have compatible sizes if, for every dimension, the dimension
               sizes of the inputs are either the same or one of them is 1.
            </td>
            <tr></tr>
            <td width="250px"><a href="orientation.times.html"><tt>times</tt></a><span>   (orientation)</span></td>
            <td>vec = ori .* Miller</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.times.html"><tt>times</tt></a><span>   (quaternion)</span></td>
            <td>quaternion .* quaternion and quaternion .* vector3d</td>
            <tr></tr>
            <td width="250px"><a href="rotation.times.html"><tt>times</tt></a><span>   (rotation)</span></td>
            <td>r = a .* b</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.times.html"><tt>times</tt></a><span>   (vector3d)</span></td>
            <td>.* - componenwtise multiplication</td>
            <tr></tr>
            <td width="250px"><a href="times_outer.html"><tt>times_outer</tt></a></td>
            <td>times_outer is a function. x = times_outer(a, b)</td>
            <tr></tr>
            <td width="250px"><a href="tensor.trace.html"><tt>trace</tt></a><span>   (tensor)</span></td>
            <td>compute the traces of a rank 2 tensor</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.trace.html"><tt>trace</tt></a><span>   (slipSystem)</span></td>
            <td>trace of the slip plane in the surface normal to n</td>
            <tr></tr>
            <td width="250px"><a href="crystalSymmetry.transformationMatrix.html"><tt>transformationMatrix</tt></a><span>   (crystalSymmetry)</span></td>
            <td>compute the transformation matrix from cs1 to cs2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a><span>   (tensor)</span></td>
            <td>set properties of a tensor variable</td>
            <tr></tr>
            <td width="250px"><a href="Miller.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a><span>   (Miller)</span></td>
            <td>change reference frame while keeping hkl or uvw</td>
            <tr></tr>
            <td width="250px"><a href="orientation.transformReferenceFrame.html"><tt>transformReferenceFrame</tt></a><span>   (orientation)</span></td>
            <td>change reference frame of an orientation</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.transpose.html"><tt>transpose</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads transpose</td>
            <tr></tr>
            <td width="250px"><a href="tensor.transpose.html"><tt>transpose</tt></a><span>   (tensor)</span></td>
            <td>transpose a list of a tensors</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.transpose.html"><tt>transpose</tt></a><span>   (dislocationSystem)</span></td>
            <td>transpose list of slipSystem</td>
            <tr></tr>
            <td width="250px"><a href="fibre.transpose.html"><tt>transpose</tt></a><span>   (fibre)</span></td>
            <td>transpose list of slipSystem</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.transpose.html"><tt>transpose</tt></a><span>   (quaternion)</span></td>
            <td>transpose array of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="rotation.transpose.html"><tt>transpose</tt></a><span>   (rotation)</span></td>
            <td>transpose array of rotations</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.transpose.html"><tt>transpose</tt></a><span>   (slipSystem)</span></td>
            <td>transpose list of slipSystem</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.transpose.html"><tt>transpose</tt></a><span>   (vector3d)</span></td>
            <td>transpose vector</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.triangle.html"><tt>triangle</tt></a><span>   (sphericalRegion)</span></td>
            <td>define a spherical triangle by its vertices</td>
            <tr></tr>
            <td width="250px"><a href="triplePointList.triplePointList.html"><tt>triplePointList</tt></a><span>   (triplePointList)</span></td>
            <td>grainBoundary list of grain boundaries in 2-D</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.truncate.html"><tt>truncate</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>truncate neglectable coefficients this includes a bit of regularisation</td>
            <tr></tr>
            <td width="250px"><a href="TSLDirectionKey.html"><tt>TSLDirectionKey</tt></a></td>
            <td>converts directions to rgb values</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>U<a name="20"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="uiimport.html"><tt>uiimport</tt></a></td>
            <td>overload standard MATLAB uiimport</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.uminus.html"><tt>uminus</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>Syntax sF = -sF</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.uminus.html"><tt>uminus</tt></a><span>   (S2FunTri)</span></td>
            <td>-  Unary minus. -A negates the elements of A.</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldHarmonic.uminus.html"><tt>uminus</tt></a><span>   (S2VectorFieldHarmonic)</span></td>
            <td>Syntax sVF = -sVF</td>
            <tr></tr>
            <td width="250px"><a href="S2VectorFieldTri.uminus.html"><tt>uminus</tt></a><span>   (S2VectorFieldTri)</span></td>
            <td>-  Unary minus. -A negates the elements of A.</td>
            <tr></tr>
            <td width="250px"><a href="ODF.uminus.html"><tt>uminus</tt></a><span>   (ODF)</span></td>
            <td>superposeing two ODFs</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.uminus.html"><tt>uminus</tt></a><span>   (PoleFigure)</span></td>
            <td>implements -pf</td>
            <tr></tr>
            <td width="250px"><a href="tensor.uminus.html"><tt>uminus</tt></a><span>   (tensor)</span></td>
            <td>unary minus</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.uminus.html"><tt>uminus</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloads unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.uminus.html"><tt>uminus</tt></a><span>   (quaternion)</span></td>
            <td>overload unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="rotation.uminus.html"><tt>uminus</tt></a><span>   (rotation)</span></td>
            <td>implements -rotation</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.uminus.html"><tt>uminus</tt></a><span>   (slipSystem)</span></td>
            <td>overloads unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.uminus.html"><tt>uminus</tt></a><span>   (vector3d)</span></td>
            <td>overloads unitary minus</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.uniformComponent.html"><tt>uniformComponent</tt></a><span>   (uniformComponent)</span></td>
            <td>uniformComponent is a class. odf = uniformComponent(cs, ss, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="uniformODF.html"><tt>uniformODF</tt></a></td>
            <td>get crystal and specimen symmetry</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.unimodalComponent.html"><tt>unimodalComponent</tt></a><span>   (unimodalComponent)</span></td>
            <td>unimodalComponent is a class. component = unimodalComponent(center, psi, weights)</td>
            <tr></tr>
            <td width="250px"><a href="unimodalODF.html"><tt>unimodalODF</tt></a></td>
            <td>define a unimodal ODF</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.union.html"><tt>union</tt></a><span>   (PoleFigure)</span></td>
            <td>crytsallographic direction to one</td>
            <tr></tr>
            <td width="250px"><a href="symmetry.union.html"><tt>union</tt></a><span>   (symmetry)</span></td>
            <td>returns the union of two symmetry groups</td>
            <tr></tr>
            <td width="250px"><a href="PoleFigure.unique.html"><tt>unique</tt></a><span>   (PoleFigure)</span></td>
            <td>remove dublicated points in a polefigure</td>
            <tr></tr>
            <td width="250px"><a href="Miller.unique.html"><tt>unique</tt></a><span>   (Miller)</span></td>
            <td>disjoint list of Miller indices</td>
            <tr></tr>
            <td width="250px"><a href="orientation.unique.html"><tt>unique</tt></a><span>   (orientation)</span></td>
            <td>disjoint list of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.unique.html"><tt>unique</tt></a><span>   (quaternion)</span></td>
            <td>disjoint list of quaternions</td>
            <tr></tr>
            <td width="250px"><a href="rotation.unique.html"><tt>unique</tt></a><span>   (rotation)</span></td>
            <td>disjoint list of rotations</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.unique.html"><tt>unique</tt></a><span>   (vector3d)</span></td>
            <td>disjoint list of vectors</td>
            <tr></tr>
            <td width="250px"><a href="EBSD.updateUnitCell.html"><tt>updateUnitCell</tt></a><span>   (EBSD)</span></td>
            <td>this function should be called after the spatial coordinates of an EBSD data set have been modified</td>
            <tr></tr>
            <td width="250px"><a href="UpDown.html"><tt>UpDown</tt></a></td>
            <td>UpDown is a function. out = UpDown(in)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>V<a name="21"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="orientation.variants.html"><tt>variants</tt></a><span>   (orientation)</span></td>
            <td>variants of an orientation relationship</td>
            <tr></tr>
            <td width="250px"><a href="varlink.html"><tt>varlink</tt></a></td>
            <td>link to a variable</td>
            <tr></tr>
            <td width="250px"><a href="vdisp.html"><tt>vdisp</tt></a></td>
            <td>vdisp is a function. vdisp(s, varargin)</td>
            <tr></tr>
            <td width="250px"><a href="vec2cell.html"><tt>vec2cell</tt></a></td>
            <td>vec2cell is a function. c = vec2cell(v)</td>
            <tr></tr>
            <td width="250px"><a href="vec42quat.html"><tt>vec42quat</tt></a></td>
            <td>returns a quaternion q with q u_1 = v1 and q u2 = v2</td>
            <tr></tr>
            <td width="250px"><a href="tensor.vector3d.html"><tt>vector3d</tt></a><span>   (tensor)</span></td>
            <td>convert rank one tensors to vector3d</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.vector3d.html"><tt>vector3d</tt></a><span>   (vector3d)</span></td>
            <td>Constructor</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.velocity.html"><tt>velocity</tt></a><span>   (complianceTensor)</span></td>
            <td>computes the elastic wave velocity(km/s) from the elastic stiffness Cijkl tensor and density (g/cm3)</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.velocity.html"><tt>velocity</tt></a><span>   (stiffnessTensor)</span></td>
            <td>computes the elastic wave velocity(km/s) from the elastic stiffness Cijkl tensor and density (g/cm3)</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.velocityGradientTensor.html"><tt>velocityGradientTensor</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>velocityGradientTensor is a class. L = velocityGradientTensor(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.vertcat.html"><tt>vertcat</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>overloads vertcat</td>
            <tr></tr>
            <td width="250px"><a href="tensor.vertcat.html"><tt>vertcat</tt></a><span>   (tensor)</span></td>
            <td>overloads [T1,T2,T3..]</td>
            <tr></tr>
            <td width="250px"><a href="dislocationSystem.vertcat.html"><tt>vertcat</tt></a><span>   (dislocationSystem)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="fibre.vertcat.html"><tt>vertcat</tt></a><span>   (fibre)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="quaternion.vertcat.html"><tt>vertcat</tt></a><span>   (quaternion)</span></td>
            <td>implements [q1;q2;q3..]</td>
            <tr></tr>
            <td width="250px"><a href="slipSystem.vertcat.html"><tt>vertcat</tt></a><span>   (slipSystem)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="vector3d.vertcat.html"><tt>vertcat</tt></a><span>   (vector3d)</span></td>
            <td>overloads [v1,v2,v3..]</td>
            <tr></tr>
            <td width="250px"><a href="viridisColorMap.html"><tt>viridisColorMap</tt></a></td>
            <td>viridisColorMap is a function. varargout = viridisColorMap(varargin)</td>
            <tr></tr>
            <td width="250px"><a href="tensor.Voigt.html"><tt>Voigt</tt></a><span>   (tensor)</span></td>
            <td>tensor/Voigt is a function. V = Voigt(T)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunHarmonic.volume.html"><tt>volume</tt></a><span>   (S2FunHarmonic)</span></td>
            <td>S2FunHarmonic/volume is a function. sF = volume(sF1, center, radius)</td>
            <tr></tr>
            <td width="250px"><a href="S2FunTri.volume.html"><tt>volume</tt></a><span>   (S2FunTri)</span></td>
            <td>S2FunTri/volume is a function. sF = volume(sF1, center, radius)</td>
            <tr></tr>
            <td width="250px"><a href="ODF.volume.html"><tt>volume</tt></a><span>   (ODF)</span></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="ODFComponent.volume.html"><tt>volume</tt></a><span>   (ODFComponent)</span></td>
            <td>get resolution</td>
            <tr></tr>
            <td width="250px"><a href="uniformComponent.volume.html"><tt>volume</tt></a><span>   (uniformComponent)</span></td>
            <td>for large angles or specimen symmetry take the quadrature based algorithm</td>
            <tr></tr>
            <td width="250px"><a href="unimodalComponent.volume.html"><tt>volume</tt></a><span>   (unimodalComponent)</span></td>
            <td>for large angles or specimen symmetry take the quadrature based algorithm</td>
            <tr></tr>
            <td width="250px"><a href="orientation.volume.html"><tt>volume</tt></a><span>   (orientation)</span></td>
            <td>ratio of orientations with a certain orientation</td>
            <tr></tr>
            <td width="250px"><a href="orientationRegion.volume.html"><tt>volume</tt></a><span>   (orientationRegion)</span></td>
            <td>volume of an orientation region</td>
            <tr></tr>
            <td width="250px"><a href="sphericalRegion.volume.html"><tt>volume</tt></a><span>   (sphericalRegion)</span></td>
            <td>volume of a spherical region</td>
            <tr></tr>
            <td width="250px"><a href="kernel.volume.html"><tt>volume</tt></a><span>   (kernel)</span></td>
            <td>kernel/volume is a function. [vol, dist] = volume(psi, radius, dist)</td>
            <tr></tr>
            <td width="250px"><a href="complianceTensor.volumeCompressibility.html"><tt>volumeCompressibility</tt></a><span>   (complianceTensor)</span></td>
            <td>computes the volume compressibility of an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.volumeCompressibility.html"><tt>volumeCompressibility</tt></a><span>   (stiffnessTensor)</span></td>
            <td>volume compressibility of an elasticity stiffness tensor</td>
            <tr></tr>
            <td width="250px"><a href="vonMisesFisherKernel.html"><tt>vonMisesFisherKernel</tt></a></td>
            <td>extract parameter and halfwidth</td>
            <tr></tr>
            <td width="250px"><a href="velocityGradientTensor.vorticity.html"><tt>vorticity</tt></a><span>   (velocityGradientTensor)</span></td>
            <td>vorticity Gamma</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>W<a name="22"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="white2blackColorMap.html"><tt>white2blackColorMap</tt></a></td>
            <td>gray   Linear gray-scale color map</td>
            <tr></tr>
            <td width="250px"><a href="WhiteJetColorMap.html"><tt>WhiteJetColorMap</tt></a></td>
            <td>WhiteJetColorMap is a function. map = WhiteJetColorMap(n)</td>
            <tr></tr>
            <td width="250px"><a href="Wigner3j.html"><tt>Wigner3j</tt></a></td>
            <td>Compute the Wigner 3j symbol using the Racah formula.</td>
            <tr></tr>
            <td width="250px"><a href="Wigner3j_new.html"><tt>Wigner3j_new</tt></a></td>
            <td>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</td>
            <tr></tr>
            <td width="250px"><a href="Wigner3jPrecomputed.html"><tt>Wigner3jPrecomputed</tt></a></td>
            <td>Wigner3jPrecomputed is a function. wigner = Wigner3jPrecomputed(l, L, m1, m2)</td>
            <tr></tr>
            <td width="250px"><a href="WignerD.html"><tt>WignerD</tt></a></td>
            <td>Wigner-D function</td>
            <tr></tr>
            <td width="250px"><a href="wignerD2.html"><tt>wignerD2</tt></a></td>
            <td>spherical harmonics of degree l</td>
            <tr></tr>
            <td width="250px"><a href="write_cell.html"><tt>write_cell</tt></a></td>
            <td>write cell string to text file</td>
            <tr></tr>
            <td width="250px"><a href="writedouble.html"><tt>writedouble</tt></a></td>
            <td>write to file</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>X<a name="23"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="xnum2str.html"><tt>xnum2str</tt></a></td>
            <td>convert number to string</td>
            <tr></tr>
            <td width="250px"><a href="xvector.html"><tt>xvector</tt></a></td>
            <td>vector (1,0,0)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>Y<a name="24"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="complianceTensor.YoungsModulus.html"><tt>YoungsModulus</tt></a><span>   (complianceTensor)</span></td>
            <td>Young's modulus for an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="stiffnessTensor.YoungsModulus.html"><tt>YoungsModulus</tt></a><span>   (stiffnessTensor)</span></td>
            <td>Young's modulus for an elasticity tensor</td>
            <tr></tr>
            <td width="250px"><a href="yvector.html"><tt>yvector</tt></a></td>
            <td>vector (0,1,0)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <h2>Z<a name="25"> </a></h2>
         <table width="95%">
            <tr></tr>
            <td width="250px"><a href="zeroRangeMethod.zeroRangeMethod.html"><tt>zeroRangeMethod</tt></a><span>   (zeroRangeMethod)</span></td>
            <td>calculate zero range</td>
            <tr></tr>
            <td width="250px"><a href="zUpDown.html"><tt>zUpDown</tt></a></td>
            <td>zUpDown is a function. v = zUpDown</td>
            <tr></tr>
            <td width="250px"><a href="zvector.html"><tt>zvector</tt></a></td>
            <td>vector (0,0,1)</td>
         </table>
         <p class="pagenavlink"><script language="Javascript">addTopOfPageButtons();</script><a href="#top_of_page">Back to Top</a></p>
         <p style="font-size:1px;"></p>
         <table class="footer" border="0" width="100%" cellpadding="0" cellspacing="0">
            <tr>
               <td valign="baseline" align="right">MTEX 5.2.beta2</td>
            </tr>
         </table>
      </div>
   </body>
</html>